{
        "Unterminated string literal.": "Niezakończony literał ciągu.",
        "Identifier expected.": "Oczekiwano identyfikatora.",
        "'{0}' expected.": "Oczekiwano elementu „{0}”.",
        "A file cannot have a reference to itself.": "Plik nie może przywoływać samego siebie.",
        "Trailing comma not allowed.": "Końcowy przecinek jest niedozwolony.",
        "'*/' expected.": "Oczekiwano ciągu „*/”.",
        "Unexpected token.": "Nieoczekiwany token.",
        "A rest parameter must be last in a parameter list.": "Parametr rest musi występować na końcu listy parametrów.",
        "Parameter cannot have question mark and initializer.": "Parametr nie może mieć znaku zapytania i inicjatora.",
        "A required parameter cannot follow an optional parameter.": "Wymagany parametr nie może występować po opcjonalnym parametrze.",
        "An index signature cannot have a rest parameter.": "Sygnatura indeksu nie może mieć parametru rest.",
        "An index signature parameter cannot have an accessibility modifier.": "Parametr sygnatury indeksu nie może mieć modyfikatora dostępności.",
        "An index signature parameter cannot have a question mark.": "Parametr sygnatury indeksu nie może zawierać znaku zapytania.",
        "An index signature parameter cannot have an initializer.": "Parametr sygnatury indeksu nie może mieć inicjatora.",
        "An index signature must have a type annotation.": "Sygnatura indeksu musi mieć adnotację typu.",
        "An index signature parameter must have a type annotation.": "Parametr sygnatury indeksu musi mieć adnotację typu.",
        "An index signature parameter type must be 'string' or 'number'.": "Parametr sygnatury indeksu musi być typu „string” lub „number”.",
        "Accessibility modifier already seen.": "Napotkano już modyfikator dostępności.",
        "'{0}' modifier must precede '{1}' modifier.": "Modyfikator „{0}” musi występować przed modyfikatorem „{1}”.",
        "'{0}' modifier already seen.": "Napotkano już modyfikator „{0}”.",
        "'{0}' modifier cannot appear on a class element.": "Modyfikator „{0}” nie może występować w elemencie klasy.",
        "'super' must be followed by an argument list or member access.": "Po elemencie „super” musi występować lista argumentów lub metoda dostępu do elementu członkowskiego.",
        "Only ambient modules can use quoted names.": "Tylko otaczające moduły mogą używać nazw w cudzysłowie.",
        "Statements are not allowed in ambient contexts.": "Instrukcje są niedozwolone w otaczających kontekstach.",
        "A 'declare' modifier cannot be used in an already ambient context.": "Nie można użyć modyfikatora „declare” w otaczającym kontekście.",
        "Initializers are not allowed in ambient contexts.": "Inicjatory są niedozwolone w otaczających kontekstach.",
        "'{0}' modifier cannot be used in an ambient context.": "Modyfikatora „{0}” nie można użyć w otaczającym kontekście.",
        "'{0}' modifier cannot be used with a class declaration.": "Modyfikatora „{0}” nie można używać z deklaracją klasy.",
        "'{0}' modifier cannot be used here.": "Modyfikatora „{0}” nie można użyć w tym miejscu.",
        "'{0}' modifier cannot appear on a data property.": "Modyfikator „{0}” nie może występować we właściwości danych.",
        "'{0}' modifier cannot appear on a module element.": "Modyfikator „{0}” nie może występować w elemencie modułu.",
        "A '{0}' modifier cannot be used with an interface declaration.": "Modyfikatora „{0}” nie można używać z deklaracją interfejsu.",
        "A 'declare' modifier is required for a top level declaration in a .d.ts file.": "Wymagany jest modyfikator „declare” deklaracji najwyższego poziomu w pliku d.ts.",
        "A rest parameter cannot be optional.": "Parametr rest nie może być opcjonalny.",
        "A rest parameter cannot have an initializer.": "Parametr rest nie może mieć inicjatora.",
        "A 'set' accessor must have exactly one parameter.": "Metoda dostępu „set” musi mieć dokładnie jeden parametr.",
        "A 'set' accessor cannot have an optional parameter.": "Metoda dostępu „set” nie może mieć parametru opcjonalnego.",
        "A 'set' accessor parameter cannot have an initializer.": "Parametr metody dostępu „set” nie może mieć inicjatora.",
        "A 'set' accessor cannot have rest parameter.": "Metoda dostępu „set” nie może mieć parametru rest.",
        "A 'get' accessor cannot have parameters.": "Metoda dostępu „get” nie może mieć parametrów.",
        "Type '{0}' is not a valid async function return type.": "Typ „{0}” nie jest prawidłowym typem zwracanym funkcji asynchronicznej.",
        "Accessors are only available when targeting ECMAScript 5 and higher.": "Metody dostępu są dostępne tylko wtedy, gdy jest używany język ECMAScript 5 lub nowszy.",
        "An async function or method must have a valid awaitable return type.": "Funkcja lub metoda asynchroniczna musi mieć prawidłowy oczekujący typ zwracany.",
        "Operand for 'await' does not have a valid callable 'then' member.": "Argumenty operacji „await” nie mają prawidłowego elementu członkowskiego „then”, który można wywołać.",
        "Return expression in async function does not have a valid callable 'then' member.": "Wyrażenie zwracane w funkcji asynchronicznej nie ma prawidłowego elementu członkowskiego „then”, który można wywołać.",
        "Expression body for async arrow function does not have a valid callable 'then' member.": "Treść wyrażenia asynchronicznej funkcji strzałkowej nie ma prawidłowego elementu członkowskiego „then”, który można wywołać.",
        "Enum member must have initializer.": "Element członkowski wyliczenia musi mieć inicjator.",
        "{0} is referenced directly or indirectly in the fulfillment callback of its own 'then' method.": "Element {0} jest przywoływany bezpośrednio lub pośrednio w wywołaniu wypełniania własnej metody „then”.",
        "An export assignment cannot be used in a namespace.": "Nie można użyć przypisania eksportu w przestrzeni nazw.",
        "Ambient enum elements can only have integer literal initializers.": "Otaczające elementy wyliczenia mogą mieć tylko inicjatory literałów liczb całkowitych.",
        "Unexpected token. A constructor, method, accessor, or property was expected.": "Nieoczekiwany token. Oczekiwano konstruktora, metody, metody dostępu lub właściwości.",
        "A '{0}' modifier cannot be used with an import declaration.": "Modyfikatora „{0}” nie można używać z deklaracją importu.",
        "Invalid 'reference' directive syntax.": "Nieprawidłowa składnia dyrektywy „reference”.",
        "Octal literals are not available when targeting ECMAScript 5 and higher.": "Literały ósemkowe są niedostępne w przypadku języka docelowego ECMAScript 5 lub nowszego.",
        "An accessor cannot be declared in an ambient context.": "Metoda dostępu nie może być zadeklarowana w otaczającym kontekście.",
        "'{0}' modifier cannot appear on a constructor declaration.": "Modyfikator „{0}” nie może występować w deklaracji konstruktora.",
        "'{0}' modifier cannot appear on a parameter.": "Modyfikator „{0}” nie może występować w parametrze.",
        "Only a single variable declaration is allowed in a 'for...in' statement.": "W instrukcji „for...in” jest dozwolona tylko pojedyncza deklaracja zmiennej.",
        "Type parameters cannot appear on a constructor declaration.": "Parametry typu nie mogą występować w deklaracji konstruktora.",
        "Type annotation cannot appear on a constructor declaration.": "Adnotacja typu nie może występować w deklaracji konstruktora.",
        "An accessor cannot have type parameters.": "Metoda dostępu nie może mieć parametrów typu.",
        "A 'set' accessor cannot have a return type annotation.": "Metoda dostępu „set” nie może mieć adnotacji zwracanego typu.",
        "An index signature must have exactly one parameter.": "Sygnatura indeksu musi mieć dokładnie jeden parametr.",
        "'{0}' list cannot be empty.": "Lista „{0}” nie może być pusta.",
        "Type parameter list cannot be empty.": "Lista parametrów typu nie może być pusta.",
        "Type argument list cannot be empty.": "Lista argumentów typu nie może być pusta.",
        "Invalid use of '{0}' in strict mode.": "Nieprawidłowe użycie elementu „{0}” w trybie z ograniczeniami.",
        "'with' statements are not allowed in strict mode.": "Instrukcje „with” są niedozwolone w trybie z ograniczeniami.",
        "'delete' cannot be called on an identifier in strict mode.": "Nie można wywołać elementu „delete” dla identyfikatora w trybie z ograniczeniami.",
        "A 'continue' statement can only be used within an enclosing iteration statement.": "Instrukcji „continue” można użyć tylko w otaczającej instrukcji iteracji.",
        "A 'break' statement can only be used within an enclosing iteration or switch statement.": "Instrukcji „break” można użyć tylko w ramach otaczającej instrukcji iteracji lub switch.",
        "Jump target cannot cross function boundary.": "Cel skoku nie może występować poza granicą funkcji.",
        "A 'return' statement can only be used within a function body.": "Instrukcji „return” można użyć tylko w treści funkcji.",
        "Expression expected.": "Oczekiwano wyrażenia.",
        "Type expected.": "Oczekiwano typu.",
        "A class member cannot be declared optional.": "Element członkowski klasy nie może być zadeklarowany jako opcjonalny.",
        "A 'default' clause cannot appear more than once in a 'switch' statement.": "Klauzula „default” nie może występować więcej niż raz w instrukcji „switch”.",
        "Duplicate label '{0}'": "Zduplikowana etykieta „{0}”",
        "A 'continue' statement can only jump to a label of an enclosing iteration statement.": "Instrukcja „continue” może wykonać skok tylko do etykiety otaczającej instrukcji iteracji.",
        "A 'break' statement can only jump to a label of an enclosing statement.": "Instrukcja „break” może wykonać skok tylko do etykiety otaczającej instrukcji.",
        "An object literal cannot have multiple properties with the same name in strict mode.": "Literał obiektu nie może mieć wielu właściwości o takiej samej nazwie w trybie z ograniczeniami.",
        "An object literal cannot have multiple get/set accessors with the same name.": "Literał obiektu nie może mieć wielu metod dostępu pobierania/ustawiania o takiej samej nazwie.",
        "An object literal cannot have property and accessor with the same name.": "Literał obiektu nie może mieć właściwości i metody dostępu o takiej samej nazwie.",
        "An export assignment cannot have modifiers.": "Przypisanie eksportu nie może mieć modyfikatorów.",
        "Octal literals are not allowed in strict mode.": "Literały ósemkowe są niedozwolone w trybie z ograniczeniami.",
        "A tuple type element list cannot be empty.": "Lista elementów typu spójnej kolekcji nie może być pusta.",
        "Variable declaration list cannot be empty.": "Lista deklaracji zmiennych nie może być pusta.",
        "Digit expected.": "Oczekiwano cyfry.",
        "Hexadecimal digit expected.": "Oczekiwano cyfry szesnastkowej.",
        "Unexpected end of text.": "Nieoczekiwany koniec tekstu.",
        "Invalid character.": "Nieprawidłowy znak.",
        "Declaration or statement expected.": "Oczekiwano deklaracji lub instrukcji.",
        "Statement expected.": "Oczekiwano instrukcji.",
        "'case' or 'default' expected.": "Oczekiwano elementu „case” lub „default”.",
        "Property or signature expected.": "Oczekiwano właściwości lub sygnatury.",
        "Enum member expected.": "Oczekiwano elementu członkowskiego wyliczenia.",
        "Variable declaration expected.": "Oczekiwano deklaracji zmiennej.",
        "Argument expression expected.": "Oczekiwano wyrażenia argumentu.",
        "Property assignment expected.": "Oczekiwano przypisania właściwości.",
        "Expression or comma expected.": "Oczekiwano wyrażenia lub przecinka.",
        "Parameter declaration expected.": "Oczekiwano deklaracji parametru.",
        "Type parameter declaration expected.": "Oczekiwano deklaracji parametru typu.",
        "Type argument expected.": "Oczekiwano argumentu typu.",
        "String literal expected.": "Oczekiwano literału ciągu.",
        "Line break not permitted here.": "Podział wiersza nie jest tutaj dozwolony.",
        "'{' or ';' expected.": "Oczekiwano znaku „{” lub „;”.",
        "Modifiers not permitted on index signature members.": "Modyfikatory nie są dozwolone w elementach członkowskich sygnatury indeksu.",
        "Declaration expected.": "Oczekiwano deklaracji.",
        "Import declarations in a namespace cannot reference a module.": "Deklaracje importu w przestrzeni nazw nie mogą odwoływać się do modułu.",
        "Cannot compile modules unless the '--module' flag is provided.": "Nie można skompilować modułów, jeśli nie podano flagi „--module”.",
        "File name '{0}' differs from already included file name '{1}' only in casing": "Nazwa pliku „{0}” różni się od już dołączonej nazwy pliku „{1}” tylko wielkością liter",
        "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.": "Nie można użyć instrukcji „new T[]” do utworzenia tablicy. Zamiast tego użyj instrukcji „new Array<T>()”.",
        "'const' declarations must be initialized": "Konieczne jest zainicjowanie deklaracji „const”",
        "'const' declarations can only be declared inside a block.": "Deklaracje „const” mogą być deklarowane tylko w bloku.",
        "'let' declarations can only be declared inside a block.": "Deklaracje „let” mogą być deklarowane tylko w bloku.",
        "Unterminated template literal.": "Niezakończony literał szablonu.",
        "Unterminated regular expression literal.": "Niezakończony literał wyrażenia regularnego.",
        "An object member cannot be declared optional.": "Element członkowski obiektu nie może być zadeklarowany jako opcjonalny.",
        "A 'yield' expression is only allowed in a generator body.": "Wyrażenie „yield” jest dozwolone tylko w treści generatora.",
        "Computed property names are not allowed in enums.": "Obliczone nazwy właściwości nie są dozwolone w wyliczeniach.",
        "A computed property name in an ambient context must directly refer to a built-in symbol.": "Obliczona nazwa właściwości w otaczającym kontekście musi odwoływać się bezpośrednio do wbudowanego symbolu.",
        "A computed property name in a class property declaration must directly refer to a built-in symbol.": "Obliczona nazwa właściwości w deklaracji właściwości klasy musi odwoływać się bezpośrednio do wbudowanego symbolu.",
        "A computed property name in a method overload must directly refer to a built-in symbol.": "Obliczona nazwa właściwości w przeciążeniu metody musi odwoływać się bezpośrednio do wbudowanego symbolu.",
        "A computed property name in an interface must directly refer to a built-in symbol.": "Obliczona nazwa właściwości w interfejsie musi odwoływać się bezpośrednio do wbudowanego symbolu.",
        "A computed property name in a type literal must directly refer to a built-in symbol.": "Obliczona nazwa właściwości w literale typu musi odwoływać się bezpośrednio do wbudowanego symbolu.",
        "A comma expression is not allowed in a computed property name.": "Wyrażenie przecinkowe nie jest dozwolone w obliczonej nazwie właściwości.",
        "'extends' clause already seen.": "Napotkano już klauzulę „extends”.",
        "'extends' clause must precede 'implements' clause.": "Klauzula „extends” musi poprzedzać klauzulę „implements”.",
        "Classes can only extend a single class.": "Klasy mogą rozszerzać tylko pojedynczą klasę.",
        "'implements' clause already seen.": "Napotkano już klauzulę „implements”.",
        "Interface declaration cannot have 'implements' clause.": "Deklaracja interfejsu nie może mieć klauzuli „implements”.",
        "Binary digit expected.": "Oczekiwano bitu.",
        "Octal digit expected.": "Oczekiwano cyfry ósemkowej.",
        "Unexpected token. '{' expected.": "Nieoczekiwany token. Oczekiwano znaku „{”.",
        "Property destructuring pattern expected.": "Oczekiwano wzorca usuwającego strukturę właściwości.",
        "Array element destructuring pattern expected.": "Oczekiwano wzorca usuwającego strukturę elementu tablicy.",
        "A destructuring declaration must have an initializer.": "Deklaracja usuwająca strukturę musi mieć inicjator.",
        "An implementation cannot be declared in ambient contexts.": "Implementacja nie może być zadeklarowana w otaczających kontekstach.",
        "Modifiers cannot appear here.": "Modyfikatory nie mogą występować w tym miejscu.",
        "Merge conflict marker encountered.": "Napotkano znacznik konfliktu scalania.",
        "A rest element cannot have an initializer.": "Element rest nie może mieć inicjatora.",
        "A parameter property may not be a binding pattern.": "Właściwość parametru nie może być wzorcem powiązania.",
        "Only a single variable declaration is allowed in a 'for...of' statement.": "W instrukcji „for...of” jest dozwolona tylko pojedyncza deklaracja zmiennej.",
        "The variable declaration of a 'for...in' statement cannot have an initializer.": "Deklaracja zmiennej instrukcji „for...in” nie może mieć inicjatora.",
        "The variable declaration of a 'for...of' statement cannot have an initializer.": "Deklaracja zmiennej instrukcji „for...of” nie może mieć inicjatora.",
        "An import declaration cannot have modifiers.": "Deklaracja importu nie może mieć modyfikatorów.",
        "Module '{0}' has no default export.": "Moduł „{0}” nie ma eksportu domyślnego.",
        "An export declaration cannot have modifiers.": "Deklaracja eksportu nie może mieć modyfikatorów.",
        "Export declarations are not permitted in a namespace.": "Deklaracje eksportu są niedozwolone w przestrzeni nazw.",
        "Catch clause variable name must be an identifier.": "Zmienna klauzuli catch musi być identyfikatorem.",
        "Catch clause variable cannot have a type annotation.": "Zmienna klauzuli catch nie może mieć adnotacji typu.",
        "Catch clause variable cannot have an initializer.": "Zmienna klauzuli catch nie może mieć inicjatora.",
        "An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.": "Rozszerzona wartość znaku ucieczki Unicode musi należeć do zakresu od 0x0 do 0x10FFFF (włącznie).",
        "Unterminated Unicode escape sequence.": "Niezakończona sekwencja specjalna kodu Unicode.",
        "Line terminator not permitted before arrow.": "Terminator wiersza nie jest dozwolony przed strzałką.",
        "Import assignment cannot be used when targeting ECMAScript 6 or higher. Consider using 'import * as ns from \"mod\"', 'import {a} from \"mod\"' or 'import d from \"mod\"' instead.": "Nie można użyć przypisania importu, gdy jest używany język ECMAScript 6 lub nowszy. Zamiast tego rozważ użycie elementu „import * as ns from \"mod\"”, „import {a} from \"mod\"” lub „import d from \"mod\"”.",
        "Export assignment cannot be used when targeting ECMAScript 6 or higher. Consider using 'export default' instead.": "Nie można użyć przypisania eksportu, gdy jest używany język ECMAScript 6 lub nowszy. Zamiast tego rozważ użycie elementu „export default”.",
        "Cannot compile modules into 'commonjs', 'amd', 'system' or 'umd' when targeting 'ES6' or higher.": "Nie można skompilować modułów do struktury „commonjs”, „amd”, „system” lub „umd” w przypadku korzystania z języka „ES6” lub nowszego.",
        "Decorators are only available when targeting ECMAScript 5 and higher.": "Elementy Decorator są dostępne tylko wtedy, gdy jest używany język ECMAScript 5 lub nowszy.",
        "Decorators are not valid here.": "Elementy Decorator nie są tutaj prawidłowe.",
        "Decorators cannot be applied to multiple get/set accessors of the same name.": "Nie można stosować elementów Decorator do wielu metod dostępu pobierania/ustawiania o takiej samej nazwie.",
        "Cannot compile namespaces when the '--isolatedModules' flag is provided.": "Nie można skompilować przestrzeni nazw, jeśli podano flagę „--isolatedModules”.",
        "Ambient const enums are not allowed when the '--isolatedModules' flag is provided.": "Otaczające wyliczenia const nie są dozwolone w przypadku podania flagi „--isolatedModules”.",
        "Invalid use of '{0}'. Class definitions are automatically in strict mode.": "Nieprawidłowe użycie elementu „{0}”. Definicje klas są określane automatycznie w trybie z ograniczeniami.",
        "A class declaration without the 'default' modifier must have a name": "Deklaracja klasy bez modyfikatora „default” musi mieć nazwę",
        "Identifier expected. '{0}' is a reserved word in strict mode": "Oczekiwano identyfikatora. „{0}” jest wyrazem zastrzeżonym w trybie z ograniczeniami",
        "Identifier expected. '{0}' is a reserved word in strict mode. Class definitions are automatically in strict mode.": "Oczekiwano identyfikatora. „{0}” jest wyrazem zastrzeżonym w trybie z ograniczeniami. Definicje klas są określane automatycznie w trybie z ograniczeniami.",
        "Identifier expected. '{0}' is a reserved word in strict mode. Modules are automatically in strict mode.": "Oczekiwano identyfikatora. Element „{0}” jest wyrazem zastrzeżonym w trybie z ograniczeniami. Moduły są określane automatycznie w trybie z ograniczeniami.",
        "Invalid use of '{0}'. Modules are automatically in strict mode.": "Nieprawidłowe użycie elementu „{0}”. Moduły są określane automatycznie w trybie z ograniczeniami.",
        "Export assignment is not supported when '--module' flag is 'system'.": "Przypisanie eksportu nie jest obsługiwane, gdy flaga „--module” ma postać „system”.",
        "Experimental support for decorators is a feature that is subject to change in a future release. Specify '--experimentalDecorators' to remove this warning.": "Obsługa eksperymentalna elementów Decorator może ulec zmianie w nowszych wersjach. Określ opcję „--experimentalDecorators”, aby usunąć to ostrzeżenie.",
        "Generators are only available when targeting ECMAScript 6 or higher.": "Generatory są dostępne tylko wtedy, gdy jest używany język ECMAScript 6 lub nowszy.",
        "Generators are not allowed in an ambient context.": "Generatory nie są dozwolone w otaczającym kontekście.",
        "An overload signature cannot be declared as a generator.": "Podpis przeciążenia nie może być zadeklarowany jako generator.",
        "'{0}' tag already specified.": "Tag „{0}” jest już określony.",
        "Signature '{0}' must have a type predicate.": "Sygnatura „{0}” musi mieć predykat typu.",
        "Cannot find parameter '{0}'.": "Nie można odnaleźć parametru „{0}”.",
        "Type predicate '{0}' is not assignable to '{1}'.": "Predykatu typu „{0}” nie można przypisać do elementu „{1}”.",
        "Parameter '{0}' is not in the same position as parameter '{1}'.": "Parametr „{0}” nie znajduje się w tym samym położeniu co parametr „{1}”.",
        "A type predicate is only allowed in return type position for functions and methods.": "Predykat typu jest dozwolony tylko w położeniu typu zwracanego dla funkcji i metod.",
        "A type predicate cannot reference a rest parameter.": "Predykat typu nie może zawierać odwołania do parametru rest.",
        "A type predicate cannot reference element '{0}' in a binding pattern.": "Predykat typu nie może zawierać odwołania do elementu „{0}” we wzorcu powiązania.",
        "An export assignment can only be used in a module.": "Przypisanie eksportu może być używane tylko w module.",
        "An import declaration can only be used in a namespace or module.": "Deklaracja importu może być używana tylko w przestrzeni nazw lub module.",
        "An export declaration can only be used in a module.": "Deklaracja eksportu może być używana tylko w module.",
        "An ambient module declaration is only allowed at the top level in a file.": "Deklaracja otaczającego modułu jest dozwolona tylko na najwyższym poziomie pliku.",
        "A namespace declaration is only allowed in a namespace or module.": "Deklaracja przestrzeni nazw jest dozwolona tylko w przestrzeni nazw lub module.",
        "Experimental support for async functions is a feature that is subject to change in a future release. Specify '--experimentalAsyncFunctions' to remove this warning.": "Obsługa eksperymentalna funkcji asynchronicznych może ulec zmianie w nowszych wersjach. Określ opcję „--experimentalAsyncFunctions”, aby usunąć to ostrzeżenie.",
        "'with' statements are not allowed in an async function block.": "Instrukcje „with” są niedozwolone w bloku funkcji asynchronicznej.",
        "'await' expression is only allowed within an async function.": "Wyrażenie „await” jest dozwolone tylko w funkcji asynchronicznej.",
        "Async functions are only available when targeting ECMAScript 6 and higher.": "Funkcje asynchroniczne są dostępne tylko wtedy, gdy używany jest język ECMAScript 6 lub nowszy.",
        "The return type of a property decorator function must be either 'void' or 'any'.": "Typ zwracany funkcji dekoratora właściwości musi mieć postać „void” lub „any”.",
        "The return type of a parameter decorator function must be either 'void' or 'any'.": "Typ zwracany funkcji dekoratora parametrów musi mieć postać „void” lub „any”.",
        "Unable to resolve signature of class decorator when called as an expression.": "Nie można rozpoznać sygnatury dekoratora klasy wywołanego jako wyrażenie.",
        "Unable to resolve signature of parameter decorator when called as an expression.": "Nie można rozpoznać sygnatury dekoratora parametru wywołanego jako wyrażenie.",
        "Unable to resolve signature of property decorator when called as an expression.": "Nie można rozpoznać sygnatury dekoratora właściwości wywołanego jako wyrażenie.",
        "Unable to resolve signature of method decorator when called as an expression.": "Nie można rozpoznać sygnatury dekoratora metody wywołanego jako wyrażenie.",
        "'abstract' modifier can only appear on a class or method declaration.": "Modyfikator „abstract” może występować tylko w klasie lub deklaracji metody.",
        "'{0}' modifier cannot be used with '{1}' modifier.": "Modyfikatora „{0}” nie można używać z modyfikatorem „{1}”.",
        "Abstract methods can only appear within an abstract class.": "Metody abstrakcyjne mogą występować tylko w klasie abstrakcyjnej.",
        "Method '{0}' cannot have an implementation because it is marked abstract.": "Metoda „{0}” nie może mieć implementacji, ponieważ jest oznaczona jako abstrakcyjna.",
        "Duplicate identifier '{0}'.": "Zduplikowany identyfikator „{0}”.",
        "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.": "Inicjator zmiennej elementu członkowskiego wystąpienia „{0}” nie może przywoływać identyfikatora „{1}” zadeklarowanego w konstruktorze.",
        "Static members cannot reference class type parameters.": "Statyczne elementy członkowskie nie mogą przywoływać parametrów typu klasy.",
        "Circular definition of import alias '{0}'.": "Definicja cykliczna aliasu importu „{0}”.",
        "Cannot find name '{0}'.": "Nie można odnaleźć nazwy „{0}”.",
        "Module '{0}' has no exported member '{1}'.": "Moduł „{0}” nie ma wyeksportowanego elementu członkowskiego „{1}”.",
        "File '{0}' is not a module.": "Plik „{0}” nie jest modułem.",
        "Cannot find module '{0}'.": "Nie można odnaleźć modułu „{0}”.",
        "An export assignment cannot be used in a module with other exported elements.": "Nie można użyć przypisania eksportu w module z innymi eksportowanymi elementami.",
        "Type '{0}' recursively references itself as a base type.": "Typ „{0}” rekursywnie przywołuje siebie jako typ podstawowy.",
        "A class may only extend another class.": "Klasa może rozszerzać tylko inną klasę.",
        "An interface may only extend a class or another interface.": "Interfejs może rozszerzać tylko klasę lub inny interfejs.",
        "Constraint of a type parameter cannot reference any type parameter from the same type parameter list.": "Ograniczenie parametru typu nie może przywoływać żadnego parametru typu z tej samej listy parametrów typu.",
        "Generic type '{0}' requires {1} type argument(s).": "Typ ogólny „{0}” wymaga następującej liczby argumentów typu: {1}.",
        "Type '{0}' is not generic.": "Typ „{0}” nie jest ogólny.",
        "Global type '{0}' must be a class or interface type.": "Typ globalny „{0}” musi być typem klasy lub interfejsu.",
        "Global type '{0}' must have {1} type parameter(s).": "Typ globalny „{0}” musi mieć następującą liczbę parametrów typu: {1}.",
        "Cannot find global type '{0}'.": "Nie można odnaleźć typu globalnego „{0}”.",
        "Named property '{0}' of types '{1}' and '{2}' are not identical.": "Nazwane właściwości „{0}” typów „{1}” i „{2}” nie są identyczne.",
        "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}'.": "Interfejs „{0}” nie może jednocześnie rozszerzać typów „{1}” i „{2}”.",
        "Excessive stack depth comparing types '{0}' and '{1}'.": "Nadmierna głębokość stosu podczas porównywania typów „{0}” i „{1}”.",
        "Type '{0}' is not assignable to type '{1}'.": "Nie można przypisać typu „{0}” do typu „{1}”.",
        "Property '{0}' is missing in type '{1}'.": "W typie „{0}” brakuje właściwości „{1}”.",
        "Property '{0}' is private in type '{1}' but not in type '{2}'.": "Właściwość „{0}” jest prywatna w typie „{1}”, ale nie w typie „{2}”.",
        "Types of property '{0}' are incompatible.": "Typy właściwości „{0}” są niezgodne.",
        "Property '{0}' is optional in type '{1}' but required in type '{2}'.": "Właściwość „{0}” jest opcjonalna w typie „{1}”, ale jest wymagana w typie „{2}”.",
        "Types of parameters '{0}' and '{1}' are incompatible.": "Typy parametrów „{0}” i „{1}” są niezgodne.",
        "Index signature is missing in type '{0}'.": "Brak sygnatury indeksu w typie „{0}”.",
        "Index signatures are incompatible.": "Sygnatury indeksów są niezgodne.",
        "'this' cannot be referenced in a module or namespace body.": "Nie można przywołać elementu „this” w treści modułu lub przestrzeni nazw.",
        "'this' cannot be referenced in current location.": "Nie można przywołać obiektu „this” w bieżącej lokalizacji.",
        "'this' cannot be referenced in constructor arguments.": "Nie można przywoływać obiektu „this” w argumentach konstruktora.",
        "'this' cannot be referenced in a static property initializer.": "Nie można przywołać elementu „this” w inicjatorze właściwości statycznej.",
        "'super' can only be referenced in a derived class.": "Element „super” może być przywoływany tylko w klasie pochodnej.",
        "'super' cannot be referenced in constructor arguments.": "Nie można przywoływać elementu „super” w argumentach konstruktora.",
        "Super calls are not permitted outside constructors or in nested functions inside constructors.": "Wywołania super są niedozwolone poza konstruktorami lub w zagnieżdżonych funkcjach wewnątrz konstruktorów.",
        "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.": "Dostęp do właściwości „super” jest dozwolony tylko w konstruktorze, funkcji członkowskiej lub metodzie dostępu elementu członkowskiego klasy pochodnej.",
        "Property '{0}' does not exist on type '{1}'.": "Właściwość „{0}” nie istnieje w typie „{1}”.",
        "Only public and protected methods of the base class are accessible via the 'super' keyword.": "Tylko publiczne i chronione metody klasy podstawowej są dostępne przy użyciu słowa kluczowego „super”.",
        "Property '{0}' is private and only accessible within class '{1}'.": "Właściwość „{0}” jest prywatna i dostępna tylko w klasie „{1}”.",
        "An index expression argument must be of type 'string', 'number', 'symbol, or 'any'.": "Argument wyrażenia indeksu musi być typu „string”, „number”, „symbol” lub „any”.",
        "Type '{0}' does not satisfy the constraint '{1}'.": "Typ „{0}” nie spełnia warunków ograniczenia „{1}”.",
        "Argument of type '{0}' is not assignable to parameter of type '{1}'.": "Nie można przypisać argumentu typu „{0}” do parametru typu „{1}”.",
        "Supplied parameters do not match any signature of call target.": "Podane parametry nie są zgodne z żadną sygnaturą celu wywołania.",
        "Untyped function calls may not accept type arguments.": "Wywołania funkcji bez typu nie mogą przyjmować argumentów typu.",
        "Value of type '{0}' is not callable. Did you mean to include 'new'?": "Nie można wywołać wartości typu „{0}”. Czy miał zostać użyty operator „new”?",
        "Cannot invoke an expression whose type lacks a call signature.": "Nie można wywołać wyrażenia, którego typ nie ma sygnatury wywołania.",
        "Only a void function can be called with the 'new' keyword.": "Tylko funkcja void może być wywoływana za pomocą słowa kluczowego „new”.",
        "Cannot use 'new' with an expression whose type lacks a call or construct signature.": "Nie można użyć elementu „new” z wyrażeniem, którego typ nie ma sygnatury wywołania lub konstrukcji.",
        "Neither type '{0}' nor type '{1}' is assignable to the other.": "Nie można przypisać typów „{0}” i „{1}” do siebie.",
        "Object literal may only specify known properties, and '{0}' does not exist in type '{1}'.": "Dla literału obiektu można określić tylko znane właściwości, a właściwość „{0}” nie istnieje w typie „{1}”.",
        "No best common type exists among return expressions.": "W zwracanych wyrażeniach nie ma najlepszego wspólnego typu.",
        "A function whose declared type is neither 'void' nor 'any' must return a value or consist of a single 'throw' statement.": "Funkcja z deklarowanym typem innym niż „void” lub „any” musi zwracać wartość lub zawierać jedną instrukcję „throw”.",
        "An arithmetic operand must be of type 'any', 'number' or an enum type.": "Arytmetyczny argument operacji musi być typu „any”, „number” lub typu wyliczeniowego.",
        "The operand of an increment or decrement operator must be a variable, property or indexer.": "Operand operatora inkrementacji lub dekrementacji musi być zmienną, właściwością lub indeksatorem.",
        "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.": "Lewa strona wyrażenia „instanceof” musi być typu „any”, typu obiektu lub parametrem typu.",
        "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.": "Prawa strona wyrażenia „instanceof” musi być typu „any” lub typu, który można przypisać do typu interfejsu „Function”.",
        "The left-hand side of an 'in' expression must be of type 'any', 'string', 'number', or 'symbol'.": "Lewa strona wyrażenia „in” musi być typu „any”, „string”, „number” lub „symbol”.",
        "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter": "Prawa strona wyrażenia „in” musi być typu „any”, typu obiektu lub parametrem typu",
        "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "Lewa strona operacji arytmetycznej musi być typu „any”, „number” lub typu wyliczeniowego.",
        "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "Prawa strona operacji arytmetycznej musi być typu „any”, „number” lub typu wyliczeniowego.",
        "Invalid left-hand side of assignment expression.": "Nieprawidłowa lewa strona wyrażenia przypisania.",
        "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": "Nie można zastosować operatora „{0}” do typów „{1}” i „{2}”.",
        "Type parameter name cannot be '{0}'": "Parametr typu nie może mieć nazwy „{0}”",
        "A parameter property is only allowed in a constructor implementation.": "Właściwość parametru jest dozwolona tylko w implementacji konstruktora.",
        "A rest parameter must be of an array type.": "Parametr rest musi być typu tablicowego.",
        "A parameter initializer is only allowed in a function or constructor implementation.": "Inicjator parametru jest dozwolony tylko w implementacji funkcji lub konstruktora.",
        "Parameter '{0}' cannot be referenced in its initializer.": "Parametr „{0}” nie może być przywoływany w swoim inicjatorze.",
        "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.": "Inicjator parametru „{0}” nie może przywoływać identyfikatora „{1}” zadeklarowanego po nim.",
        "Duplicate string index signature.": "Zduplikowana sygnatura indeksu ciągu.",
        "Duplicate number index signature.": "Zduplikowana sygnatura indeksu liczbowego.",
        "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.": "Wywołanie „super” musi być pierwszą instrukcją konstruktora, jeśli klasa zawiera zainicjowane właściwości lub ma właściwości parametrów.",
        "Constructors for derived classes must contain a 'super' call.": "Konstruktory klas pochodnych muszą zawierać wywołanie „super”.",
        "A 'get' accessor must return a value or consist of a single 'throw' statement.": "Metoda dostępu „get” musi zwracać wartość lub zawierać jedną instrukcję „throw”.",
        "Getter and setter accessors do not agree in visibility.": "Widoczności metod dostępu pobierającej i ustawiającej są niezgodne.",
        "'get' and 'set' accessor must have the same type.": "Metody dostępu „get” i „set” muszą być tego samego typu.",
        "A signature with an implementation cannot use a string literal type.": "Sygnatura z implementacją nie może używać typu literału ciągu.",
        "Specialized overload signature is not assignable to any non-specialized signature.": "Nie można przypisać specjalizowanej sygnatury przeciążenia do żadnej sygnatury niespecjalizowanej.",
        "Overload signatures must all be exported or not exported.": "Wszystkie sygnatury przeciążeń muszą być wyeksportowane lub żadna nie może być wyeksportowana.",
        "Overload signatures must all be ambient or non-ambient.": "Wszystkie sygnatury przeciążeń muszą być otaczającymi podpisami lub żadna nie może być otaczającą sygnaturą.",
        "Overload signatures must all be public, private or protected.": "Wszystkie sygnatury przeciążeń muszą być publiczne, prywatne lub chronione.",
        "Overload signatures must all be optional or required.": "Wszystkie sygnatury przeciążeń muszą być opcjonalne lub wymagane.",
        "Function overload must be static.": "Przeciążenie funkcji musi być statyczne.",
        "Function overload must not be static.": "Przeciążenie funkcji nie może być statyczne.",
        "Function implementation name must be '{0}'.": "Implementacja funkcji musi mieć nazwę „{0}”.",
        "Constructor implementation is missing.": "Brak implementacji konstruktora.",
        "Function implementation is missing or not immediately following the declaration.": "Brak implementacji funkcji lub nie występuje ona bezpośrednio po deklaracji.",
        "Multiple constructor implementations are not allowed.": "Konstruktor nie może mieć wielu implementacji.",
        "Duplicate function implementation.": "Zduplikowana implementacja funkcji.",
        "Overload signature is not compatible with function implementation.": "Sygnatura przeciążenia nie jest zgodna z implementacją funkcji.",
        "Individual declarations in merged declaration '{0}' must be all exported or all local.": "Wszystkie pojedyncze deklaracje w scalonej deklaracji „{0}” muszą być wyeksportowane lub lokalne.",
        "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.": "Zduplikowany identyfikator „arguments”. Kompilator używa ciągu „arguments” do zainicjowania parametrów rest.",
        "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.": "Zduplikowany identyfikator „_this”. Kompilator używa deklaracji zmiennej „_this” do przechwycenia odwołania do elementu „this”.",
        "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.": "Wynikiem rozpoznania wyrażenia jest deklaracja zmiennej „_this” używana przez kompilator do przechwycenia odwołania do elementu „this”.",
        "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.": "Zduplikowany identyfikator „_super”. Kompilator używa ciągu „_super” do przechwycenia odwołania do klasy podstawowej.",
        "Expression resolves to '_super' that compiler uses to capture base class reference.": "Wynikiem rozpoznania wyrażenia jest element „_super” używany przez kompilator do przechwycenia odwołania do klasy podstawowej.",
        "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.": "Kolejne deklaracje zmiennej muszą być tego samego typu. Zmienna „{0}” musi być typu „{1}”, ale w tym miejscu jest typu „{2}”.",
        "The left-hand side of a 'for...in' statement cannot use a type annotation.": "Lewa strona instrukcji „for...in” nie może używać adnotacji typu.",
        "The left-hand side of a 'for...in' statement must be of type 'string' or 'any'.": "Lewa strona instrukcji „for...in” musi być typu „string” lub „any”.",
        "Invalid left-hand side in 'for...in' statement.": "Nieprawidłowa lewa strona instrukcji „for...in”.",
        "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.": "Prawa strona instrukcji „for...in” musi być typu „any”, typu obiektu lub parametrem typu.",
        "Setters cannot return a value.": "Metody ustawiające nie mogą zwracać wartości.",
        "Return type of constructor signature must be assignable to the instance type of the class": "Musi istnieć możliwość przypisania zwracanego typu sygnatury konstruktora do typu wystąpienia klasy",
        "All symbols within a 'with' block will be resolved to 'any'.": "Wszystkie symbole w bloku „with” zostaną rozpoznane jako element „any”.",
        "Property '{0}' of type '{1}' is not assignable to string index type '{2}'.": "Nie można przypisać właściwości „{0}” typu „{1}” do typu indeksu ciągu „{2}”.",
        "Property '{0}' of type '{1}' is not assignable to numeric index type '{2}'.": "Nie można przypisać właściwości „{0}” typu „{1}” do typu indeksu numerycznego „{2}”.",
        "Numeric index type '{0}' is not assignable to string index type '{1}'.": "Nie można przypisać typu indeksu numerycznego „{0}” do typu indeksu ciągu „{1}”.",
        "Class name cannot be '{0}'": "Klasa nie może mieć nazwy „{0}”",
        "Class '{0}' incorrectly extends base class '{1}'.": "Klasa „{0}” niepoprawnie rozszerza klasę podstawową „{1}”.",
        "Class static side '{0}' incorrectly extends base class static side '{1}'.": "Strona statyczna klasy „{0}” niepoprawnie rozszerza stronę statyczną klasy podstawowej „{1}”.",
        "Type name '{0}' in extends clause does not reference constructor function for '{0}'.": "Nazwa typu „{0}” w klauzuli extends nie przywołuje funkcji konstruktora dla elementu „{0}”.",
        "Class '{0}' incorrectly implements interface '{1}'.": "Klasa „{0}” zawiera niepoprawną implementację interfejsu „{1}”.",
        "A class may only implement another class or interface.": "Klasa może zawierać tylko implementację innej klasy lub innego interfejsu.",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.": "Klasa „{0}” definiuje funkcję elementu członkowskiego wystąpienia „{1}”,ale rozszerzona klasa „{2}” definiuje ją jako metodę dostępu do elementu członkowskiego wystąpienia.",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.": "Klasa „{0}” definiuje funkcję elementu członkowskiego wystąpienia „{1}”, ale rozszerzona klasa „{2}” definiuje ją jako właściwość elementu członkowskiego wystąpienia.",
        "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.": "Klasa „{0}” definiuje właściwość elementu członkowskiego wystąpienia „{1}”, ale rozszerzona klasa „{2}” definiuje ją jako funkcję elementu członkowskiego wystąpienia.",
        "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.": "Klasa „{0}” definiuje metodę dostępu do elementu członkowskiego wystąpienia „{1}”, ale rozszerzona klasa „{2}” definiuje ją jako funkcję elementu członkowskiego wystąpienia.",
        "Interface name cannot be '{0}'": "Interfejs nie może mieć nazwy „{0}”",
        "All declarations of an interface must have identical type parameters.": "Wszystkie deklaracje interfejsu muszą mieć identyczne parametry typu.",
        "Interface '{0}' incorrectly extends interface '{1}'.": "Interfejs „{0}” niepoprawnie rozszerza interfejs „{1}”.",
        "Enum name cannot be '{0}'": "Wyliczenie nie może mieć nazwy „{0}”",
        "In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.": "W przypadku wyliczenia z wieloma deklaracjami tylko jedna deklaracja może pominąć inicjator dla pierwszego elementu wyliczenia.",
        "A namespace declaration cannot be in a different file from a class or function with which it is merged": "Deklaracja przestrzeni nazw nie może znajdować się w innym pliku niż klasa lub funkcja, z którą ją scalono",
        "A namespace declaration cannot be located prior to a class or function with which it is merged": "Deklaracja przestrzeni nazw nie może występować przed klasą lub funkcją, z którą ją scalono",
        "Ambient modules cannot be nested in other modules.": "Otaczające moduły nie mogą być zagnieżdżone w innych modułach.",
        "Ambient module declaration cannot specify relative module name.": "Deklaracja otaczającego modułu nie może określać względnej nazwy modułu.",
        "Module '{0}' is hidden by a local declaration with the same name": "Moduł „{0}” został ukryty przez deklarację lokalną o takiej samej nazwie",
        "Import name cannot be '{0}'": "Import nie może mieć nazwy „{0}”",
        "Import or export declaration in an ambient module declaration cannot reference module through relative module name.": "Deklaracja importu lub eksportu w deklaracji otaczającego modułu nie może przywoływać modułu za pomocą jego nazwy względnej.",
        "Import declaration conflicts with local declaration of '{0}'": "Deklaracja importu powoduje konflikt z deklaracją lokalną „{0}”",
        "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module.": "Zduplikowany identyfikator „{0}”. Kompilator rezerwuje nazwę „{1}” w zakresie najwyższego poziomu modułu.",
        "Types have separate declarations of a private property '{0}'.": "Typy mają osobne deklaracje właściwości prywatnej „{0}”.",
        "Property '{0}' is protected but type '{1}' is not a class derived from '{2}'.": "Właściwość „{0}” jest chroniona, ale typ „{1}” nie jest klasą pochodną elementu „{2}”.",
        "Property '{0}' is protected in type '{1}' but public in type '{2}'.": "Właściwość „{0}” jest chroniona w typie „{1}”, ale jest publiczna w typie „{2}”.",
        "Property '{0}' is protected and only accessible within class '{1}' and its subclasses.": "Właściwość „{0}” jest chroniona i dostępna tylko w klasie „{1}” oraz w jej podklasach.",
        "Property '{0}' is protected and only accessible through an instance of class '{1}'.": "Właściwość „{0}” jest chroniona i dostępna tylko za pośrednictwem wystąpienia klasy „{1}”.",
        "The '{0}' operator is not allowed for boolean types. Consider using '{1}' instead.": "Operator „{0}” nie jest dozwolony w przypadku typów logicznych. Zamiast tego rozważ użycie operatora „{1}”.",
        "Block-scoped variable '{0}' used before its declaration.": "Zmienna „{0}” należąca do zakresu bloku została użyta przed jej deklaracją.",
        "The operand of an increment or decrement operator cannot be a constant.": "Argument operacji operatora inkrementacji lub dekrementacji nie może być stałą.",
        "Left-hand side of assignment expression cannot be a constant.": "Lewa strona wyrażenia przypisania nie może być stałą.",
        "Cannot redeclare block-scoped variable '{0}'.": "Nie można ponownie zadeklarować zmiennej „{0}” należącej do zakresu bloku.",
        "An enum member cannot have a numeric name.": "Element członkowski wyliczenia nie może mieć nazwy liczbowej.",
        "The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.": "Nie można wywnioskować argumentu typu dla parametru typu „{0}” na podstawie użytkowania. Rozważ jawne określenie argumentów typu.",
        "Type argument candidate '{1}' is not a valid type argument because it is not a supertype of candidate '{0}'.": "Argument kandydujący „{1}” nie jest prawidłowym argumentem typu, ponieważ nie jest nadtypem kandydata „{0}”.",
        "Type alias '{0}' circularly references itself.": "Alias typu „{0}” cyklicznie przywołuje siebie.",
        "Type alias name cannot be '{0}'": "Alias typu nie może mieć nazwy „{0}”",
        "An AMD module cannot have multiple name assignments.": "Moduł AMD nie może mieć wielu przypisań nazw.",
        "Type '{0}' has no property '{1}' and no string index signature.": "Typ „{0}” nie ma właściwości „{1}” i sygnatury indeksu ciągu.",
        "Type '{0}' has no property '{1}'.": "Typ „{0}” nie ma właściwości „{1}”.",
        "Type '{0}' is not an array type.": "Typ „{0}” nie jest typem tablicowym.",
        "A rest element must be last in an array destructuring pattern": "Element rest musi występować na końcu wzorca usuwającego strukturę tablicy",
        "A binding pattern parameter cannot be optional in an implementation signature.": "Parametr wzorca powiązania nie może być opcjonalny w sygnaturze implementacji.",
        "A computed property name must be of type 'string', 'number', 'symbol', or 'any'.": "Obliczona nazwa właściwości musi być typu „string”, „number”, „symbol” lub „any”.",
        "'this' cannot be referenced in a computed property name.": "Nie można przywołać elementu „this” w obliczonej nazwie właściwości.",
        "'super' cannot be referenced in a computed property name.": "Nie można przywołać elementu „super” w obliczonej nazwie właściwości.",
        "A computed property name cannot reference a type parameter from its containing type.": "Obliczona nazwa właściwości nie może odwoływać się do parametru typu z zawierającego go typu.",
        "Cannot find global value '{0}'.": "Nie można odnaleźć wartości globalnej „{0}”.",
        "The '{0}' operator cannot be applied to type 'symbol'.": "Nie można zastosować operatora „{0}” do typu „symbol”.",
        "'Symbol' reference does not refer to the global Symbol constructor object.": "Odwołanie do elementu „Symbol” nie zawiera odwołania do globalnego obiektu konstruktora symboli.",
        "A computed property name of the form '{0}' must be of type 'symbol'.": "Obliczona nazwa właściwości w postaci „{0}” musi być typu „symbol”.",
        "Spread operator in 'new' expressions is only available when targeting ECMAScript 5 and higher.": "Operator rozpiętości w wyrażeniach „new” jest dostępny tylko wtedy, gdy jest używany język ECMAScript 5 lub nowszy.",
        "Enum declarations must all be const or non-const.": "Wszystkie deklaracje wyliczeń muszą być elementami const lub żadna nie może być elementem const.",
        "In 'const' enum declarations member initializer must be constant expression.": "W deklaracjach wyliczeń „const” inicjator elementu członkowskiego musi być wyrażeniem stałej.",
        "'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment.": "Wyliczenia „const” mogą być używane tylko w wyrażeniach dostępu do indeksu albo po prawej stronie deklaracji importu lub przypisania eksportu.",
        "A const enum member can only be accessed using a string literal.": "Dostęp do elementu członkowskiego wyliczenia const można uzyskać tylko za pomocą literału ciągu.",
        "'const' enum member initializer was evaluated to a non-finite value.": "Wynikiem obliczenia inicjatora elementu członkowskiego wyliczenia „const” jest wartość nieskończona.",
        "'const' enum member initializer was evaluated to disallowed value 'NaN'.": "Wynikiem obliczenia inicjatora elementu członkowskiego wyliczenia „const” jest niedozwolona wartość „NaN”.",
        "Property '{0}' does not exist on 'const' enum '{1}'.": "Właściwość „{0}” nie istnieje w wyliczeniu „const” „{1}”.",
        "'let' is not allowed to be used as a name in 'let' or 'const' declarations.": "Element „let” nie może być używany jako nazwa w deklaracjach „let” lub „const”.",
        "Cannot initialize outer scoped variable '{0}' in the same scope as block scoped declaration '{1}'.": "Nie można zainicjować zmiennej „{0}” z zakresu zewnętrznego w tym samym zakresie co deklaracja „{1}” należąca do zakresu bloku.",
        "The left-hand side of a 'for...of' statement cannot use a type annotation.": "Lewa strona instrukcji „for...of” nie może używać adnotacji typu.",
        "Export declaration conflicts with exported declaration of '{0}'": "Deklaracja eksportu powoduje konflikt z wyeksportowaną deklaracją „{0}”",
        "The left-hand side of a 'for...of' statement cannot be a previously defined constant.": "Lewa strona instrukcji „for...of” nie może być wcześniej zdefiniowaną stałą.",
        "The left-hand side of a 'for...in' statement cannot be a previously defined constant.": "Lewa strona instrukcji „for...in” nie może być wcześniej zdefiniowaną stałą.",
        "Invalid left-hand side in 'for...of' statement.": "Nieprawidłowa lewa strona instrukcji „for...of”.",
        "Type must have a '[Symbol.iterator]()' method that returns an iterator.": "Typ musi zawierać metodę „[Symbol.iterator]()” zwracającą iterator.",
        "An iterator must have a 'next()' method.": "Iterator musi zawierać metodę „next()”.",
        "The type returned by the 'next()' method of an iterator must have a 'value' property.": "Typ zwracany przez metodę „next()” iteratora musi mieć właściwość „value”.",
        "The left-hand side of a 'for...in' statement cannot be a destructuring pattern.": "Lewa strona instrukcji „for...in” nie może być wzorcem usuwającym strukturę.",
        "Cannot redeclare identifier '{0}' in catch clause": "Nie można ponownie zadeklarować identyfikatora „{0}” w klauzuli catch",
        "Tuple type '{0}' with length '{1}' cannot be assigned to tuple with length '{2}'.": "Nie można przypisać typu spójnej kolekcji „{0}” o długości „{1}” do spójnej kolekcji o długości „{2}”.",
        "Using a string in a 'for...of' statement is only supported in ECMAScript 5 and higher.": "Używanie ciągu w instrukcji „for...of” jest obsługiwane tylko w języku ECMAScript 5 lub nowszym.",
        "Type '{0}' is not an array type or a string type.": "Typ „{0}” nie jest typem tablicowym ani typem ciągu.",
        "The 'arguments' object cannot be referenced in an arrow function in ES3 and ES5. Consider using a standard function expression.": "Obiekt „arguments” nie może być przywoływany w funkcji strzałkowej w językach ES3 i ES5. Rozważ użycie standardowego wyrażenia funkcji.",
        "Module '{0}' resolves to a non-module entity and cannot be imported using this construct.": "Wynikiem rozpoznania modułu „{0}” jest jednostka niebędąca modułem i nie można zaimportować tego modułu przy użyciu tej konstrukcji.",
        "Module '{0}' uses 'export =' and cannot be used with 'export *'.": "Moduł „{0}” używa elementu „export =” i nie może być używany z elementem „export *”.",
        "An interface can only extend an identifier/qualified-name with optional type arguments.": "Interfejs może rozszerzać tylko identyfikator/nazwę kwalifikowaną z opcjonalnymi argumentami typów.",
        "A class can only implement an identifier/qualified-name with optional type arguments.": "Klasa może zawierać implementację tylko identyfikatora/nazwy kwalifikowanej z opcjonalnymi argumentami typów.",
        "A rest element cannot contain a binding pattern.": "Element rest nie może zawierać wzorca powiązania.",
        "'{0}' is referenced directly or indirectly in its own type annotation.": "Element „{0}” jest przywoływany bezpośrednio lub pośrednio w jego własnej adnotacji typu.",
        "Cannot find namespace '{0}'.": "Nie można odnaleźć przestrzeni nazw „{0}”.",
        "No best common type exists among yield expressions.": "W wyrażeniach yield nie ma najlepszego wspólnego typu.",
        "A generator cannot have a 'void' type annotation.": "Generator nie może mieć adnotacji typu „void”.",
        "'{0}' is referenced directly or indirectly in its own base expression.": "Element „{0}” jest przywoływany bezpośrednio lub pośrednio w jego własnym wyrażeniu podstawowym.",
        "Type '{0}' is not a constructor function type.": "Typ „{0}” nie jest typem funkcji konstruktora.",
        "No base constructor has the specified number of type arguments.": "Żaden z konstruktorów podstawowych nie ma określonej liczby argumentów typu.",
        "Base constructor return type '{0}' is not a class or interface type.": "Typ zwracany konstruktora podstawowego „{0}” nie jest typem klasy ani interfejsu.",
        "Base constructors must all have the same return type.": "Wszystkie konstruktory podstawowe muszą mieć ten sam typ zwracany.",
        "Cannot create an instance of the abstract class '{0}'.": "Nie można utworzyć wystąpienia klasy abstrakcyjnej „{0}”.",
        "Overload signatures must all be abstract or not abstract.": "Wszystkie sygnatury przeciążeń muszą być abstrakcyjne lub nieabstrakcyjne.",
        "Abstract method '{0}' in class '{1}' cannot be accessed via super expression.": "Nie można uzyskać dostępu do metody abstrakcyjnej „{0}” w klasie „{1}” za pośrednictwem wyrażenia super.",
        "Classes containing abstract methods must be marked abstract.": "Klasy zawierające metody abstrakcyjne muszą być oznaczone jako abstrakcyjne.",
        "Non-abstract class '{0}' does not implement inherited abstract member '{1}' from class '{2}'.": "Klasa nieabstrakcyjna„{0}” nie implementuje odziedziczonego abstrakcyjnego elementu członkowskiego „{1}” z klasy „{2}”.",
        "All declarations of an abstract method must be consecutive.": "Wszystkie deklaracje metody abstrakcyjnej muszą występować obok siebie.",
        "Cannot assign an abstract constructor type to a non-abstract constructor type.": "Nie można przypisać abstrakcyjnego typu konstruktora do nieabstrakcyjnego typu konstruktora.",
        "Only an ambient class can be merged with an interface.": "Z interfejsem można scalić tylko klasę otaczającą.",
        "Duplicate identifier '{0}'. Compiler uses declaration '{1}' to support async functions.": "Zduplikowany identyfikator „{0}”. Kompilator używa deklaracji „{1}” do obsługi funkcji asynchronicznych.",
        "Expression resolves to variable declaration '{0}' that compiler uses to support async functions.": "Wynikiem rozpoznania wyrażenia jest deklaracja zmiennej „{0}” używana przez kompilator do obsługi funkcji asynchronicznych.",
        "The 'arguments' object cannot be referenced in an async arrow function. Consider using a standard async function expression.": "Obiekt „arguments” nie może być przywoływany w asynchronicznej funkcji strzałkowej. Rozważ użycie standardowego wyrażenia funkcji asynchronicznej.",
        "'yield' expressions cannot be used in a parameter initializer.": "Wyrażeń „yield” nie można używać w inicjatorze parametru.",
        "'await' expressions cannot be used in a parameter initializer.": "Wyrażeń „await” nie można używać w inicjatorze parametru.",
        "JSX element attributes type '{0}' must be an object type.": "Atrybuty typu elementu JSX „{0}” muszą być typu obiektu.",
        "The return type of a JSX element constructor must return an object type.": "Typ zwracany konstruktora elementu JSX musi zwracać typ obiektu.",
        "JSX element implicitly has type 'any' because the global type 'JSX.Element' does not exist.": "Dla elementu JSX niejawnie określono typ „any”, ponieważ typ globalny „JSX.Element” nie istnieje.",
        "Property '{0}' in type '{1}' is not assignable to type '{2}'": "Właściwości „{0}” w typie „{1}” nie można przypisać do typu „{2}”.",
        "JSX element type '{0}' does not have any construct or call signatures.": "Typ elementu JSX „{0}” nie ma sygnatury konstruktora lub wywołania.",
        "JSX element type '{0}' is not a constructor function for JSX elements.": "Typ elementu JSX „{0}” nie jest funkcją konstruktora dla elementów JSX.",
        "Property '{0}' of JSX spread attribute is not assignable to target property.": "Właściwości „{0}” atrybutu rozkładu JSX nie można przypisać do właściwości docelowej.",
        "JSX element class does not support attributes because it does not have a '{0}' property": "Klasa elementów JSX nie obsługuje atrybutów, ponieważ nie ma właściwości „{0}”",
        "The global type 'JSX.{0}' may not have more than one property": "Dla typu globalnego „JSX.{0}” nie można określić więcej niż jednej właściwości.",
        "Cannot emit namespaced JSX elements in React": "Nie można wyemitować elementów JSX należących do przestrzeni nazw w bibliotece React.",
        "A member initializer in a 'const' enum declaration cannot reference members declared after it, including members defined in other 'const' enums.": "Inicjator elementu członkowskiego w deklaracji wyliczenia „const” nie może zawierać odwołań do elementów członkowskich zadeklarowanych po nim, w tym elementów członkowskich zdefiniowanych w innych wyliczeniach „const”.",
        "Merged declaration '{0}' cannot include a default export declaration. Consider adding a separate 'export default {0}' declaration instead.": "Scalona deklaracja „{0}” nie może zawierać domyślnej deklaracji eksportu. Rozważ dodanie oddzielnej deklaracji „export default {0}” zamiast niej.",
        "Import declaration '{0}' is using private name '{1}'.": "Deklaracja importu „{0}” używa nazwy prywatnej „{1}”.",
        "Type parameter '{0}' of exported class has or is using private name '{1}'.": "Parametr typu „{0}” wyeksportowanej klasy ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Type parameter '{0}' of exported interface has or is using private name '{1}'.": "Parametr typu „{0}” wyeksportowanego interfejsu ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.": "Parametr typu „{0}” sygnatury konstruktora z wyeksportowanego interfejsu ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'.": "Parametr typu „{0}” sygnatury wywołania z wyeksportowanego interfejsu ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Type parameter '{0}' of public static method from exported class has or is using private name '{1}'.": "Parametr typu „{0}” publicznej metody statycznej z wyeksportowanej klasy ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Type parameter '{0}' of public method from exported class has or is using private name '{1}'.": "Parametr typu „{0}” metody publicznej z wyeksportowanej klasy ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Type parameter '{0}' of method from exported interface has or is using private name '{1}'.": "Parametr typu „{0}” metody z wyeksportowanego interfejsu ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Type parameter '{0}' of exported function has or is using private name '{1}'.": "Parametr typu „{0}” wyeksportowanej funkcji ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Implements clause of exported class '{0}' has or is using private name '{1}'.": "Klauzula implements wyeksportowanej klasy „{0}” ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Extends clause of exported class '{0}' has or is using private name '{1}'.": "Klauzula extends wyeksportowanej klasy „{0}” ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Extends clause of exported interface '{0}' has or is using private name '{1}'.": "Klauzula extends wyeksportowanego interfejsu „{0}” ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named.": "Wyeksportowana zmienna „{0}” ma nazwę „{1}” z modułu zewnętrznego {2} lub używa tej nazwy, ale nie można jej nazwać.",
        "Exported variable '{0}' has or is using name '{1}' from private module '{2}'.": "Wyeksportowana zmienna „{0}” ma nazwę „{1}” z modułu prywatnego „{2}” lub używa tej nazwy.",
        "Exported variable '{0}' has or is using private name '{1}'.": "Wyeksportowana zmienna „{0}” ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.": "Publiczna właściwość statyczna „{0}” wyeksportowanej klasy ma nazwę „{1}” z modułu zewnętrznego {2} lub używa tej nazwy, ale nie można jej nazwać.",
        "Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'.": "Publiczna właściwość statyczna „{0}” wyeksportowanej klasy ma nazwę „{1}” z modułu prywatnego „{2}” lub używa tej nazwy.",
        "Public static property '{0}' of exported class has or is using private name '{1}'.": "Publiczna właściwość statyczna „{0}” wyeksportowanej klasy ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.": "Właściwość publiczna „{0}” wyeksportowanej klasy ma nazwę „{1}” z modułu zewnętrznego {2} lub używa tej nazwy, ale nie można jej nazwać.",
        "Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'.": "Właściwość publiczna „{0}” wyeksportowanej klasy ma nazwę „{1}” z modułu prywatnego „{2}” lub używa tej nazwy.",
        "Public property '{0}' of exported class has or is using private name '{1}'.": "Właściwość publiczna „{0}” wyeksportowanej klasy ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'.": "Właściwość „{0}” wyeksportowanego interfejsu ma nazwę „{1}” z modułu prywatnego „{2}” lub używa tej nazwy.",
        "Property '{0}' of exported interface has or is using private name '{1}'.": "Właściwość „{0}” wyeksportowanego interfejsu ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Parameter '{0}' of public static property setter from exported class has or is using name '{1}' from private module '{2}'.": "Parametr „{0}” metody ustawiającej publicznej właściwości statycznej z wyeksportowanej klasy ma nazwę ”{1}” z modułu prywatnego „{2}” lub używa tej nazwy.",
        "Parameter '{0}' of public static property setter from exported class has or is using private name '{1}'.": "Parametr „{0}” metody ustawiającej publicznej właściwości statycznej z wyeksportowanej klasy ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Parameter '{0}' of public property setter from exported class has or is using name '{1}' from private module '{2}'.": "Parametr „{0}” metody ustawiającej właściwości publicznej z wyeksportowanej klasy ma nazwę ”{1}” z modułu prywatnego „{2}” lub używa tej nazwy.",
        "Parameter '{0}' of public property setter from exported class has or is using private name '{1}'.": "Parametr „{0}” metody ustawiającej właściwości publicznej z wyeksportowanej klasy ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Return type of public static property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.": "Zwracany typ metody pobierającej publicznej właściwości statycznej z wyeksportowanej klasy ma nazwę „{0}” z modułu zewnętrznego {1} lub używa tej nazwy, ale nie można go nazwać.",
        "Return type of public static property getter from exported class has or is using name '{0}' from private module '{1}'.": "Zwracany typ metody pobierającej publicznej właściwości statycznej z wyeksportowanej klasy ma nazwę „{0}” z modułu prywatnego „{1}” lub używa tej nazwy.",
        "Return type of public static property getter from exported class has or is using private name '{0}'.": "Zwracany typ metody pobierającej publicznej właściwości statycznej z wyeksportowanej klasy ma nazwę prywatną „{0}” lub używa tej nazwy.",
        "Return type of public property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.": "Zwracany typ metody pobierającej publicznej właściwości z wyeksportowanej klasy ma nazwę „{0}” z modułu zewnętrznego {1} lub używa tej nazwy, ale nie można go nazwać.",
        "Return type of public property getter from exported class has or is using name '{0}' from private module '{1}'.": "Zwracany typ metody pobierającej właściwości publicznej z wyeksportowanej klasy ma nazwę „{0}” z modułu prywatnego „{1}” lub używa tej nazwy.",
        "Return type of public property getter from exported class has or is using private name '{0}'.": "Zwracany typ metody pobierającej właściwości publicznej z wyeksportowanej klasy ma nazwę prywatną „{0}” lub używa tej nazwy.",
        "Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'.": "Zwracany typ sygnatury konstruktora z wyeksportowanego interfejsu ma nazwę „{0}” z modułu prywatnego „{1}” lub używa tej nazwy.",
        "Return type of constructor signature from exported interface has or is using private name '{0}'.": "Zwracany typ sygnatury konstruktora z wyeksportowanego interfejsu ma nazwę prywatną „{0}” lub używa tej nazwy.",
        "Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'.": "Zwracany typ sygnatury wywołania z wyeksportowanego interfejsu ma nazwę „{0}” z modułu prywatnego „{1}” lub używa tej nazwy.",
        "Return type of call signature from exported interface has or is using private name '{0}'.": "Zwracany typ sygnatury wywołania z wyeksportowanego interfejsu ma nazwę prywatną „{0}” lub używa tej nazwy.",
        "Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'.": "Zwracany typ sygnatury indeksu z wyeksportowanego interfejsu ma nazwę „{0}” z modułu prywatnego „{1}” lub używa tej nazwy.",
        "Return type of index signature from exported interface has or is using private name '{0}'.": "Zwracany typ sygnatury indeksu z wyeksportowanego interfejsu ma nazwę prywatną „{0}” lub używa tej nazwy.",
        "Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named.": "Zwracany typ publicznej metody statycznej z wyeksportowanej klasy ma nazwę „{0}” z modułu zewnętrznego {1} lub używa tej nazwy, ale nie można go nazwać.",
        "Return type of public static method from exported class has or is using name '{0}' from private module '{1}'.": "Zwracany typ publicznej metody statycznej z wyeksportowanej klasy ma nazwę „{0}” z modułu prywatnego „{1}” lub używa tej nazwy.",
        "Return type of public static method from exported class has or is using private name '{0}'.": "Zwracany typ publicznej metody statycznej z wyeksportowanej klasy ma nazwę prywatną „{0}” lub używa tej nazwy.",
        "Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named.": "Zwracany typ metody publicznej z wyeksportowanej klasy ma nazwę „{0}” z modułu zewnętrznego {1} lub używa tej nazwy, ale nie można go nazwać.",
        "Return type of public method from exported class has or is using name '{0}' from private module '{1}'.": "Zwracany typ metody publicznej z wyeksportowanej klasy ma nazwę „{0}” z modułu prywatnego „{1}” lub używa tej nazwy.",
        "Return type of public method from exported class has or is using private name '{0}'.": "Zwracany typ metody publicznej z wyeksportowanej klasy ma nazwę prywatną „{0}” lub używa tej nazwy.",
        "Return type of method from exported interface has or is using name '{0}' from private module '{1}'.": "Zwracany typ metody z wyeksportowanego interfejsu ma nazwę „{0}” z modułu prywatnego „{1}” lub używa tej nazwy.",
        "Return type of method from exported interface has or is using private name '{0}'.": "Zwracany typ metody z wyeksportowanego interfejsu ma nazwę prywatną „{0}” lub używa tej nazwy.",
        "Return type of exported function has or is using name '{0}' from external module {1} but cannot be named.": "Zwracany typ wyeksportowanej funkcji ma nazwę „{0}” z modułu zewnętrznego {1} lub używa tej nazwy, ale nie można go nazwać.",
        "Return type of exported function has or is using name '{0}' from private module '{1}'.": "Zwracany typ wyeksportowanej funkcji ma nazwę „{0}” z modułu prywatnego „{1}” lub używa tej nazwy.",
        "Return type of exported function has or is using private name '{0}'.": "Zwracany typ wyeksportowanej funkcji ma nazwę prywatną „{0}” lub używa tej nazwy.",
        "Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named.": "Parametr „{0}” konstruktora z wyeksportowanej klasy ma nazwę „{1}” z modułu zewnętrznego {2} lub używa tej nazwy, ale nie można go nazwać.",
        "Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'.": "Parametr „{0}” konstruktora z wyeksportowanej klasy ma nazwę „{1}” z modułu prywatnego „{2}” lub używa tej nazwy.",
        "Parameter '{0}' of constructor from exported class has or is using private name '{1}'.": "Parametr „{0}” konstruktora z wyeksportowanej klasy ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'.": "Parametr „{0}” sygnatury konstruktora z wyeksportowanego interfejsu ma nazwę „{1}” z modułu prywatnego „{2}” lub używa tej nazwy.",
        "Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.": "Parametr „{0}” sygnatury konstruktora z wyeksportowanego interfejsu ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'.": "Parametr „{0}” sygnatury wywołania z wyeksportowanego interfejsu ma nazwę „{1}” z modułu prywatnego „{2}” lub używa tej nazwy.",
        "Parameter '{0}' of call signature from exported interface has or is using private name '{1}'.": "Parametr „{0}” sygnatury wywołania z wyeksportowanego interfejsu ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named.": "Parametr „{0}” publicznej metody statycznej z wyeksportowanej klasy ma nazwę „{1}” z modułu zewnętrznego {2} lub używa tej nazwy, ale nie można go nazwać.",
        "Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'.": "Parametr „{0}” publicznej metody statycznej z wyeksportowanej klasy ma nazwę „{1}” z modułu prywatnego „{2}” lub używa tej nazwy.",
        "Parameter '{0}' of public static method from exported class has or is using private name '{1}'.": "Parametr „{0}” publicznej metody statycznej z wyeksportowanej klasy ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named.": "Parametr „{0}” metody publicznej z wyeksportowanej klasy ma nazwę „{1}” z modułu zewnętrznego {2} lub używa tej nazwy, ale nie można go nazwać.",
        "Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'.": "Parametr „{0}” metody publicznej z wyeksportowanej klasy ma nazwę „{1}” z modułu prywatnego „{2}” lub używa tej nazwy.",
        "Parameter '{0}' of public method from exported class has or is using private name '{1}'.": "Parametr „{0}” metody publicznej z wyeksportowanej klasy ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'.": "Parametr „{0}” metody z wyeksportowanego interfejsu ma nazwę „{1}” z modułu prywatnego „{2}” lub używa tej nazwy.",
        "Parameter '{0}' of method from exported interface has or is using private name '{1}'.": "Parametr „{0}” metody z wyeksportowanego interfejsu ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named.": "Parametr „{0}” wyeksportowanej funkcji ma nazwę „{1}” z modułu zewnętrznego {2} lub używa tej nazwy, ale nie można go nazwać.",
        "Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'.": "Parametr „{0}” wyeksportowanej funkcji ma nazwę „{1}” z modułu prywatnego „{2}” lub używa tej nazwy.",
        "Parameter '{0}' of exported function has or is using private name '{1}'.": "Parametr „{0}” wyeksportowanej funkcji ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Exported type alias '{0}' has or is using private name '{1}'.": "Alias „{0}” wyeksportowanego typu ma nazwę prywatną „{1}” lub używa tej nazwy.",
        "Default export of the module has or is using private name '{0}'.": "Domyślny eksport modułu ma nazwę prywatną „{0}” lub używa tej nazwy.",
        "Loop contains block-scoped variable '{0}' referenced by a function in the loop. This is only supported in ECMAScript 6 or higher.": "Pętla zawiera zmienną „{0}” należącą do zakresu bloku, która jest przywoływana przez funkcję w pętli. Jest to obsługiwane tylko w języku ECMAScript 6 lub nowszym.",
        "The current host does not support the '{0}' option.": "Bieżący host nie obsługuje opcji „{0}”.",
        "Cannot find the common subdirectory path for the input files.": "Nie można odnaleźć wspólnej ścieżki podkatalogu dla plików wejściowych.",
        "Cannot read file '{0}': {1}": "Nie można odczytać pliku „{0}”: {1}",
        "Unsupported file encoding.": "Nieobsługiwane kodowanie pliku.",
        "Failed to parse file '{0}': {1}.": "Nie można przeanalizować pliku „{0}”: {1}.",
        "Unknown compiler option '{0}'.": "Nieznana opcja kompilatora „{0}”.",
        "Compiler option '{0}' requires a value of type {1}.": "Opcja kompilatora „{0}” wymaga wartości typu {1}.",
        "Could not write file '{0}': {1}": "Nie można zapisać pliku „{0}”: {1}",
        "Option 'mapRoot' cannot be specified without specifying 'sourceMap' option.": "Opcji „mapRoot” nie można określić bez opcji „sourceMap”.",
        "Option 'sourceRoot' cannot be specified without specifying 'sourceMap' option.": "Opcji „sourceRoot” nie można określić bez opcji „sourceMap”.",
        "Option 'noEmit' cannot be specified with option 'out' or 'outDir'.": "Nie można określić opcji „noEmit” z opcją „out” lub „outDir”.",
        "Option 'noEmit' cannot be specified with option 'declaration'.": "Nie można określić opcji „noEmit” z opcją „declaration”.",
        "Option 'project' cannot be mixed with source files on a command line.": "Nie można mieszać opcji „project” z plikami źródłowymi w wierszu polecenia.",
        "Option 'declaration' cannot be specified with option 'isolatedModules'.": "Nie można określić opcji „declaration” z opcją „isolatedModules”.",
        "Option 'noEmitOnError' cannot be specified with option 'isolatedModules'.": "Nie można określić opcji „noEmitOnError” z opcją „isolatedModules”.",
        "Option 'out' cannot be specified with option 'isolatedModules'.": "Nie można określić opcji „out” z opcją „isolatedModules”.",
        "Option 'isolatedModules' can only be used when either option'--module' is provided or option 'target' is 'ES6' or higher.": "Opcja „isolatedModules” może być używana tylko w przypadku podania opcji „--module” lub w sytuacji, gdy opcja „target” ma wartość „ES6” lub wyższą.",
        "Option 'sourceMap' cannot be specified with option 'inlineSourceMap'.": "Nie można określić opcji „sourceMap” z opcją „inlineSourceMap”.",
        "Option 'sourceRoot' cannot be specified with option 'inlineSourceMap'.": "Nie można określić opcji „sourceRoot” z opcją „inlineSourceMap”.",
        "Option 'mapRoot' cannot be specified with option 'inlineSourceMap'.": "Nie można określić opcji „mapRoot” z opcją „inlineSourceMap”.",
        "Option 'inlineSources' can only be used when either option '--inlineSourceMap' or option '--sourceMap' is provided.": "Opcja „inlineSources” może być używana tylko w przypadku podania opcji „--inlineSourceMap” lub „--sourceMap”.",
        "Concatenate and emit output to single file.": "Połącz i wyemituj dane wyjściowe do pojedynczego pliku.",
        "Generates corresponding '.d.ts' file.": "Generuje odpowiadający plik „d.ts”.",
        "Specifies the location where debugger should locate map files instead of generated locations.": "Określa lokalizację, w której debuger powinien szukać plików map zamiast szukania w wygenerowanych lokalizacjach.",
        "Specifies the location where debugger should locate TypeScript files instead of source locations.": "Określa lokalizację, w której debuger powinien szukać plików TypeScript zamiast szukania w lokalizacjach źródłowych.",
        "Watch input files.": "Obserwuj pliki wejściowe.",
        "Redirect output structure to the directory.": "Przekieruj strukturę wyjściową do katalogu.",
        "Do not erase const enum declarations in generated code.": "Nie wymazuj deklaracji wyliczeń const w wygenerowanym kodzie.",
        "Do not emit outputs if any errors were reported.": "Nie emituj danych wyjściowych w przypadku zgłoszenia błędów.",
        "Do not emit comments to output.": "Nie emituj komentarzy do danych wyjściowych.",
        "Do not emit outputs.": "Nie emituj danych wyjściowych.",
        "Specify ECMAScript target version: 'ES3' (default), 'ES5', or 'ES6' (experimental)": "Określ docelową wersję języka ECMAScript: „ES3” (domyślna), „ES5” lub „ES6” (eksperymentalna)",
        "Specify module code generation: 'commonjs', 'amd', 'system' or 'umd'": "Określ generowanie kodu modułu: „commonjs”, „amd”, „system” lub „umd”",
        "Print this message.": "Wypisz ten komunikat.",
        "Print the compiler's version.": "Wypisz wersję kompilatora.",
        "Compile the project in the given directory.": "Kompiluj projekt w podanym katalogu.",
        "Syntax: {0}": "Składnia: {0}",
        "options": "opcje",
        "file1": "plik",
        "Examples: {0}": "Przykłady: {0}",
        "Options:": "Opcje:",
        "Version {0}": "Wersja {0}",
        "Insert command line options and files from a file.": "Wstaw opcje wiersza polecenia i pliki z pliku.",
        "File change detected. Starting incremental compilation...": "Wykryto zmianę pliku. Trwa rozpoczynanie kompilacji przyrostowej...",
        "KIND": "RODZAJ",
        "file2": "PLIK",
        "VERSION": "WERSJA",
        "LOCATION": "LOKALIZACJA",
        "DIRECTORY": "KATALOG",
        "Compilation complete. Watching for file changes.": "Ukończono kompilację. Wyszukiwanie zmian plików.",
        "Generates corresponding '.map' file.": "Generuje odpowiadający plik „map”.",
        "Compiler option '{0}' expects an argument.": "Opcja kompilatora „{0}” oczekuje argumentu.",
        "Unterminated quoted string in response file '{0}'.": "Niezakończony ciąg ujęty w cudzysłów w pliku odpowiedzi „{0}”.",
        "Argument for '--module' option must be 'commonjs', 'amd', 'system' or 'umd'.": "Argument opcji „--module” musi mieć postać „commonjs”, „amd”, „system” lub „umd”.",
        "Argument for '--target' option must be 'ES3', 'ES5', or 'ES6'.": "Argument opcji „--target” musi mieć postać „ES3”, „ES5” lub „ES6”.",
        "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.": "Ustawienia regionalne muszą mieć postać <język> lub <język>-<terytorium>. Na przykład „{0}” lub „{1}”.",
        "Unsupported locale '{0}'.": "Nieobsługiwane ustawienia regionalne „{0}”.",
        "Unable to open file '{0}'.": "Nie można otworzyć pliku „{0}”.",
        "Corrupted locale file {0}.": "Uszkodzony plik ustawień regionalnych {0}.",
        "Raise error on expressions and declarations with an implied 'any' type.": "Zgłaszaj błąd w przypadku wyrażeń i deklaracji z domniemanym typem „any”.",
        "File '{0}' not found.": "Nie znaleziono pliku „{0}”.",
        "File '{0}' has unsupported extension. The only supported extensions are {1}.": "Plik „{0}” ma nieobsługiwane rozszerzenie. Obsługiwane są tylko rozszerzenia {1}.",
        "Suppress noImplicitAny errors for indexing objects lacking index signatures.": "Pomiń błędy noImplicitAny dotyczące obiektów indeksowania bez sygnatur indeksów.",
        "Do not emit declarations for code that has an '@internal' annotation.": "Nie emituj deklaracji dla kodu z adnotacją „@internal”.",
        "Specifies the root directory of input files. Use to control the output directory structure with --outDir.": "Określa katalog główny plików wejściowych. Umożliwia sterowanie strukturą katalogów przy użyciu opcji --outDir.",
        "File '{0}' is not under 'rootDir' '{1}'. 'rootDir' is expected to contain all source files.": "Plik „{0}” nie znajduje się w katalogu „rootDir” „{1}”. Katalog „rootDir” powinien zawierać wszystkie pliki źródłowe.",
        "Specifies the end of line sequence to be used when emitting files: 'CRLF' (dos) or 'LF' (unix).": "Określa koniec sekwencji wierszy do użycia podczas emitowania plików: „CRLF” (DOS) lub „LF” (Unix).",
        "NEWLINE": "NOWY WIERSZ",
        "Argument for '--newLine' option must be 'CRLF' or 'LF'.": "Argument opcji „--newLine” musi mieć postać „CRLF” lub „LF”.",
        "Specify JSX code generation: 'preserve' or 'react'": "Określ metodę generowania kodu JSX: „preserve” lub „react”",
        "Argument for '--jsx' must be 'preserve' or 'react'.": "Argument dla opcji „--jsx” musi mieć postać „preserve” lub „react”.",
        "Option 'experimentalDecorators' must also be specified when option 'emitDecoratorMetadata' is specified.": "W przypadku określenia opcji „emitDecoratorMetadata” należy też określić opcję „experimentalDecorators”.",
        "Enables experimental support for ES7 decorators.": "Umożliwia obsługę eksperymentalną elementów Decorator języka ES7.",
        "Enables experimental support for emitting type metadata for decorators.": "Umożliwia obsługę eksperymentalną emitowania metadanych typów elementów Decorator.",
        "Option 'experimentalAsyncFunctions' cannot be specified when targeting ES5 or lower.": "Opcji „experimentalAsyncFunctions” nie można określić, gdy używany jest język ES5 lub starszy.",
        "Enables experimental support for ES7 async functions.": "Umożliwia obsługę eksperymentalną funkcji asynchronicznych języka ES7.",
        "Variable '{0}' implicitly has an '{1}' type.": "Dla zmiennej „{0}” niejawnie określono typ „{1}”.",
        "Parameter '{0}' implicitly has an '{1}' type.": "Dla parametru „{0}” niejawnie określono typ „{1}”.",
        "Member '{0}' implicitly has an '{1}' type.": "Dla elementu członkowskiego „{0}” niejawnie określono typ „{1}”.",
        "'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.": "Wyrażenie „new”, którego element docelowy nie ma sygnatury konstrukcji, jest niejawnie typu „any”.",
        "'{0}', which lacks return-type annotation, implicitly has an '{1}' return type.": "Dla elementu „{0}” bez adnotacji zwracanego typu niejawnie określono zwracany typ „{1}”.",
        "Function expression, which lacks return-type annotation, implicitly has an '{0}' return type.": "Dla wyrażenia funkcji bez adnotacji zwracanego typu jest niejawnie określony zwracany typ „{0}”.",
        "Construct signature, which lacks return-type annotation, implicitly has an 'any' return type.": "Dla sygnatury konstrukcji bez adnotacji zwracanego typu niejawnie określono zwracany typ „any”.",
        "Property '{0}' implicitly has type 'any', because its 'set' accessor lacks a type annotation.": "Dla właściwości „{0}” niejawnie określono typ „any”, ponieważ jego metoda dostępu „set” nie ma adnotacji typu.",
        "Index signature of object type implicitly has an 'any' type.": "Sygnatura indeksu typu obiektu niejawnie jest typu „any”.",
        "Object literal's property '{0}' implicitly has an '{1}' type.": "Dla właściwości „{0}” literału obiektu niejawnie określono typ „{1}”.",
        "Rest parameter '{0}' implicitly has an 'any[]' type.": "Dla parametru rest „{0}” niejawnie określono typ „any[]”.",
        "Call signature, which lacks return-type annotation, implicitly has an 'any' return type.": "Dla sygnatury wywołania bez adnotacji zwracanego typu niejawnie określono zwracany typ „any”.",
        "'{0}' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.": "Dla elementu „{0}” niejawnie określono typ „any”, ponieważ nie zawiera on adnotacji typu i jest przywoływany bezpośrednio lub pośrednio w jego własnym inicjatorze.",
        "'{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.": "Dla elementu „{0}” niejawnie określono zwracany typ „any”, ponieważ nie zawiera on adnotacji zwracanego typu i jest przywoływany bezpośrednio lub pośrednio w jednym z jego zwracanych wyrażeń.",
        "Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.": "Dla funkcji niejawnie określono zwracany typ „any”, ponieważ nie zawiera ona adnotacji zwracanego typu i jest przywoływana bezpośrednio lub pośrednio w jednym z jej zwracanych wyrażeń.",
        "Generator implicitly has type '{0}' because it does not yield any values. Consider supplying a return type.": "Dla generatora niejawnie określono typ „{0}”, ponieważ nie przekazuje on żadnych wartości yield. Rozważ podanie typu zwracanego.",
        "JSX element implicitly has type 'any' because no interface 'JSX.{0}' exists": "Dla elementu JSX niejawnie określono typ „any”, ponieważ interfejs „JSX.{0}” nie istnieje.",
        "You cannot rename this element.": "Nie można zmienić nazwy tego elementu.",
        "You cannot rename elements that are defined in the standard TypeScript library.": "Nie można zmienić nazw elementów zdefiniowanych w standardowej bibliotece TypeScript.",
        "'import ... =' can only be used in a .ts file.": "Ciągu „export ... =” można użyć tylko w pliku ts.",
        "'export=' can only be used in a .ts file.": "Ciągu „export=” można użyć tylko w pliku ts.",
        "'type parameter declarations' can only be used in a .ts file.": "Deklaracji parametrów typów można używać tylko w pliku ts.",
        "'implements clauses' can only be used in a .ts file.": "Klauzul implements można używać tylko w pliku ts.",
        "'interface declarations' can only be used in a .ts file.": "Deklaracji interfejsów można używać tylko w pliku ts.",
        "'module declarations' can only be used in a .ts file.": "Deklaracji modułów można używać tylko w pliku ts.",
        "'type aliases' can only be used in a .ts file.": "Aliasów typów można używać tylko w pliku ts.",
        "'{0}' can only be used in a .ts file.": "Elementu „{0}” można użyć tylko w pliku ts.",
        "'types' can only be used in a .ts file.": "Typów można używać tylko w pliku ts.",
        "'type arguments' can only be used in a .ts file.": "Argumentów typów można używać tylko w pliku ts.",
        "'parameter modifiers' can only be used in a .ts file.": "Modyfikatorów parametrów można używać tylko w pliku ts.",
        "'property declarations' can only be used in a .ts file.": "Deklaracji właściwości można używać tylko w pliku ts.",
        "'enum declarations' can only be used in a .ts file.": "Deklaracji wyliczeń można używać tylko w pliku ts.",
        "'type assertion expressions' can only be used in a .ts file.": "Wyrażeń asercji typów można używać tylko w pliku ts.",
        "'decorators' can only be used in a .ts file.": "Elementów „decorator” można używać tylko w pliku ts.",
        "Only identifiers/qualified-names with optional type arguments are currently supported in a class 'extends' clauses.": "Klauzule „extends” klasy obsługują obecnie tylko identyfikatory/nazwy kwalifikowane z opcjonalnymi argumentami typów.",
        "'class' expressions are not currently supported.": "Wyrażenia „class” nie są obecnie obsługiwane.",
        "JSX attributes must only be assigned a non-empty 'expression'.": "Atrybuty JSX muszą mieć przypisane wyrażenie, które nie jest puste.",
        "JSX elements cannot have multiple attributes with the same name.": "Elementy JSX nie mogą mieć wielu atrybutów o tej samej nazwie.",
        "Expected corresponding JSX closing tag for '{0}'.": "Oczekiwano odpowiadającego tagu zamykającego kodu JSX dla elementu „{0}”.",
        "JSX attribute expected.": "Oczekiwano atrybutu JSX.",
        "Cannot use JSX unless the '--jsx' flag is provided.": "Nie można użyć kodu JSX, jeśli nie podano flagi „--jsx”.",
        "A constructor cannot contain a 'super' call when its class extends 'null'": "Konstruktor nie może zawierać wywołania „super”, gdy jego rozszerzenie klasy ma wartość „null”."
}