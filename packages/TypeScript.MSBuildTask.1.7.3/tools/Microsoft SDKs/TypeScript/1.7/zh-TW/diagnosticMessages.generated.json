{
        "Unterminated string literal.": "未結束的字串常值。",
        "Identifier expected.": "應有識別項。",
        "'{0}' expected.": "應為 '{0}'。",
        "A file cannot have a reference to itself.": "檔案不得參考自己。",
        "Trailing comma not allowed.": "尾端不得為逗號。",
        "'*/' expected.": "應為 '*/'。",
        "Unexpected token.": "未預期的語彙基元。",
        "A rest parameter must be last in a parameter list.": "剩餘參數必須是參數清單中的最後一個參數。",
        "Parameter cannot have question mark and initializer.": "參數不得有問號及初始設定式。",
        "A required parameter cannot follow an optional parameter.": "必要參數不得接在選擇性參數之後。",
        "An index signature cannot have a rest parameter.": "索引簽章不得有剩餘參數。",
        "An index signature parameter cannot have an accessibility modifier.": "索引簽章參數不得有存取範圍修飾詞。",
        "An index signature parameter cannot have a question mark.": "索引簽章參數不得有問號。",
        "An index signature parameter cannot have an initializer.": "索引簽章參數不得有初始設定式。",
        "An index signature must have a type annotation.": "索引簽章必須有類型註釋。",
        "An index signature parameter must have a type annotation.": "索引簽章參數必須有類型註釋。",
        "An index signature parameter type must be 'string' or 'number'.": "索引簽章參數類型必須為 'string' 或 'number'。",
        "Accessibility modifier already seen.": "已有存取範圍修飾詞。",
        "'{0}' modifier must precede '{1}' modifier.": "'{0}' 修飾詞必須在 '{1}' 修飾詞之前。",
        "'{0}' modifier already seen.": "已有 '{0}' 修飾詞。",
        "'{0}' modifier cannot appear on a class element.": "類別項目不能有 '{0}' 修飾詞。",
        "'super' must be followed by an argument list or member access.": "'super' 之後必須接引數清單或成員存取。",
        "Only ambient modules can use quoted names.": "只有環境模組可以使用括以引號的名稱。",
        "Statements are not allowed in ambient contexts.": "環境內容中不得有陳述式。",
        "A 'declare' modifier cannot be used in an already ambient context.": "不得在現有環境內容中使用 'declare' 修飾詞。",
        "Initializers are not allowed in ambient contexts.": "環境內容中不得有初始設定式。",
        "'{0}' modifier cannot be used in an ambient context.": "無法在環境內容中使用 '{0}' 修飾詞。",
        "'{0}' modifier cannot be used with a class declaration.": "'{0}' 修飾詞無法與類別宣告並用。",
        "'{0}' modifier cannot be used here.": "無法在此處使用 '{0}' 修飾詞。",
        "'{0}' modifier cannot appear on a data property.": "'{0}' 修飾詞不得出現在資料屬性上。",
        "'{0}' modifier cannot appear on a module element.": "模組元素不得有 '{0}' 修飾詞。",
        "A '{0}' modifier cannot be used with an interface declaration.": "'{0}' 修飾詞無法與介面宣告並用。",
        "A 'declare' modifier is required for a top level declaration in a .d.ts file.": ".d.ts 檔案中的最上層宣告需要 'declare' 修飾詞。",
        "A rest parameter cannot be optional.": "剩餘參數不得為選擇性參數。",
        "A rest parameter cannot have an initializer.": "剩餘參數不得有初始設定式。",
        "A 'set' accessor must have exactly one parameter.": "'set' 存取子只可有一個參數。",
        "A 'set' accessor cannot have an optional parameter.": "'set' 存取子不得有選擇性參數。",
        "A 'set' accessor parameter cannot have an initializer.": "'set' 存取子參數不得有初始設定式。",
        "A 'set' accessor cannot have rest parameter.": "'set' 存取子不得有剩餘參數。",
        "A 'get' accessor cannot have parameters.": "'get' 存取子不得有參數。",
        "Type '{0}' is not a valid async function return type.": "類型 '{0}' 不是有效的非同步函式傳回類型。",
        "Accessors are only available when targeting ECMAScript 5 and higher.": "僅當目標為 ECMAScript 5 或更高版本時，才可使用存取子。",
        "An async function or method must have a valid awaitable return type.": "非同步函式或方法必須包含有效可等候的傳回類型。",
        "Operand for 'await' does not have a valid callable 'then' member.": "'await' 的運算元沒有有效可呼叫的 'then' 成員。",
        "Return expression in async function does not have a valid callable 'then' member.": "非同步函式中的 Return 運算式沒有有效可呼叫的 'then' 成員。",
        "Expression body for async arrow function does not have a valid callable 'then' member.": "非同步箭號函式的運算式主體沒有有效可呼叫的 'then' 成員。",
        "Enum member must have initializer.": "列舉成員必須有初始設定式。",
        "{0} is referenced directly or indirectly in the fulfillment callback of its own 'then' method.": "{0} 在其本身 'then' 方法的完成回撥中直接或間接受到參考。",
        "An export assignment cannot be used in a namespace.": "命名空間中不可使用匯出指派。",
        "Ambient enum elements can only have integer literal initializers.": "環境列舉元素只可有整數常值初始設定式。",
        "Unexpected token. A constructor, method, accessor, or property was expected.": "未預期的語彙基元。應有建構函式、方法、存取子或屬性。",
        "A '{0}' modifier cannot be used with an import declaration.": "'{0}' 修飾詞無法與匯入宣告並用。",
        "Invalid 'reference' directive syntax.": "無效的 'reference' 指示詞語法。",
        "Octal literals are not available when targeting ECMAScript 5 and higher.": "當目標為 ECMAScript 5 或更高版本時，無法使用八進位常值。",
        "An accessor cannot be declared in an ambient context.": "不得在環境內容中宣告存取子",
        "'{0}' modifier cannot appear on a constructor declaration.": "建構函式宣告不得有 '{0}' 修飾詞。",
        "'{0}' modifier cannot appear on a parameter.": "參數不得有 '{0}' 修飾詞。",
        "Only a single variable declaration is allowed in a 'for...in' statement.": "'for...in' 陳述式中只可使用單一變數宣告。",
        "Type parameters cannot appear on a constructor declaration.": "建構函式宣告不得有類型參數。",
        "Type annotation cannot appear on a constructor declaration.": "建構函式宣告不得有類型註釋。",
        "An accessor cannot have type parameters.": "存取子不得有類型參數。",
        "A 'set' accessor cannot have a return type annotation.": "'set' 存取子不得有傳回類型註釋。",
        "An index signature must have exactly one parameter.": "索引簽章只可有一個參數。",
        "'{0}' list cannot be empty.": "'{0}' 清單不得為空白。",
        "Type parameter list cannot be empty.": "類型參數清單不得為空白。",
        "Type argument list cannot be empty.": "類型引數清單不得為空白。",
        "Invalid use of '{0}' in strict mode.": "在 strict 模式中使用 '{0}' 無效。",
        "'with' statements are not allowed in strict mode.": "不得在 strict 模式中使用 'with' 陳述式。",
        "'delete' cannot be called on an identifier in strict mode.": "不得在 strict 模式中對識別項呼叫 'delete'。",
        "A 'continue' statement can only be used within an enclosing iteration statement.": "'continue' 陳述式只可在封入的反覆項目陳述式內使用。",
        "A 'break' statement can only be used within an enclosing iteration or switch statement.": "'break' 陳述式只可在封入的反覆項目或 switch 陳述式內使用。",
        "Jump target cannot cross function boundary.": "跳躍目標不得跨越函式界限。",
        "A 'return' statement can only be used within a function body.": "'return' 陳述式只可在函式主體內使用。",
        "Expression expected.": "應有運算式。",
        "Type expected.": "應有類型。",
        "A class member cannot be declared optional.": "不得將類別成員宣告為選用。",
        "A 'default' clause cannot appear more than once in a 'switch' statement.": "'default' 子句在 'switch' 陳述式中不得出現一次以上。",
        "Duplicate label '{0}'": "標籤 '{0}' 重複",
        "A 'continue' statement can only jump to a label of an enclosing iteration statement.": "'continue' 陳述式只可跳至封入之反覆項目陳述式的標籤。",
        "A 'break' statement can only jump to a label of an enclosing statement.": "'break' 陳述式只可跳至封入之陳述式的標籤。",
        "An object literal cannot have multiple properties with the same name in strict mode.": "在 strict 模式中，物件常值不得有多個同名的屬性。",
        "An object literal cannot have multiple get/set accessors with the same name.": "物件常值不得有多個同名的 get/set 存取子。",
        "An object literal cannot have property and accessor with the same name.": "物件常值不得有同名的屬性與存取子。",
        "An export assignment cannot have modifiers.": "匯出指派不得有修飾詞。",
        "Octal literals are not allowed in strict mode.": "strict 模式中不允許八進位常值。",
        "A tuple type element list cannot be empty.": "Tuple 類型元素清單不得為空白。",
        "Variable declaration list cannot be empty.": "變數宣告清單不得為空白。",
        "Digit expected.": "應有數字。",
        "Hexadecimal digit expected.": "應有十六進位數字。",
        "Unexpected end of text.": "未預期的文字結尾。",
        "Invalid character.": "無效的字元。",
        "Declaration or statement expected.": "應有宣告或陳述式。",
        "Statement expected.": "應有陳述式。",
        "'case' or 'default' expected.": "應有 'case' 或 'default'。",
        "Property or signature expected.": "應有屬性或簽章。",
        "Enum member expected.": "應有列舉成員。",
        "Variable declaration expected.": "應有變數宣告。",
        "Argument expression expected.": "應有引數運算式。",
        "Property assignment expected.": "應指派屬性。",
        "Expression or comma expected.": "應有運算式或逗號。",
        "Parameter declaration expected.": "應有參數宣告。",
        "Type parameter declaration expected.": "應有類型參數宣告。",
        "Type argument expected.": "應有類型引數。",
        "String literal expected.": "應有字串常值。",
        "Line break not permitted here.": "這裡不可使用分行符號。",
        "'{' or ';' expected.": "必須有 '{' 或 ';'。",
        "Modifiers not permitted on index signature members.": "索引簽章成員中不允許修飾詞。",
        "Declaration expected.": "應有宣告。",
        "Import declarations in a namespace cannot reference a module.": "命名空間中的匯入裝飾項目不可參考模組。",
        "Cannot compile modules unless the '--module' flag is provided.": "除非有提供 '--module' 旗標，否則無法編譯模組。",
        "File name '{0}' differs from already included file name '{1}' only in casing": "檔案名稱 '{0}' 與包含的檔案名稱 '{1}' 只差在大小寫",
        "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.": "new T[]' 不能用來建立陣列。請改用 'new Array<T>()'。",
        "'const' declarations must be initialized": "必須初始化 'const' 宣告",
        "'const' declarations can only be declared inside a block.": "只可在區塊內宣告 'const' 宣告。",
        "'let' declarations can only be declared inside a block.": "只能在區塊內宣告 'let' 宣告。",
        "Unterminated template literal.": "未結束的樣板常值。",
        "Unterminated regular expression literal.": "未結束的規則運算式常值。",
        "An object member cannot be declared optional.": "物件成員不可以是宣告的選擇項。",
        "A 'yield' expression is only allowed in a generator body.": "只有產生器主體才允許 'yield' 運算式。",
        "Computed property names are not allowed in enums.": "列舉中不能有計算的屬性名稱。",
        "A computed property name in an ambient context must directly refer to a built-in symbol.": "環境內容中之計算的屬性名稱必須直接參考內建符號。",
        "A computed property name in a class property declaration must directly refer to a built-in symbol.": "計算的屬性名稱在類型屬性宣告中之必須直接參考內建符號。",
        "A computed property name in a method overload must directly refer to a built-in symbol.": "計算的屬性名稱在方法多載中必須直接參考內建符號。",
        "A computed property name in an interface must directly refer to a built-in symbol.": "介面中之計算的屬性名稱必須直接參考內建符號。",
        "A computed property name in a type literal must directly refer to a built-in symbol.": "類型常值中之計算的屬性名稱必須直接參考內建符號。",
        "A comma expression is not allowed in a computed property name.": "已計算的屬性名稱中不能有逗號運算式。",
        "'extends' clause already seen.": "已經有 'extends' 子句。",
        "'extends' clause must precede 'implements' clause.": "'extends' 子句必須在 'implements' 子句之前。",
        "Classes can only extend a single class.": "類別只能擴充一個類別。",
        "'implements' clause already seen.": "已經看到 'implements' 子句。",
        "Interface declaration cannot have 'implements' clause.": "介面宣告不能有 'implements' 子句。",
        "Binary digit expected.": "必須是二進位數字。",
        "Octal digit expected.": "必須是八進位數字。",
        "Unexpected token. '{' expected.": "未預期的語彙基元。必須是 '{'。",
        "Property destructuring pattern expected.": "應為屬性解構模式。",
        "Array element destructuring pattern expected.": "應為陣列項目解構模式。",
        "A destructuring declaration must have an initializer.": "解構宣告中必須包含初始設定式。",
        "An implementation cannot be declared in ambient contexts.": "不得在環境內容中宣告實作。",
        "Modifiers cannot appear here.": "此處不得出現修飾詞。",
        "Merge conflict marker encountered.": "偵測到合併衝突標記。",
        "A rest element cannot have an initializer.": "剩餘項目不得包含初始設定式。",
        "A parameter property may not be a binding pattern.": "參數屬性不得為繫結模式。",
        "Only a single variable declaration is allowed in a 'for...of' statement.": "'for...of' 陳述式只能包含一個變數宣告。",
        "The variable declaration of a 'for...in' statement cannot have an initializer.": "'for...in' 陳述式的變數宣告不得包含初始設定式。",
        "The variable declaration of a 'for...of' statement cannot have an initializer.": "'for...of' 陳述式的變數宣告不得包含初始設定式。",
        "An import declaration cannot have modifiers.": "匯入宣告不得包含修飾詞。",
        "Module '{0}' has no default export.": "模組 '{0}' 沒有任何預設匯出。",
        "An export declaration cannot have modifiers.": "匯出宣告不得包含修飾詞。",
        "Export declarations are not permitted in a namespace.": "在命名空間中不可使用匯出裝飾項目。",
        "Catch clause variable name must be an identifier.": "Catch 子句變數名稱必須是識別項。",
        "Catch clause variable cannot have a type annotation.": "Catch 子句變數不得包含類型註釋。",
        "Catch clause variable cannot have an initializer.": "Catch 子句變數不得包含初始設定式。",
        "An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.": "擴充的 Unicode 逸出值必須介於 0x0 與 0x10FFFF (不含) 之間。",
        "Unterminated Unicode escape sequence.": "未結束的 Unicode 逸出序列。",
        "Line terminator not permitted before arrow.": "arrow 前不得有行結束字元。",
        "Import assignment cannot be used when targeting ECMAScript 6 or higher. Consider using 'import * as ns from \"mod\"', 'import {a} from \"mod\"' or 'import d from \"mod\"' instead.": "當目標為 ECMAScript 6 或更新版本時，無法使用匯入指派。請考慮改用 'import * as ns from \"mod\"'、'import {a} from \"mod\"' 或 'import d from \"mod\"'。",
        "Export assignment cannot be used when targeting ECMAScript 6 or higher. Consider using 'export default' instead.": "當目標為 ECMAScript 6 或更新版本時，無法使用匯出指派。請考慮改用 'export default'。",
        "Cannot compile modules into 'commonjs', 'amd', 'system' or 'umd' when targeting 'ES6' or higher.": "當目標為 'ES6' 或更高時，不可將模組編譯進 'commonjs'、'amd'、'system' 或 'umd'。",
        "Decorators are only available when targeting ECMAScript 5 and higher.": "僅當目標為 ECMAScript 5 及更新版本時，才可使用裝飾項目。",
        "Decorators are not valid here.": "裝飾項目在此處無效。",
        "Decorators cannot be applied to multiple get/set accessors of the same name.": "無法將裝飾項目套用到多個同名的 get/set 存取子。",
        "Cannot compile namespaces when the '--isolatedModules' flag is provided.": "提供 '--isolatedModules' 旗標時，不可編譯命名空間。",
        "Ambient const enums are not allowed when the '--isolatedModules' flag is provided.": "提供 '--isolatedModules' 旗標時，不可使用環境常數列舉。",
        "Invalid use of '{0}'. Class definitions are automatically in strict mode.": "不當使用 '{0}'。類別定義會自動採用 strict 模式。",
        "A class declaration without the 'default' modifier must have a name": "沒有 'default' 修飾詞的類別宣告必須要有名稱",
        "Identifier expected. '{0}' is a reserved word in strict mode": "必須是識別項。'{0}' 是 strict 模式中的保留字",
        "Identifier expected. '{0}' is a reserved word in strict mode. Class definitions are automatically in strict mode.": "必須是識別項。'{0}' 是 strict 模式中的保留字。類別定義會自動採用 strict 模式。",
        "Identifier expected. '{0}' is a reserved word in strict mode. Modules are automatically in strict mode.": "需要識別碼。'{0}' 是 strict 模式的保留字。模組會自動處於 strict 模式。",
        "Invalid use of '{0}'. Modules are automatically in strict mode.": "'{0}' 的用法無效。模組會自動處於 strict 模式。",
        "Export assignment is not supported when '--module' flag is 'system'.": "當 '--module' 旗標為 'system' 時，不支援匯出指派。",
        "Experimental support for decorators is a feature that is subject to change in a future release. Specify '--experimentalDecorators' to remove this warning.": "裝飾項目的實驗支援這項功能在未來的版本中有可能會變更。指定 '--experimentalDecorators' 可移除此警告。",
        "Generators are only available when targeting ECMAScript 6 or higher.": "當目標為 ECMAScript 6 或更高版本時，才可使用產生器。",
        "Generators are not allowed in an ambient context.": "環境內容中不允許產生器。",
        "An overload signature cannot be declared as a generator.": "不可將多載簽章宣告為產生器。",
        "'{0}' tag already specified.": "已指定 '{0}' 標記。",
        "Signature '{0}' must have a type predicate.": "簽章 '{0}' 必須包含類型述詞。",
        "Cannot find parameter '{0}'.": "找不到參數 '{0}'。",
        "Type predicate '{0}' is not assignable to '{1}'.": "無法將類型述詞 '{0}' 指派給 '{1}'。",
        "Parameter '{0}' is not in the same position as parameter '{1}'.": "參數 '{0}' 與參數 '{1}' 不在同一個位置。",
        "A type predicate is only allowed in return type position for functions and methods.": "只有函式及方法的傳回類型位置才允許類型述詞。",
        "A type predicate cannot reference a rest parameter.": "類型述詞不得參考 REST 參數。",
        "A type predicate cannot reference element '{0}' in a binding pattern.": "類型述詞不得參考繫結模式的項目 '{0}'。",
        "An export assignment can only be used in a module.": "只有在模組中才可使用匯出指派。",
        "An import declaration can only be used in a namespace or module.": "只有在命名空間或模組中才可使用匯入宣告。",
        "An export declaration can only be used in a module.": "只有在模組中才可使用匯出宣告。",
        "An ambient module declaration is only allowed at the top level in a file.": "環境模組宣告只可出現在檔案的最上層。",
        "A namespace declaration is only allowed in a namespace or module.": "只有命名空間或模組才允許命名空間宣告。",
        "Experimental support for async functions is a feature that is subject to change in a future release. Specify '--experimentalAsyncFunctions' to remove this warning.": "非同步函式的實驗支援這項功能在後續版本中可能會有所變更。指定 '--experimentalAsyncFunctions' 可移除此警告。",
        "'with' statements are not allowed in an async function block.": "非同步函式區塊中不允許 'with' 陳述式。",
        "'await' expression is only allowed within an async function.": "只有非同步函式才允許 'await' 運算式。",
        "Async functions are only available when targeting ECMAScript 6 and higher.": "當目標為 ECMAScript 6 或更高版本時，才可使用非同步函式。",
        "The return type of a property decorator function must be either 'void' or 'any'.": "屬性 decorator 函式的傳回類型必須是 'void' 或 'any'。",
        "The return type of a parameter decorator function must be either 'void' or 'any'.": "參數 decorator 函式的傳回類型必須是 'void' 或 'any'。",
        "Unable to resolve signature of class decorator when called as an expression.": "無法解析以運算式形式呼叫之類別裝飾項目的簽章。",
        "Unable to resolve signature of parameter decorator when called as an expression.": "無法解析以運算式形式呼叫之參數裝飾項目的簽章。",
        "Unable to resolve signature of property decorator when called as an expression.": "無法解析以運算式形式呼叫之屬性裝飾項目的簽章。",
        "Unable to resolve signature of method decorator when called as an expression.": "無法解析以運算式形式呼叫之方法裝飾項目的簽章。",
        "'abstract' modifier can only appear on a class or method declaration.": "'abstract' 修飾詞只可出現在類別或方法宣告上。",
        "'{0}' modifier cannot be used with '{1}' modifier.": "'{0}' 修飾詞無法與 '{1}' 修飾詞並用。",
        "Abstract methods can only appear within an abstract class.": "抽象方法只可出現在抽象類別中。",
        "Method '{0}' cannot have an implementation because it is marked abstract.": "因為方法 '{0}' 已標記為抽象，所以不可具有實作。",
        "Duplicate identifier '{0}'.": "識別項 '{0}' 重複。",
        "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.": "執行個體成員變數 '{0}' 的初始設定式不得參考建構函式中所宣告的識別項 '{1}'。",
        "Static members cannot reference class type parameters.": "靜態成員不得參考類別類型參數。",
        "Circular definition of import alias '{0}'.": "匯入別名 '{0}' 的循環定義。",
        "Cannot find name '{0}'.": "找不到名稱 '{0}'。",
        "Module '{0}' has no exported member '{1}'.": "模組 '{0}' 沒有匯出的成員 '{1}'。",
        "File '{0}' is not a module.": "檔案 '{0}' 不是模組。",
        "Cannot find module '{0}'.": "找不到模組 '{0}'。",
        "An export assignment cannot be used in a module with other exported elements.": "匯出指派不得在包含有其他匯出元素的模組中使用。",
        "Type '{0}' recursively references itself as a base type.": "類型 '{0}' 將自己當做基底類型遞迴參考。",
        "A class may only extend another class.": "每個類別只可擴充另一個類別。",
        "An interface may only extend a class or another interface.": "介面只可擴充類別或另一個介面。",
        "Constraint of a type parameter cannot reference any type parameter from the same type parameter list.": "類型參數的條件約束不得參考相同類型參數清單中的任何類型參數。",
        "Generic type '{0}' requires {1} type argument(s).": "泛型類型 '{0}' 需要 {1} 個類型引數。",
        "Type '{0}' is not generic.": "'{0}' 不是泛型類型。",
        "Global type '{0}' must be a class or interface type.": "全域類型 '{0}' 必須是類別或介面類型。",
        "Global type '{0}' must have {1} type parameter(s).": "全域類型 '{0}' 必須有 {1} 類型參數。",
        "Cannot find global type '{0}'.": "找不到全域類型 '{0}'。",
        "Named property '{0}' of types '{1}' and '{2}' are not identical.": "類型 '{1}' 及 '{2}' 的具名屬性 '{0}' 不一致。",
        "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}'.": "介面 '{0}' 不能同時擴充類型 '{1}' 和 '{2}'。",
        "Excessive stack depth comparing types '{0}' and '{1}'.": "比較類型 '{0}' 與 '{1}' 的堆疊深度過深。",
        "Type '{0}' is not assignable to type '{1}'.": "類型 '{0}' 不可指派給類型 '{1}'。",
        "Property '{0}' is missing in type '{1}'.": "類型 '{1}' 遺漏屬性 '{0}'。",
        "Property '{0}' is private in type '{1}' but not in type '{2}'.": "在類型 '{1}' 中，'{0}' 是私用屬性，但在類型 '{2}' 中不是。",
        "Types of property '{0}' are incompatible.": "屬性 '{0}' 的類型不相容。",
        "Property '{0}' is optional in type '{1}' but required in type '{2}'.": "在類型 '{1}' 中，'{0}' 是選用屬性，但在類型 '{2}' 中是必要屬性。",
        "Types of parameters '{0}' and '{1}' are incompatible.": "參數 '{0}' 和 '{1}' 的類型不相容。",
        "Index signature is missing in type '{0}'.": "類型 '{0}' 中遺漏索引簽章。",
        "Index signatures are incompatible.": "索引簽章不相容。",
        "'this' cannot be referenced in a module or namespace body.": "模組或命名空間主體中不可參考 'this'。",
        "'this' cannot be referenced in current location.": "目前的位置中不得參考 'this'。",
        "'this' cannot be referenced in constructor arguments.": "建構函式引數中不得參考 'this'。",
        "'this' cannot be referenced in a static property initializer.": "靜態屬性初始設定式中不得參考 'this'。",
        "'super' can only be referenced in a derived class.": "只有衍生類別中才可參考 'super'。",
        "'super' cannot be referenced in constructor arguments.": "建構函式引數中不得參考 'super'。",
        "Super calls are not permitted outside constructors or in nested functions inside constructors.": "建構函式外部或建構函式內的巢狀函式中不允許 super 呼叫。",
        "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.": "只有在建構函式、成員函式或衍生類別的成員存取子中，才能存取 'super' 屬性。",
        "Property '{0}' does not exist on type '{1}'.": "類型 '{1}' 沒有屬性 '{0}'。",
        "Only public and protected methods of the base class are accessible via the 'super' keyword.": "只有基底類別之公開且受保護的方法，才可透過 'super' 關鍵字存取。",
        "Property '{0}' is private and only accessible within class '{1}'.": "'{0}' 是私用屬性，只可從類別 '{1}' 中存取。",
        "An index expression argument must be of type 'string', 'number', 'symbol, or 'any'.": "索引運算式引數必須是 'string'、'number'、'symbol' 或 'any' 類型。",
        "Type '{0}' does not satisfy the constraint '{1}'.": "類型 '{0}' 不符合條件約束 '{1}'。",
        "Argument of type '{0}' is not assignable to parameter of type '{1}'.": "類型 '{0}' 的引數不可指派給類型 '{1}' 的參數。",
        "Supplied parameters do not match any signature of call target.": "提供的參數與任何呼叫目標簽章都不符。",
        "Untyped function calls may not accept type arguments.": "不具類型的函式呼叫無法接受類型引數。",
        "Value of type '{0}' is not callable. Did you mean to include 'new'?": "無法呼叫類型 '{0}' 的值。您要包含 'new' 嗎?",
        "Cannot invoke an expression whose type lacks a call signature.": "無法叫用類型缺少呼叫簽章的運算式。",
        "Only a void function can be called with the 'new' keyword.": "只有 void 函式可以使用 'new' 關鍵字進行呼叫。",
        "Cannot use 'new' with an expression whose type lacks a call or construct signature.": "類型缺少呼叫或建構函式簽章的運算式，不得與 'new' 一起使用。",
        "Neither type '{0}' nor type '{1}' is assignable to the other.": "類型 '{0}' 與類型 '{1}' 不得互相指派。",
        "Object literal may only specify known properties, and '{0}' does not exist in type '{1}'.": "物件常值只可指定已知的屬性，且類型 '{1}' 中沒有 '{0}'。",
        "No best common type exists among return expressions.": "傳回運算式之間沒有最佳的一般類型。",
        "A function whose declared type is neither 'void' nor 'any' must return a value or consist of a single 'throw' statement.": "宣告類型不是 'void' 或 'any' 的函式，必須傳回值或包含單一 'throw' 陳述式。",
        "An arithmetic operand must be of type 'any', 'number' or an enum type.": "算術運算元必須為 'any'、'number' 或列舉類型。",
        "The operand of an increment or decrement operator must be a variable, property or indexer.": "遞增或遞減運算子的運算元必須是變數、屬性或索引子。",
        "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.": "'instanceof' 運算式左側必須是類型 'any'、物件類型或類型參數。",
        "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.": "'instanceof' 運算式右側的類型必須是 'any' 類型，或是可指派給 'Function' 介面類型的類型。",
        "The left-hand side of an 'in' expression must be of type 'any', 'string', 'number', or 'symbol'.": "'in' 運算式的左側必須是 'any'、'string'、'number' 或 'symbol' 類型。",
        "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter": "'in' 運算式右側必須是類型 'any'、物件類型或類型參數",
        "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "算術運算左側必須是類型 'any'、'number' 或列舉類型。",
        "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "算術運算右側必須是類型 'any'、'number' 或列舉類型。",
        "Invalid left-hand side of assignment expression.": "指派運算式的左側無效。",
        "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": "運算子 '{0}' 無法套用至類型 '{1}' 及 '{2}'。",
        "Type parameter name cannot be '{0}'": "類型參數名稱不得為 '{0}'",
        "A parameter property is only allowed in a constructor implementation.": "建構函式實作中只可有一個參數屬性。",
        "A rest parameter must be of an array type.": "剩餘參數必須為陣列類型。",
        "A parameter initializer is only allowed in a function or constructor implementation.": "只有函式或建構函式實作才可使用參數初始設定式。",
        "Parameter '{0}' cannot be referenced in its initializer.": "無法在參數 '{0}' 的初始設定式中參考此參數。",
        "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.": "參數 '{0}' 的初始設定式不得參考在其之後宣告的識別項 '{1}'。",
        "Duplicate string index signature.": "字串索引簽章重複。",
        "Duplicate number index signature.": "數字索引簽章重複。",
        "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.": "當類別包含已初始化的屬性或參數屬性時，'super' 呼叫必須是建構函式中的第一個陳述式。",
        "Constructors for derived classes must contain a 'super' call.": "衍生類別的建構函式必須包含 'super' 呼叫。",
        "A 'get' accessor must return a value or consist of a single 'throw' statement.": "'get' 存取子必須傳回值或只包含單一 'throw' 陳述式。",
        "Getter and setter accessors do not agree in visibility.": "getter 和 setter 存取子的可視性不符。",
        "'get' and 'set' accessor must have the same type.": "get' 和 'set' 存取子的類型必須相同。",
        "A signature with an implementation cannot use a string literal type.": "包含實作的簽章不得使用字串常值類型。",
        "Specialized overload signature is not assignable to any non-specialized signature.": "特製化的多載簽章不可指派給任何非特製化的簽章。",
        "Overload signatures must all be exported or not exported.": "多載簽章必須全部匯出或全部不匯出。",
        "Overload signatures must all be ambient or non-ambient.": "多載簽章都必須是環境或非環境簽章。",
        "Overload signatures must all be public, private or protected.": "多載簽章必須是公用、私用或受保護。",
        "Overload signatures must all be optional or required.": "多載簽章都必須是選擇性或必要簽章。",
        "Function overload must be static.": "函式多載必須為靜態。",
        "Function overload must not be static.": "函式多載不可為靜態。",
        "Function implementation name must be '{0}'.": "函式實作名稱必須是 '{0}'。",
        "Constructor implementation is missing.": "缺少建構函式實作。",
        "Function implementation is missing or not immediately following the declaration.": "遺漏函式實作，或函式實作未緊接在宣告之後。",
        "Multiple constructor implementations are not allowed.": "不允許多個建構函式實作。",
        "Duplicate function implementation.": "函式實作重複。",
        "Overload signature is not compatible with function implementation.": "多載簽章與函式實作不相容。",
        "Individual declarations in merged declaration '{0}' must be all exported or all local.": "合併宣告 '{0}' 中的個別宣告必須全部匯出或全在本機上。",
        "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.": "識別項 'arguments'' 重複。編譯器會使用 'arguments' 來初始化剩餘參數。",
        "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.": "識別項 '_this' 重複。編譯器使用變數宣告 '_this' 來擷取 'this' 參考。",
        "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.": "運算式會解析成變數宣告 '_this'，而編譯器會使用此宣告擷取 'this' 參考 。",
        "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.": "識別項 '_super' 重複。編譯器會使用 '_super' 來擷取基底類別參考。",
        "Expression resolves to '_super' that compiler uses to capture base class reference.": "運算式會解析成 '_super'，而編譯器會使用其來擷取基底類別參考。",
        "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.": "後續的變數宣告必須具有相同的類型。變數 '{0}' 的類型必須是 '{1}' 但卻是 '{2}'。",
        "The left-hand side of a 'for...in' statement cannot use a type annotation.": "'for...in' 陳述式左側不得使用類型註釋。",
        "The left-hand side of a 'for...in' statement must be of type 'string' or 'any'.": "'for...in' 陳述式左側必須是類型 'string' 或 'any'。",
        "Invalid left-hand side in 'for...in' statement.": "'for...in' 陳述式的左側無效。",
        "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.": "'for...in' 陳述式右側必須是類型 'any'、物件類型或類型參數。",
        "Setters cannot return a value.": "setter 無法傳回值。",
        "Return type of constructor signature must be assignable to the instance type of the class": "建構函式簽章的傳回類型必須能夠指派給類別的執行個體類型",
        "All symbols within a 'with' block will be resolved to 'any'.": "'with' 區塊內的所有符號都會解析成 'any'。",
        "Property '{0}' of type '{1}' is not assignable to string index type '{2}'.": "類型 '{1}' 的屬性 '{0}' 不可指派給字串索引類型 '{2}'。",
        "Property '{0}' of type '{1}' is not assignable to numeric index type '{2}'.": "類型 '{1}' 的屬性 '{0}' 不可指派給數值索引類型 '{2}'。",
        "Numeric index type '{0}' is not assignable to string index type '{1}'.": "數值索引類型 '{0}' 不可指派給字串索引類型 '{1}'。",
        "Class name cannot be '{0}'": "類別名稱不得為 '{0}'",
        "Class '{0}' incorrectly extends base class '{1}'.": "類別 '{0}' 不正確地擴充基底類別 '{1}'。",
        "Class static side '{0}' incorrectly extends base class static side '{1}'.": "類別靜態端 '{0}' 不正確地擴充基底類別靜態端 '{1}'。",
        "Type name '{0}' in extends clause does not reference constructor function for '{0}'.": "Extends 子句中的類型名稱 '{0}' 未參考 '{0}' 的建構函式。",
        "Class '{0}' incorrectly implements interface '{1}'.": "類別 '{0}' 不正確地實作介面 '{1}'。",
        "A class may only implement another class or interface.": "每個類別只可實作另一個類別或介面。",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.": "類別 '{0}' 已定義執行個體成員函式 '{1}'，但是擴充類別 '{2}' 卻將其定義為執行個體成員存取子。",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.": "類別 '{0}' 已定義執行個體成員函式 '{1}'，但是擴充類別 '{2}' 卻將其定義為執行個體成員屬性。",
        "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.": "類別 '{0}' 已定義執行個體成員屬性 '{1}'，但是擴充類別 '{2}' 卻將其定義為執行個體成員函式。",
        "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.": "類別 '{0}' 已定義執行個體成員存取子 '{1}'，但是擴充類別 '{2}' 卻將其定義為執行個體成員函式。",
        "Interface name cannot be '{0}'": "介面名稱不得為 '{0}'",
        "All declarations of an interface must have identical type parameters.": "所有介面有宣告都必須使用相同的類型參數。",
        "Interface '{0}' incorrectly extends interface '{1}'.": "介面 '{0}' 不正確地擴充介面 '{1}'。",
        "Enum name cannot be '{0}'": "列舉名稱不得為 '{0}'",
        "In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.": "在具有多個宣告的列舉中，只有一個宣告可以在其第一個列舉元素中省略初始設定式。",
        "A namespace declaration cannot be in a different file from a class or function with which it is merged": "命名空間宣告不可位於和其所合併的類別或函式不同的檔案中。",
        "A namespace declaration cannot be located prior to a class or function with which it is merged": "命名空間宣告的位置不可早於其所合併的類別或函式。",
        "Ambient modules cannot be nested in other modules.": "環境模組不可位於其他模組的巢狀結構中。",
        "Ambient module declaration cannot specify relative module name.": "環境模組宣告不可指定相對模組名稱。",
        "Module '{0}' is hidden by a local declaration with the same name": "同名的區域宣告隱藏了模組 '{0}'",
        "Import name cannot be '{0}'": "匯入名稱不得為 '{0}'",
        "Import or export declaration in an ambient module declaration cannot reference module through relative module name.": "環境模組宣告中的匯入或匯出宣告，不可透過相對模組名稱參考模組。",
        "Import declaration conflicts with local declaration of '{0}'": "匯入宣告與 '{0}' 的區域宣告衝突",
        "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module.": "識別項 '{0}' 重複。編譯器會在模組的最上層範圍中保 '{1}'。",
        "Types have separate declarations of a private property '{0}'.": "類型具有私用屬性 '{0}' 的個別宣告。",
        "Property '{0}' is protected but type '{1}' is not a class derived from '{2}'.": "'{0}' 是受保護屬性，但類型 '{1}' 不是衍生自 '{2}' 的類別。",
        "Property '{0}' is protected in type '{1}' but public in type '{2}'.": "在類型 '{1}' 中，'{0}' 是受保護屬性，但在類型 '{2}' 中是公用屬性。",
        "Property '{0}' is protected and only accessible within class '{1}' and its subclasses.": "'{0}' 是受保護屬性，只可從類別 '{1}' 及其子類別中存取。",
        "Property '{0}' is protected and only accessible through an instance of class '{1}'.": "'{0}' 是受保護屬性，只能透過類別 '{1}' 的執行個體進行存取。",
        "The '{0}' operator is not allowed for boolean types. Consider using '{1}' instead.": "布林類型不允許有 '{0}' 運算子。請考慮改用 '{1}'。",
        "Block-scoped variable '{0}' used before its declaration.": "已在其宣告之前使用區塊範圍變數 '{0}'。",
        "The operand of an increment or decrement operator cannot be a constant.": "遞增或遞減運算子的運算元不可為常數。",
        "Left-hand side of assignment expression cannot be a constant.": "指派運算式的左側不可為常數。",
        "Cannot redeclare block-scoped variable '{0}'.": "無法重新宣告區塊範圍變數 '{0}'。",
        "An enum member cannot have a numeric name.": "列舉成員不可有數值名稱。",
        "The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.": "無法從使用方式推斷類型參數 '{0}' 的類型引數。請考慮明確地指定類型引數。",
        "Type argument candidate '{1}' is not a valid type argument because it is not a supertype of candidate '{0}'.": "因為類型引數候選項 '{1}' 不是候選項 '{0}' 的超級類型，所以不是有效的類型引數。",
        "Type alias '{0}' circularly references itself.": "類型別名 '{0}' 會循環參考自己。",
        "Type alias name cannot be '{0}'": "類型別名不可為 '{0}'",
        "An AMD module cannot have multiple name assignments.": "AMD 模組不能有多個名稱指派。",
        "Type '{0}' has no property '{1}' and no string index signature.": "類型 '{0}' 沒有屬性 '{1}'，也沒有字串索引簽章。",
        "Type '{0}' has no property '{1}'.": "類型 '{0}' 沒有屬性 '{1}'。",
        "Type '{0}' is not an array type.": "類型 '{0}' 不是陣列類型。",
        "A rest element must be last in an array destructuring pattern": "剩餘項目必須是陣列解構模式中的最後一項",
        "A binding pattern parameter cannot be optional in an implementation signature.": "實作簽章中不得省略繫結模式參數。",
        "A computed property name must be of type 'string', 'number', 'symbol', or 'any'.": "計算的屬性名稱必須是 'string'、'number'、'symbol' 或 'any' 類型。",
        "'this' cannot be referenced in a computed property name.": "計算的屬性名稱中不得參考 'this'。",
        "'super' cannot be referenced in a computed property name.": "計算的屬性名稱中不得參考 'super'。",
        "A computed property name cannot reference a type parameter from its containing type.": "計算的屬性名稱不得參考其包含類型中的類型參數。",
        "Cannot find global value '{0}'.": "找不到全域值 '{0}'。",
        "The '{0}' operator cannot be applied to type 'symbol'.": "不得對 'symbol' 類型套用 '{0}' 運算子。",
        "'Symbol' reference does not refer to the global Symbol constructor object.": "'Symbol' 參考不是參考全域 Symbol 建構函式物件。",
        "A computed property name of the form '{0}' must be of type 'symbol'.": "格式為 '{0}' 之計算的屬性名稱必須是 'symbol' 類型。",
        "Spread operator in 'new' expressions is only available when targeting ECMAScript 5 and higher.": "當目標為 ECMAScript 5 及更新版本時，才可在 'new' 運算式中展開運算子。",
        "Enum declarations must all be const or non-const.": "列舉宣告必須都是 const 或非 const。",
        "In 'const' enum declarations member initializer must be constant expression.": "在 'const' 列舉宣告中，成員初始設定式必須是常數運算式。",
        "'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment.": "只有屬性、索引存取運算式、匯入宣告或匯出指派的右側，可以使用 'const' 列舉。",
        "A const enum member can only be accessed using a string literal.": "若要存取常數列舉成員，必須透過字串常值。",
        "'const' enum member initializer was evaluated to a non-finite value.": "'const' 列舉成員初始設定式已評估為非有限值。",
        "'const' enum member initializer was evaluated to disallowed value 'NaN'.": "'const' 列舉成員初始設定式已評估為不允許的值 'NaN'。",
        "Property '{0}' does not exist on 'const' enum '{1}'.": "'const' 列舉 '{1}' 沒有屬性 '{0}'。",
        "'let' is not allowed to be used as a name in 'let' or 'const' declarations.": "'let' 或 'const' 宣告中不得使用 'let' 做為名稱。",
        "Cannot initialize outer scoped variable '{0}' in the same scope as block scoped declaration '{1}'.": "無法初始化區塊範圍宣告 '{1}' 之同一範圍中的外部範圍變數 '{0}'。",
        "The left-hand side of a 'for...of' statement cannot use a type annotation.": "'for...of' 陳述式的左側不得使用類型註解。",
        "Export declaration conflicts with exported declaration of '{0}'": "匯出宣告與匯出的 '{0}' 宣告相衝突",
        "The left-hand side of a 'for...of' statement cannot be a previously defined constant.": "'for...of' 陳述式的左側不得為先前定義的常數。",
        "The left-hand side of a 'for...in' statement cannot be a previously defined constant.": "'for...in' 陳述式的左側不得為先前定義的常數。",
        "Invalid left-hand side in 'for...of' statement.": "'for...of' 陳述式的左側無效。",
        "Type must have a '[Symbol.iterator]()' method that returns an iterator.": "類型必須有傳回迭代器的 '[Symbol.iterator]()' 方法。",
        "An iterator must have a 'next()' method.": "迭代器必須要有 'next()' 方法。",
        "The type returned by the 'next()' method of an iterator must have a 'value' property.": "迭代器之 'next()' 方法傳回的類型必須具有 'value' 屬性。",
        "The left-hand side of a 'for...in' statement cannot be a destructuring pattern.": "'for...in' 陳述式的左側不得為解構模式。",
        "Cannot redeclare identifier '{0}' in catch clause": "無法在 Catch 子句中重新宣告識別項 '{0}'",
        "Tuple type '{0}' with length '{1}' cannot be assigned to tuple with length '{2}'.": "無法將長度為 '{1}' 的 Tuple 類型 '{0}' 指派給長度為 '{2}' 的 Tuple。",
        "Using a string in a 'for...of' statement is only supported in ECMAScript 5 and higher.": "只有在 ECMAScript 5 及更新版本中，才可在 'for...of' 陳述式中使用字串。",
        "Type '{0}' is not an array type or a string type.": "類型 '{0}' 不是陣列類型或字串類型。",
        "The 'arguments' object cannot be referenced in an arrow function in ES3 and ES5. Consider using a standard function expression.": "無法在 ES3 和 ES5 的箭號函式中參考 'arguments' 物件。請考慮使用標準的函式運算式。",
        "Module '{0}' resolves to a non-module entity and cannot be imported using this construct.": "模組 '{0}' 會解析為非模組實體，且不可使用這個建構溝匯入。",
        "Module '{0}' uses 'export =' and cannot be used with 'export *'.": "模組 '{0}' 使用 'export ='，因而無法以 'export *' 的方式使用。",
        "An interface can only extend an identifier/qualified-name with optional type arguments.": "介面只能擴充具有選擇性類型引數的識別項/限定名稱。",
        "A class can only implement an identifier/qualified-name with optional type arguments.": "類別只能實作具有選擇性類型引數的識別項/限定名稱。",
        "A rest element cannot contain a binding pattern.": "Rest 項目不得包含繫結模式。",
        "'{0}' is referenced directly or indirectly in its own type annotation.": "'{0}' 在其本身的類型註釋中有直接或間接地參考到。",
        "Cannot find namespace '{0}'.": "找不到命名空間 '{0}'。",
        "No best common type exists among yield expressions.": "yield 運算式中沒有最佳的一般類型。",
        "A generator cannot have a 'void' type annotation.": "產生器不得有 'void' 類型註釋。",
        "'{0}' is referenced directly or indirectly in its own base expression.": "'{0}' 在其本身的基底運算式中直接或間接受到參考。",
        "Type '{0}' is not a constructor function type.": "類型 '{0}' 不是建構函式類型。",
        "No base constructor has the specified number of type arguments.": "沒有任何基底建構函式具有指定的類型引數數量。",
        "Base constructor return type '{0}' is not a class or interface type.": "基底建構函式傳回類型 '{0}' 不是類別或介面類型。",
        "Base constructors must all have the same return type.": "基底建構函式的傳回類型必須全部相同。",
        "Cannot create an instance of the abstract class '{0}'.": "無法建立抽象類別 '{0}' 的執行個體。",
        "Overload signatures must all be abstract or not abstract.": "多載簽章必須全為抽象或全為非抽象。",
        "Abstract method '{0}' in class '{1}' cannot be accessed via super expression.": "無法透過 super 運算式存取類別 '{1}' 中的抽象方法 '{0}'。",
        "Classes containing abstract methods must be marked abstract.": "包含抽象方法的類別必須標記為抽象。",
        "Non-abstract class '{0}' does not implement inherited abstract member '{1}' from class '{2}'.": "非抽象類別 '{0}' 未實作從類別 '{2}' 繼承而來的抽象成員 '{1}'。",
        "All declarations of an abstract method must be consecutive.": "抽象方法的所有宣告必須連續。",
        "Cannot assign an abstract constructor type to a non-abstract constructor type.": "無法將抽象建構函式類型指派給非抽象建構函式類型。",
        "Only an ambient class can be merged with an interface.": "只有環境類別才可與介面合併。",
        "Duplicate identifier '{0}'. Compiler uses declaration '{1}' to support async functions.": "重複的識別碼 '{0}'。編譯器會使用宣告 '{1}' 支援非同步函式。",
        "Expression resolves to variable declaration '{0}' that compiler uses to support async functions.": "運算式會解析為變數宣告 '{0}'，而編譯器會使用此宣告支援非同步函式。",
        "The 'arguments' object cannot be referenced in an async arrow function. Consider using a standard async function expression.": "在非同步箭號函式中無法參考 'arguments' 物件。請考慮使用標準非同步函式運算式。",
        "'yield' expressions cannot be used in a parameter initializer.": "'yield' 運算式不得用於參數初始設定式。",
        "'await' expressions cannot be used in a parameter initializer.": "'await' 運算式不得用於參數初始設定式。",
        "JSX element attributes type '{0}' must be an object type.": "JSX 項目屬性類型 '{0}' 必須為物件類型。",
        "The return type of a JSX element constructor must return an object type.": "JSX 項目建構函式的傳回類型必須傳回物件類型。",
        "JSX element implicitly has type 'any' because the global type 'JSX.Element' does not exist.": "因為全域類型 'JSX.Element' 不存在，所以 JSX 項目具有隱含類型 'any'。",
        "Property '{0}' in type '{1}' is not assignable to type '{2}'": "無法將類型 '{1}' 的屬性 '{0}' 指派給類型 '{2}'",
        "JSX element type '{0}' does not have any construct or call signatures.": "JSX 項目類型 '{0}' 沒有任何建構或呼叫簽章。",
        "JSX element type '{0}' is not a constructor function for JSX elements.": "JSX 項目類型 '{0}' 不是 JSX 項目的建構函式。",
        "Property '{0}' of JSX spread attribute is not assignable to target property.": "無法將 JSX 擴張屬性的屬性 '{0}' 指派給目標屬性。",
        "JSX element class does not support attributes because it does not have a '{0}' property": "因為 JSX 項目類別沒有 '{0}' 屬性 (property)，所以不支援屬性 (attribute)",
        "The global type 'JSX.{0}' may not have more than one property": "全域類型 'JSX.{0}' 的屬性不得超過一個",
        "Cannot emit namespaced JSX elements in React": "無法在 React 中發出已命名空間的 JSX 項目",
        "A member initializer in a 'const' enum declaration cannot reference members declared after it, including members defined in other 'const' enums.": "'const' 列舉宣告中的成員初始設定式無法參考其後所宣告的成員，包括在其他 'const' 列舉中所定義的成員。",
        "Merged declaration '{0}' cannot include a default export declaration. Consider adding a separate 'export default {0}' declaration instead.": "合併宣告 '{0}' 不得包含預設匯出宣告。請考慮改為加入獨立型 'export default {0}' 宣告。",
        "Import declaration '{0}' is using private name '{1}'.": "匯入宣告 '{0}' 使用私用名稱 '{1}'。",
        "Type parameter '{0}' of exported class has or is using private name '{1}'.": "匯出類別的類型參數 '{0}' 具有或使用私用名稱 '{1}'。",
        "Type parameter '{0}' of exported interface has or is using private name '{1}'.": "匯出介面的類型參數 '{0}' 具有或使用私用名稱 '{1}'。",
        "Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.": "匯出介面中建構函式簽章的類型參數 '{0}' 具有或使用私用名稱 '{1}'。",
        "Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'.": "匯出介面中呼叫簽章的類型參數 '{0}' 具有或使用私用名稱 '{1}'。",
        "Type parameter '{0}' of public static method from exported class has or is using private name '{1}'.": "匯出類別中公用靜態方法的類型參數 '{0}' 具有或使用私用名稱 '{1}'。",
        "Type parameter '{0}' of public method from exported class has or is using private name '{1}'.": "匯出類別中公用方法的類型參數 '{0}' 具有或使用私用名稱 '{1}'。",
        "Type parameter '{0}' of method from exported interface has or is using private name '{1}'.": "匯出介面中方法的類型參數 '{0}' 具有或使用私用名稱 '{1}'。",
        "Type parameter '{0}' of exported function has or is using private name '{1}'.": "匯出函式的類型參數 '{0}' 具有或使用私用名稱 '{1}'。",
        "Implements clause of exported class '{0}' has or is using private name '{1}'.": "匯出類別 '{0}' 的 Implements 子句具有或使用私用名稱 '{1}'。",
        "Extends clause of exported class '{0}' has or is using private name '{1}'.": "匯出類別 '{0}' 的 Extends 子句具有或使用私用名稱 '{1}'。",
        "Extends clause of exported interface '{0}' has or is using private name '{1}'.": "匯出介面 '{0}' 的 Extends 子句具有或使用私用名稱 '{1}'。",
        "Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named.": "匯出的變數 '{0}' 具有或使用外部模組 {2} 中的名稱 '{1}'，但無法命名。",
        "Exported variable '{0}' has or is using name '{1}' from private module '{2}'.": "匯出的變數 '{0}' 具有或使用私用模組 {2} 中的名稱 '{1}'。",
        "Exported variable '{0}' has or is using private name '{1}'.": "匯出的變數 '{0}' 具有或使用私用名稱 '{1}'。",
        "Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.": "匯出類別的公用靜態屬性 '{0}' 具有或使用外部模組 {2} 中的名稱 '{1}'，但無法命名。",
        "Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'.": "匯出類別的公用靜態屬性 '{0}' 具有或使用私用模組 '{2}' 中的名稱 '{1}'。",
        "Public static property '{0}' of exported class has or is using private name '{1}'.": "匯出類別的公用靜態屬性 '{0}' 具有或使用私用名稱 '{1}'。",
        "Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.": "匯出類別的公用屬性 '{0}' 具有或使用外部模組 {2} 中的名稱 '{1}'，但無法命名。",
        "Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'.": "匯出類別的公用屬性 '{0}' 具有或使用私用模組 '{2}' 中的名稱 '{1}'。",
        "Public property '{0}' of exported class has or is using private name '{1}'.": "匯出類別的公用屬性 '{0}' 具有或使用私用名稱 '{1}'。",
        "Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'.": "匯出介面的屬性 '{0}' 具有或使用私用模組 '{2}' 中的名稱 '{1}'。",
        "Property '{0}' of exported interface has or is using private name '{1}'.": "匯出介面的屬性 '{0}' 具有或使用私用名稱 '{1}'。",
        "Parameter '{0}' of public static property setter from exported class has or is using name '{1}' from private module '{2}'.": "匯出類別中靜態屬性 setter 的參數 '{0}' 具有或使用私用模組 '{2}' 中的名稱 '{1}'。",
        "Parameter '{0}' of public static property setter from exported class has or is using private name '{1}'.": "匯出類別中公用靜態屬性 setter 的參數 '{0}' 具有或使用私用名稱 '{1}'。",
        "Parameter '{0}' of public property setter from exported class has or is using name '{1}' from private module '{2}'.": "匯出類別中公用屬性 setter 的參數 '{0}' 具有或使用私用模組 '{2}' 中的名稱 '{1}'。",
        "Parameter '{0}' of public property setter from exported class has or is using private name '{1}'.": "匯出類別中公用屬性 setter 的參數 '{0}' 具有或使用私用名稱 '{1}'。",
        "Return type of public static property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.": "匯出類別中公用靜態屬性 getter 的傳回類型具有或使用外部模組 {1} 中的名稱 '{0}'，但無法命名。",
        "Return type of public static property getter from exported class has or is using name '{0}' from private module '{1}'.": "匯出類別中公用靜態屬性 getter 的傳回類型具有或使用私用模組 '{1}' 中的名稱 '{0}'。",
        "Return type of public static property getter from exported class has or is using private name '{0}'.": "匯出類別中公用靜態屬性 getter 的傳回類型具有或使用私用名稱 '{0}'。",
        "Return type of public property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.": "匯出類別中公用屬性 getter 的傳回類型具有或使用外部模組 {1} 中的名稱 '{0}'，但無法命名。",
        "Return type of public property getter from exported class has or is using name '{0}' from private module '{1}'.": "匯出類別中公用屬性 getter 的傳回類型具有或使用私用模組 '{1}' 中的名稱 '{0}'。",
        "Return type of public property getter from exported class has or is using private name '{0}'.": "匯出類別中公用屬性 getter 的傳回類型具有或使用私用名稱 '{0}'。",
        "Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'.": "匯出介面中建構函式簽章的傳回類型具有或使用私用模組 '{1}' 中的名稱 '{0}'。",
        "Return type of constructor signature from exported interface has or is using private name '{0}'.": "匯出介面中建構函式簽章的傳回類型具有或使用私用名稱 '{0}'。",
        "Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'.": "匯出介面中呼叫簽章的傳回類型具有或使用私用模組 '{1}' 中的名稱 '{0}'。",
        "Return type of call signature from exported interface has or is using private name '{0}'.": "匯出介面中呼叫簽章的傳回類型具有或使用私用名稱 '{0}'。",
        "Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'.": "匯出介面中索引簽章的傳回類型具有或使用私用模組 '{1}' 中的名稱 '{0}'。",
        "Return type of index signature from exported interface has or is using private name '{0}'.": "匯出介面中索引簽章的傳回類型具有或使用私用名稱 '{0}'。",
        "Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named.": "匯出類別中公用靜態方法的傳回類型具有或使用外部模組 {1} 中的名稱 '{0}'，但無法命名。",
        "Return type of public static method from exported class has or is using name '{0}' from private module '{1}'.": "匯出類別中公用靜態方法的傳回類型具有或使用私用模組 '{1}' 中的名稱 '{0}'。",
        "Return type of public static method from exported class has or is using private name '{0}'.": "匯出類別中公用靜態方法的傳回類型具有或使用私用名稱 '{0}'。",
        "Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named.": "匯出類別中公用方法的傳回類型具有或使用外部模組 {1} 中的名稱 '{0}'，但無法命名。",
        "Return type of public method from exported class has or is using name '{0}' from private module '{1}'.": "匯出類別中公用方法的傳回類型具有或使用私用模組 '{1}' 中的名稱 '{0}'。",
        "Return type of public method from exported class has or is using private name '{0}'.": "匯出類別中公用方法的傳回類型具有或使用私用名稱 '{0}'。",
        "Return type of method from exported interface has or is using name '{0}' from private module '{1}'.": "匯出介面中方法的傳回類型具有或使用私用模組 '{1}' 中的名稱 '{0}'。",
        "Return type of method from exported interface has or is using private name '{0}'.": "匯出介面中方法的傳回類型具有或使用私用名稱 '{0}'。",
        "Return type of exported function has or is using name '{0}' from external module {1} but cannot be named.": "匯出函式的傳回類型具有或使用外部模組 {1} 中的名稱 '{0}'，但無法命名。",
        "Return type of exported function has or is using name '{0}' from private module '{1}'.": "匯出函式的傳回類型具有或使用私用模組 '{1}' 中的名稱 '{0}'。",
        "Return type of exported function has or is using private name '{0}'.": "匯出函式的傳回類型具有或使用私用名稱 '{0}'。",
        "Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named.": "匯出類別中建構函式的參數 '{0}' 具有或使用外部模組 {2} 中的名稱 '{1}'，但無法命名。",
        "Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'.": "匯出類別中建構函式的參數 '{0}' 具有或使用私用模組 '{2}' 中的名稱 '{1}'。",
        "Parameter '{0}' of constructor from exported class has or is using private name '{1}'.": "匯出類別中建構函式的參數 '{0}' 具有或使用私用名稱 '{1}'。",
        "Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'.": "匯出介面中建構函式簽章的參數 '{0}' 具有或使用私用模組 '{2}' 中的名稱 '{1}'。",
        "Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.": "匯出介面中建構函式簽章的參數 '{0}' 具有或使用私用名稱 '{1}'。",
        "Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'.": "匯出介面之呼叫簽章的參數 '{0}' 具有或使用私用模組 '{2}' 中的名稱 '{1}'。",
        "Parameter '{0}' of call signature from exported interface has or is using private name '{1}'.": "匯出介面之呼叫簽章的參數 '{0}' 具有或使用私用名稱 '{1}'。",
        "Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named.": "匯出類別中公用靜態方法的參數 '{0}' 具有或使用外部模組 {2} 中的名稱 '{1}'，但無法命名。",
        "Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'.": "匯出類別中公用靜態方法的參數 '{0}' 具有或使用私用模組 '{2}' 中的名稱 '{1}'。",
        "Parameter '{0}' of public static method from exported class has or is using private name '{1}'.": "匯出類別中公用靜態方法的參數 '{0}' 具有或使用私用名稱 '{1}'。",
        "Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named.": "匯出類別中公用方法的參數 '{0}' 具有或使用外部模組 {2} 中的名稱 '{1}'，但無法命名。",
        "Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'.": "匯出類別中公用方法的參數 '{0}' 具有或使用私用模組 '{2}' 中的名稱 '{1}'。",
        "Parameter '{0}' of public method from exported class has or is using private name '{1}'.": "匯出類別中公用方法的參數 '{0}' 具有或使用私用名稱 '{1}'。",
        "Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'.": "匯出介面中方法的參數 '{0}' 具有或使用私用模組 '{2}' 中的名稱 '{1}'。",
        "Parameter '{0}' of method from exported interface has or is using private name '{1}'.": "匯出介面中方法的參數 '{0}' 具有或使用私用名稱 '{1}'。",
        "Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named.": "匯出函式的參數 '{0}' 具有或使用外部模組 {2} 中的名稱 '{1}'，但無法命名。",
        "Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'.": "匯出函式的參數 '{0}' 具有或使用私用模組 '{2}' 中的名稱 '{1}'。",
        "Parameter '{0}' of exported function has or is using private name '{1}'.": "匯出函式的參數 '{0}' 具有或使用私用名稱 '{1}'。",
        "Exported type alias '{0}' has or is using private name '{1}'.": "匯出的類型別名 '{0}' 具有或使用私用名稱 '{1}'。",
        "Default export of the module has or is using private name '{0}'.": "模組的預設匯出使用了私用名稱 '{0}' 或要使用該名稱。",
        "Loop contains block-scoped variable '{0}' referenced by a function in the loop. This is only supported in ECMAScript 6 or higher.": "迴圈包含迴圈中之函式所參考的區塊範圍變數 '{0}'。只有 ECMAScript 6 或更新版本才提供此支援。",
        "The current host does not support the '{0}' option.": "目前的主機不支援 '{0}' 選項。",
        "Cannot find the common subdirectory path for the input files.": "找不到輸入檔案的一般子目錄路徑。",
        "Cannot read file '{0}': {1}": "無法讀取檔案 '{0}': {1}",
        "Unsupported file encoding.": "不支援的檔案編碼。",
        "Failed to parse file '{0}': {1}.": "無法剖析檔案 '{0}': {1}。",
        "Unknown compiler option '{0}'.": "不明的編譯器選項 '{0}'。",
        "Compiler option '{0}' requires a value of type {1}.": "編譯器選項 '{0}' 需要類型 {1} 的值。",
        "Could not write file '{0}': {1}": "無法寫入檔案 '{0}': {1}",
        "Option 'mapRoot' cannot be specified without specifying 'sourceMap' option.": "必須指定 'sourcemap' 選項才能指定 'mapRoot' 選項。",
        "Option 'sourceRoot' cannot be specified without specifying 'sourceMap' option.": "必須指定 'sourcemap' 選項才能指定 'sourceRoot' 選項。",
        "Option 'noEmit' cannot be specified with option 'out' or 'outDir'.": "不得同時指定 'noEmit' 選項與 'out' 或 'outDir' 選項 。",
        "Option 'noEmit' cannot be specified with option 'declaration'.": "不得同時指定 'declaration' 選項與 'noEmit' 選項。",
        "Option 'project' cannot be mixed with source files on a command line.": "在命令列上，'project' 選項不得與原始程式檔並用。",
        "Option 'declaration' cannot be specified with option 'isolatedModules'.": "選項 'declaration' 不可與選項 'isolatedModules' 同時指定。",
        "Option 'noEmitOnError' cannot be specified with option 'isolatedModules'.": "選項 'noEmitOnError' 不可與選項 'isolatedModules' 同時指定。",
        "Option 'out' cannot be specified with option 'isolatedModules'.": "選項 'out' 不可與選項 'isolatedModules' 同時指定。",
        "Option 'isolatedModules' can only be used when either option'--module' is provided or option 'target' is 'ES6' or higher.": "只有在提供選項 '--module' 或選項 'target' 是 'ES6' 或更高時，才可使用選項 'isolatedModules'。",
        "Option 'sourceMap' cannot be specified with option 'inlineSourceMap'.": "選項 'sourceMap' 不可與選項 'inlineSourceMap' 同時指定。",
        "Option 'sourceRoot' cannot be specified with option 'inlineSourceMap'.": "選項 'sourceRoot' 不可與選項 'inlineSourceMap' 同時指定。",
        "Option 'mapRoot' cannot be specified with option 'inlineSourceMap'.": "選項 'mapRoot' 不可與選項 'inlineSourceMap' 同時指定。",
        "Option 'inlineSources' can only be used when either option '--inlineSourceMap' or option '--sourceMap' is provided.": "只有在提供選項 '--inlineSourceMap' 或選項 '--sourceMap' 時，才可指定選項 'inlineSources'。",
        "Concatenate and emit output to single file.": "串連並發出輸出至單一檔案。",
        "Generates corresponding '.d.ts' file.": "產生對應的 '.d.ts' 檔案。",
        "Specifies the location where debugger should locate map files instead of generated locations.": "指定偵錯工具尋找對應檔的位置，而不尋找產生的位置。",
        "Specifies the location where debugger should locate TypeScript files instead of source locations.": "指定偵錯工具尋找 TypeScript 檔案的位置，而不尋找原始檔位置。",
        "Watch input files.": "監看輸入檔案。",
        "Redirect output structure to the directory.": "將輸出結構重新導向至目錄。",
        "Do not erase const enum declarations in generated code.": "請勿清除產生之程式碼中的 const 列舉宣告。",
        "Do not emit outputs if any errors were reported.": "如有回報任何錯誤，即不發出輸出。",
        "Do not emit comments to output.": "不將註解發出到輸出。",
        "Do not emit outputs.": "請勿發出輸出。",
        "Specify ECMAScript target version: 'ES3' (default), 'ES5', or 'ES6' (experimental)": "指定 ECMAScript 目標版本: 'ES3' (預設值)、'ES5' 或 'ES6' (實驗)",
        "Specify module code generation: 'commonjs', 'amd', 'system' or 'umd'": "指定產生模組程式碼: 'commonjs'、'amd'、'system' 或 'umd'",
        "Print this message.": "列印這則訊息。",
        "Print the compiler's version.": "列印編譯器的版本。",
        "Compile the project in the given directory.": "編譯指定目錄中的專案。",
        "Syntax: {0}": "語法: {0}",
        "options": "選項",
        "file1": "檔案",
        "Examples: {0}": "範例: {0}",
        "Options:": "選項:",
        "Version {0}": "{0} 版",
        "Insert command line options and files from a file.": "檔案中的插入命令列選項及檔案。",
        "File change detected. Starting incremental compilation...": "偵測到檔案變更。正在啟動累加編譯...",
        "KIND": "類型",
        "file2": "檔案",
        "VERSION": "版本",
        "LOCATION": "位置",
        "DIRECTORY": "目錄",
        "Compilation complete. Watching for file changes.": "編譯完成。正在等候檔案變更。",
        "Generates corresponding '.map' file.": "產生對應的 '.map' 檔案。",
        "Compiler option '{0}' expects an argument.": "編譯器選項 '{0}' 應有引數。",
        "Unterminated quoted string in response file '{0}'.": "回應檔 '{0}' 中有未結束的括號字串。",
        "Argument for '--module' option must be 'commonjs', 'amd', 'system' or 'umd'.": "'--module' 選項的引數必須是 'commonjs'、'amd'、'system' 或 'umd'。",
        "Argument for '--target' option must be 'ES3', 'ES5', or 'ES6'.": "'--target' 選項的引數必須是 'ES3'、'ES5' 或 'ES6'。",
        "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.": "地區設定的格式必須是 <語言> 或 <語言>-<國家/地區>。例如 '{0}' 或 '{1}'。",
        "Unsupported locale '{0}'.": "不支援的地區設定 '{0}'。",
        "Unable to open file '{0}'.": "無法開啟檔案 '{0}'。",
        "Corrupted locale file {0}.": "地區設定檔 {0} 已損毀。",
        "Raise error on expressions and declarations with an implied 'any' type.": "當運算式及宣告包含隱含的 'any' 類型時顯示錯誤。",
        "File '{0}' not found.": "找不到檔案 '{0}'。",
        "File '{0}' has unsupported extension. The only supported extensions are {1}.": "檔案 '{0}' 的附檔名不受支援。僅支援副檔名 {1}。",
        "Suppress noImplicitAny errors for indexing objects lacking index signatures.": "針對缺少索引簽章的索引物件隱藏 noImplicitAny 錯誤。",
        "Do not emit declarations for code that has an '@internal' annotation.": "請勿發出包含 '@internal' 註釋的程式碼宣告。",
        "Specifies the root directory of input files. Use to control the output directory structure with --outDir.": "指定輸入檔的根目錄。用以控制具有 --outDir 的輸出目錄結構。",
        "File '{0}' is not under 'rootDir' '{1}'. 'rootDir' is expected to contain all source files.": "檔案 '{0}' 不在 'rootDir' '{1}' 之下。'rootDir' 必須包含所有原始程式檔。",
        "Specifies the end of line sequence to be used when emitting files: 'CRLF' (dos) or 'LF' (unix).": "指定發出檔案時要用的行尾順序: 'CRLF' (DOS) 或 'LF' (UNIX)。",
        "NEWLINE": "新行",
        "Argument for '--newLine' option must be 'CRLF' or 'LF'.": "'--newLine' 選項的引數必須是 'CRLF' 或 'LF'。",
        "Specify JSX code generation: 'preserve' or 'react'": "指定 JSX 程式碼產生: 'preserve' 或 'react'",
        "Argument for '--jsx' must be 'preserve' or 'react'.": "'--jsx' 的引數必須是 'preserve' 或 'react'。",
        "Option 'experimentalDecorators' must also be specified when option 'emitDecoratorMetadata' is specified.": "指定選項 'emitDecoratorMetadata' 時，也必須指定選項 'experimentalDecorators'。",
        "Enables experimental support for ES7 decorators.": "啟用 ES7 裝飾項目的實驗支援。",
        "Enables experimental support for emitting type metadata for decorators.": "啟用實驗支援以發出裝飾項目類型的中繼資料。",
        "Option 'experimentalAsyncFunctions' cannot be specified when targeting ES5 or lower.": "當目標為 ES5 或更舊版本時，無法指定選項 'experimentalAsyncFunctions'。",
        "Enables experimental support for ES7 async functions.": "啟用 ES7 非同步函式的實驗支援。",
        "Variable '{0}' implicitly has an '{1}' type.": "變數 '{0}' 隱含 '{1}' 類型。",
        "Parameter '{0}' implicitly has an '{1}' type.": "參數 '{0}' 隱含了 '{1}' 類型。",
        "Member '{0}' implicitly has an '{1}' type.": "成員 '{0}' 隱含了 '{1}' 類型。",
        "'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.": "目標缺少建構簽章的 'new' 運算式隱含了 'any' 類型。",
        "'{0}', which lacks return-type annotation, implicitly has an '{1}' return type.": "缺少傳回類型註釋的 '{0}' 隱含了 '{1}' 傳回類型。",
        "Function expression, which lacks return-type annotation, implicitly has an '{0}' return type.": "缺少傳回類型註釋的函式運算式隱含了 '{0}' 傳回類型。",
        "Construct signature, which lacks return-type annotation, implicitly has an 'any' return type.": "缺少傳回類型註釋的建構函式簽章隱含了 'any' 傳回類型。",
        "Property '{0}' implicitly has type 'any', because its 'set' accessor lacks a type annotation.": "屬性 '{0}' 因為其 'set' 存取子缺少類型註釋，所以隱含了類型 'any'。",
        "Index signature of object type implicitly has an 'any' type.": "物件類型的索引簽章隱含了 'any' 類型。",
        "Object literal's property '{0}' implicitly has an '{1}' type.": "物件常值的屬性 '{0}' 隱含了 '{1}' 類型。",
        "Rest parameter '{0}' implicitly has an 'any[]' type.": "剩餘參數 '{0}' 隱含了 'any[]' 類型。",
        "Call signature, which lacks return-type annotation, implicitly has an 'any' return type.": "缺少傳回類型註釋的呼叫簽章隱含了 'any' 傳回類型。",
        "'{0}' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.": "因為 '{0}' 沒有類型註釋，並在其本身的初始設定式中直接或間接受到參考，所以具有隱含類型 'any'。",
        "'{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.": "'{0}' 因為沒有傳回類型註釋，並在自己的傳回運算式中直接或間接參考了自己，所以隱含了傳回類型 'any'。",
        "Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.": "函式因為沒有傳回類型註釋，並在其中一個傳回運算式中直接或間接參考了自己，所以隱含了傳回類型 'any'。",
        "Generator implicitly has type '{0}' because it does not yield any values. Consider supplying a return type.": "因為產生器不會產生任何值，所以具有隱含類型 '{0}'。請考慮提供傳回類型。",
        "JSX element implicitly has type 'any' because no interface 'JSX.{0}' exists": "因為沒有任何介面 'JSX.{0}' 存在，所以 JSX 項目具有隱含類型 'any'",
        "You cannot rename this element.": "您無法重新命名這個元素。",
        "You cannot rename elements that are defined in the standard TypeScript library.": "您無法重新命名標準 TypeScript 程式庫中所定義的項目。",
        "'import ... =' can only be used in a .ts file.": "'import ... =' 只可用於 .ts 檔案中。",
        "'export=' can only be used in a .ts file.": "'export=' 只可用於 .ts 檔案中。",
        "'type parameter declarations' can only be used in a .ts file.": "'type parameter declarations' 只可用於 .ts 檔案中。",
        "'implements clauses' can only be used in a .ts file.": "'implements clauses' 只可用於 .ts 檔案中。",
        "'interface declarations' can only be used in a .ts file.": "'interface declarations' 只可用於 .ts 檔案中。",
        "'module declarations' can only be used in a .ts file.": "'module declarations' 只可用於 .ts 檔案中。",
        "'type aliases' can only be used in a .ts file.": "'type aliases' 只可用於 .ts 檔案中。",
        "'{0}' can only be used in a .ts file.": "'{0}' 只可用於 .ts 檔案中。",
        "'types' can only be used in a .ts file.": "'types' 只可用於 .ts 檔案中。",
        "'type arguments' can only be used in a .ts file.": "'type arguments' 只可用於 .ts 檔案中。",
        "'parameter modifiers' can only be used in a .ts file.": "'parameter modifiers' 只可用於 .ts 檔案中。",
        "'property declarations' can only be used in a .ts file.": "'property declarations' 只可用於 .ts 檔案中。",
        "'enum declarations' can only be used in a .ts file.": "'enum declarations' 只可用於 .ts 檔案中。",
        "'type assertion expressions' can only be used in a .ts file.": "'type assertion expressions' 只可用於 .ts 檔案中。",
        "'decorators' can only be used in a .ts file.": "'decorators' 只可用於 .ts 檔案中。",
        "Only identifiers/qualified-names with optional type arguments are currently supported in a class 'extends' clauses.": "類別 'extends' 子句中，目前只支援具有選擇性類型引數的識別項/限定名稱。",
        "'class' expressions are not currently supported.": "目前不支援 'class' 運算式。",
        "JSX attributes must only be assigned a non-empty 'expression'.": "只能將非空白的 'expression' 指派給 JSX 屬性。",
        "JSX elements cannot have multiple attributes with the same name.": "JSX 項目不得有多個同名的屬性。",
        "Expected corresponding JSX closing tag for '{0}'.": "'{0}' 需要對應的 JSX 結尾標記。",
        "JSX attribute expected.": "需要 JSX 屬性。",
        "Cannot use JSX unless the '--jsx' flag is provided.": "除非有提供 '--jsx' 旗標，否則無法使用 JSX。",
        "A constructor cannot contain a 'super' call when its class extends 'null'": "當建構函式的類別為 'null' 時，不得包含 'super' 呼叫"
}