{
        "Unterminated string literal.": "未終了の文字列リテラルです。",
        "Identifier expected.": "識別子が必要です。",
        "'{0}' expected.": "'{0}' が必要です。",
        "A file cannot have a reference to itself.": "ファイルにそれ自体への参照を含めることはできません。",
        "Trailing comma not allowed.": "末尾にコンマは使用できません。",
        "'*/' expected.": "'*/' が必要です。",
        "Unexpected token.": "予期しないトークンです。",
        "A rest parameter must be last in a parameter list.": "rest パラメーターはパラメーター リストの最後に指定する必要があります。",
        "Parameter cannot have question mark and initializer.": "パラメーターに疑問符および初期化子を指定することはできません。",
        "A required parameter cannot follow an optional parameter.": "必須パラメーターを省略可能なパラメーターの後に指定することはできません。",
        "An index signature cannot have a rest parameter.": "インデックス シグネチャに rest パラメーターを指定することはできません。",
        "An index signature parameter cannot have an accessibility modifier.": "インデックス シグネチャのパラメーターにアクセシビリティ修飾子を指定することはできません。",
        "An index signature parameter cannot have a question mark.": "インデックス シグネチャのパラメーターに疑問符を指定することはできません。",
        "An index signature parameter cannot have an initializer.": "インデックス シグネチャのパラメーターに初期化子を指定することはできません。",
        "An index signature must have a type annotation.": "インデックス シグネチャには型の注釈が必要です。",
        "An index signature parameter must have a type annotation.": "インデックス シグネチャのパラメーターには型の注釈が必要です。",
        "An index signature parameter type must be 'string' or 'number'.": "インデックス シグネチャのパラメーターの型は 'string' または 'number' でなければなりません。",
        "Accessibility modifier already seen.": "アクセシビリティ修飾子は既に存在します。",
        "'{0}' modifier must precede '{1}' modifier.": "'{0}' 修飾子は '{1}' 修飾子の前に指定する必要があります。",
        "'{0}' modifier already seen.": "'{0}' 修飾子は既に存在します。",
        "'{0}' modifier cannot appear on a class element.": "'{0}' 修飾子はクラス要素では使用できません。",
        "'super' must be followed by an argument list or member access.": "'super' の後には、引数リストまたはメンバー アクセスが必要です。",
        "Only ambient modules can use quoted names.": "引用符付きの名前を使用できるのはアンビエント モジュールのみです。",
        "Statements are not allowed in ambient contexts.": "ステートメントはアンビエント コンテキストでは使用できません。",
        "A 'declare' modifier cannot be used in an already ambient context.": "'declare' 修飾子は、アンビエント コンテキストでは使用できません。",
        "Initializers are not allowed in ambient contexts.": "初期化子はアンビエント コンテキストでは使用できません。",
        "'{0}' modifier cannot be used in an ambient context.": "'{0}' 修飾子は環境コンテキストでは使用できません。",
        "'{0}' modifier cannot be used with a class declaration.": "'{0}' 修飾子とクラス宣言は同時に使用できません。",
        "'{0}' modifier cannot be used here.": "'{0}' 修飾子はここでは使用できません。",
        "'{0}' modifier cannot appear on a data property.": "'{0}' 修飾子はデータ プロパティでは使用できません。",
        "'{0}' modifier cannot appear on a module element.": "'{0}' 修飾子はモジュール要素では使用できません。",
        "A '{0}' modifier cannot be used with an interface declaration.": "'{0}' 修飾子とインターフェイス宣言は同時に使用できません。",
        "A 'declare' modifier is required for a top level declaration in a .d.ts file.": ".d.ts ファイルの最上位宣言には、'declare' 修飾子が必要です。",
        "A rest parameter cannot be optional.": "rest パラメーターを省略可能にすることはできません。",
        "A rest parameter cannot have an initializer.": "rest パラメーターに初期化子を指定することはできません。",
        "A 'set' accessor must have exactly one parameter.": "'set' アクセサーにはパラメーターを 1 つだけ指定しなければなりません。",
        "A 'set' accessor cannot have an optional parameter.": "'set' アクセサーに、省略可能パラメーターを指定することはできません。",
        "A 'set' accessor parameter cannot have an initializer.": "'set' アセクターのパラメーターに初期化子を含めることはできません。",
        "A 'set' accessor cannot have rest parameter.": "'set' アクセサーに rest パラメーターを指定することはできません。",
        "A 'get' accessor cannot have parameters.": "'get' アクセサーにパラメーターを指定することはできません。",
        "Type '{0}' is not a valid async function return type.": "型 '{0}' は有効な非同期関数の戻り値の型ではありません。",
        "Accessors are only available when targeting ECMAScript 5 and higher.": "アクセサーは ECMAScript 5 以上をターゲットにする場合にのみ使用できます。",
        "An async function or method must have a valid awaitable return type.": "非同期関数または非同期メソッドには、有効で待機可能な戻り値の型を指定する必要があります。",
        "Operand for 'await' does not have a valid callable 'then' member.": "'await' のオペランドに有効で呼び出し可能な 'then' メンバーが含まれていません。",
        "Return expression in async function does not have a valid callable 'then' member.": "非同期関数の return 式に、有効で呼び出し可能な 'then' メンバーが含まれていません。",
        "Expression body for async arrow function does not have a valid callable 'then' member.": "非同期アロー関数の式本文に、有効で呼び出し可能な 'then' メンバーが含まれていません。",
        "Enum member must have initializer.": "列挙メンバーには初期化子が必要です。",
        "{0} is referenced directly or indirectly in the fulfillment callback of its own 'then' method.": "'{0}' は、それ自身の 'then' メソッドのフルフィルメント コールバック内で直接または間接的に参照されます。",
        "An export assignment cannot be used in a namespace.": "エクスポートの割り当ては、名前空間では使用できません。",
        "Ambient enum elements can only have integer literal initializers.": "アンビエント列挙要素には整数リテラル初期化子のみを指定できます。",
        "Unexpected token. A constructor, method, accessor, or property was expected.": "予期しないトークンです。コンストラクター、メソッド、アクセサー、またはプロパティが必要です。",
        "A '{0}' modifier cannot be used with an import declaration.": "'{0}' 修飾子とインポート宣言は同時に使用できません。",
        "Invalid 'reference' directive syntax.": "無効な 'reference' ディレクティブ構文です。",
        "Octal literals are not available when targeting ECMAScript 5 and higher.": "octal リテラルは ECMAScript 5 以上をターゲットにする場合には使用できません。",
        "An accessor cannot be declared in an ambient context.": "アンビエント コンテキストではアクセサーは宣言できません。",
        "'{0}' modifier cannot appear on a constructor declaration.": "'{0}' 修飾子はコンストラクター宣言では使用できません。",
        "'{0}' modifier cannot appear on a parameter.": "'{0}' 修飾子はパラメーターでは使用できません。",
        "Only a single variable declaration is allowed in a 'for...in' statement.": "'for...in' ステートメントで使用できる変数宣言は 1 つのみです。",
        "Type parameters cannot appear on a constructor declaration.": "型パラメーターはコンストラクター宣言では使用できません。",
        "Type annotation cannot appear on a constructor declaration.": "型の注釈はコンストラクター宣言では使用できません。",
        "An accessor cannot have type parameters.": "アクセサーに型パラメーターを指定することはできません。",
        "A 'set' accessor cannot have a return type annotation.": "'set' アクセサーに、戻り値の型の注釈を指定することはできません。",
        "An index signature must have exactly one parameter.": "インデックス シグネチャには、パラメーターを 1 つだけ指定しなければなりません。",
        "'{0}' list cannot be empty.": "'{0}' のリストを空にすることはできません。",
        "Type parameter list cannot be empty.": "型パラメーター リストを空にすることはできません。",
        "Type argument list cannot be empty.": "型引数リストを空にすることはできません。",
        "Invalid use of '{0}' in strict mode.": "strict モードでは '{0}' の使用は無効です。",
        "'with' statements are not allowed in strict mode.": "strict モードでは 'with' ステートメントは使用できません。",
        "'delete' cannot be called on an identifier in strict mode.": "strict モードでは 'delete' を識別子で呼び出すことはできません。",
        "A 'continue' statement can only be used within an enclosing iteration statement.": "'continue' ステートメントは外側のイテレーション内でのみ使用できます。",
        "A 'break' statement can only be used within an enclosing iteration or switch statement.": "'break' ステートメントは外側のイテレーションまたは switch ステートメント内でのみ使用できます。",
        "Jump target cannot cross function boundary.": "ジャンプ先は関数の境界を越えることはできません。",
        "A 'return' statement can only be used within a function body.": "'return' ステートメントは、関数本体でのみ使用できます。",
        "Expression expected.": "式が必要です。",
        "Type expected.": "型が必要です。",
        "A class member cannot be declared optional.": "クラス メンバーを省略可能として宣言することはできません。",
        "A 'default' clause cannot appear more than once in a 'switch' statement.": "'default' 句を 'switch' ステートメントで複数回使用することはできません。",
        "Duplicate label '{0}'": "重複しているラベル '{0}'",
        "A 'continue' statement can only jump to a label of an enclosing iteration statement.": "'continue' ステートメントは、外側のイテレーション ステートメントのラベルにのみ移動できます。",
        "A 'break' statement can only jump to a label of an enclosing statement.": "'break' ステートメントは、外側のステートメントのラベルにのみ移動できます。",
        "An object literal cannot have multiple properties with the same name in strict mode.": "strict モードでは、オブジェクト リテラルに同じ名前の複数のプロパティを指定することはできません。",
        "An object literal cannot have multiple get/set accessors with the same name.": "オブジェクト リテラルに同じ名前の複数の get/set アクセサーを指定することはできません。",
        "An object literal cannot have property and accessor with the same name.": "オブジェクト リテラルには、同じ名前のプロパティおよびアクセサーを指定することはできません。",
        "An export assignment cannot have modifiers.": "エクスポートの割り当てに修飾子を指定することはできません。",
        "Octal literals are not allowed in strict mode.": "Strict モードでは Octal リテラルは使用できません。",
        "A tuple type element list cannot be empty.": "タプル型の要素リストを空にすることはできません。",
        "Variable declaration list cannot be empty.": "変数宣言リストを空にすることはできません。",
        "Digit expected.": "数字が必要です。",
        "Hexadecimal digit expected.": "16 進の数字が必要です。",
        "Unexpected end of text.": "予期しないテキストの末尾です。",
        "Invalid character.": "無効な文字です。",
        "Declaration or statement expected.": "宣言またはステートメントが必要です。",
        "Statement expected.": "ステートメントが必要です。",
        "'case' or 'default' expected.": "'case' または 'default' が必要です。",
        "Property or signature expected.": "プロパティまたはシグネチャが必要です。",
        "Enum member expected.": "列挙型メンバーが必要です。",
        "Variable declaration expected.": "変数の宣言が必要です。",
        "Argument expression expected.": "引数式が必要です。",
        "Property assignment expected.": "プロパティの割り当てが必要です。",
        "Expression or comma expected.": "式またはコンマが必要です。",
        "Parameter declaration expected.": "パラメーター宣言が必要です。",
        "Type parameter declaration expected.": "型パラメーターの宣言が必要です。",
        "Type argument expected.": "型引数が必要です。",
        "String literal expected.": "文字列リテラルが必要です。",
        "Line break not permitted here.": "ここで改行することはできません。",
        "'{' or ';' expected.": "'{' または ';' が必要です。",
        "Modifiers not permitted on index signature members.": "インデックス シグネチャ メンバーに対して修飾子は使用できません。",
        "Declaration expected.": "宣言が必要です。",
        "Import declarations in a namespace cannot reference a module.": "名前空間内のインポート宣言は、モジュールを参照できません。",
        "Cannot compile modules unless the '--module' flag is provided.": "'--module' フラグが指定されていないと、モジュールをコンパイルできません。",
        "File name '{0}' differs from already included file name '{1}' only in casing": "ファイル名 '{0}' は、既に含まれているファイル名 '{1}' と大文字と小文字の指定だけが異なります",
        "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.": "'new T[]' は配列の作成に使用できません。代わりに 'new Array<T>()' を使用してください。",
        "'const' declarations must be initialized": "'const' 宣言は初期化する必要があります。",
        "'const' declarations can only be declared inside a block.": "'const' 宣言は、ブロック内でのみ宣言できます。",
        "'let' declarations can only be declared inside a block.": "'let' 宣言は、ブロック内でのみ宣言できます。",
        "Unterminated template literal.": "未終了のテンプレート リテラルです。",
        "Unterminated regular expression literal.": "未終了の正規表現リテラルです。",
        "An object member cannot be declared optional.": "オブジェクト メンバーを省略可能として宣言することはできません。",
        "A 'yield' expression is only allowed in a generator body.": "'yield' 式は、ジェネレーター本文でのみ使用できます。",
        "Computed property names are not allowed in enums.": "計算されたプロパティ名は列挙では使用できません。",
        "A computed property name in an ambient context must directly refer to a built-in symbol.": "アンビエント コンテキスト内の計算されたプロパティ名は、組み込みシンボルを直接参照する必要があります。",
        "A computed property name in a class property declaration must directly refer to a built-in symbol.": "クラス プロパティ宣言内の計算されたプロパティ名は、組み込みシンボルを直接参照する必要があります。",
        "A computed property name in a method overload must directly refer to a built-in symbol.": "メソッド オーバーロード内の計算されたプロパティ名は、組み込みシンボルを直接参照する必要があります。",
        "A computed property name in an interface must directly refer to a built-in symbol.": "インターフェイス内の計算されたプロパティ名は、組み込みシンボルを直接参照する必要があります。",
        "A computed property name in a type literal must directly refer to a built-in symbol.": "type リテラル内の計算されたプロパティ名は、組み込みシンボルを直接参照する必要があります。",
        "A comma expression is not allowed in a computed property name.": "コンマ式は計算されたプロパティー名では使用できません。",
        "'extends' clause already seen.": "'extends' 句は既に存在します。",
        "'extends' clause must precede 'implements' clause.": "extends' 句は 'implements' 句の前に指定しなければなりません。",
        "Classes can only extend a single class.": "クラスで拡張できるクラスは 1 つのみです。",
        "'implements' clause already seen.": "'implements' 句は既に存在します。",
        "Interface declaration cannot have 'implements' clause.": "インターフェイス宣言に 'implements' 句を指定することはできません。",
        "Binary digit expected.": "2 進の数字が必要です。",
        "Octal digit expected.": "8 進の数字が必要です。",
        "Unexpected token. '{' expected.": "予期しないトークンです。'{' が必要です。",
        "Property destructuring pattern expected.": "プロパティの非構造化パターンが必要です。",
        "Array element destructuring pattern expected.": "配列要素の非構造化パターンが必要です。",
        "A destructuring declaration must have an initializer.": "非構造化宣言には初期化子が必要です。",
        "An implementation cannot be declared in ambient contexts.": "実装はアンビエント コンテキストでは宣言できません。",
        "Modifiers cannot appear here.": "ここで修飾子を使用することはできません。",
        "Merge conflict marker encountered.": "マージ競合マーカーが検出されました。",
        "A rest element cannot have an initializer.": "rest 要素に初期化子を指定することはできません。",
        "A parameter property may not be a binding pattern.": "パラメーター プロパティはバインド パターンであってはなりません。",
        "Only a single variable declaration is allowed in a 'for...of' statement.": "'for...of' ステートメントで使用できる変数宣言は 1 つのみです。",
        "The variable declaration of a 'for...in' statement cannot have an initializer.": "'for...in' ステートメントの変数宣言に初期化子を指定することはできません。",
        "The variable declaration of a 'for...of' statement cannot have an initializer.": "'for...of' ステートメントの変数宣言に初期化子を指定することはできません。",
        "An import declaration cannot have modifiers.": "インポート宣言に修飾子を指定することはできません。",
        "Module '{0}' has no default export.": "モジュール '{0}' に既定エクスポートがありません。",
        "An export declaration cannot have modifiers.": "エクスポート宣言に修飾子を指定することはできません。",
        "Export declarations are not permitted in a namespace.": "エクスポート宣言は名前空間でサポートされません。",
        "Catch clause variable name must be an identifier.": "catch 句の変数名は識別子でなければなりません。",
        "Catch clause variable cannot have a type annotation.": "catch 句の変数に型の注釈を指定することはできません。",
        "Catch clause variable cannot have an initializer.": "catch 句の変数に初期化子を指定することはできません。",
        "An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.": "拡張された Unicode エスケープ値は 0x0 と 0x10FFFF の間 (それぞれの値を含む) でなければなりません。",
        "Unterminated Unicode escape sequence.": "未終了の Unicode エスケープ シーケンスです。",
        "Line terminator not permitted before arrow.": "行の終端記号をアローの前で使用することはできません。",
        "Import assignment cannot be used when targeting ECMAScript 6 or higher. Consider using 'import * as ns from \"mod\"', 'import {a} from \"mod\"' or 'import d from \"mod\"' instead.": "ECMAScript 6 以上を対象にする場合は、インポート割り当てを使用できません。代わりに 'import * as ns from \"mod\"'、'import {a} from \"mod\"' または 'import d from \"mod\"' を使用してください。",
        "Export assignment cannot be used when targeting ECMAScript 6 or higher. Consider using 'export default' instead.": "ECMAScript 6 以上を対象にする場合は、エクスポート割り当てを使用できません。代わりに 'export default' を使用してください。",
        "Cannot compile modules into 'commonjs', 'amd', 'system' or 'umd' when targeting 'ES6' or higher.": "'ES6' 以上をターゲットにしている場合は、モジュールを 'commonjs'、'amd'、'system'、または 'umd' にコンパイルできません。",
        "Decorators are only available when targeting ECMAScript 5 and higher.": "デコレータは ECMAScript 5 以上を対象にする場合にのみ使用できます。",
        "Decorators are not valid here.": "デコレータはここでは無効です。",
        "Decorators cannot be applied to multiple get/set accessors of the same name.": "デコレータを同じ名前の複数の get/set アクセサーに適用することはできません。",
        "Cannot compile namespaces when the '--isolatedModules' flag is provided.": "'--isolatedModules' フラグが指定されていると、名前空間をコンパイルできません。",
        "Ambient const enums are not allowed when the '--isolatedModules' flag is provided.": "'--isolatedModules' フラグが指定されている場合、アンビエント const 列挙型は使用できません。",
        "Invalid use of '{0}'. Class definitions are automatically in strict mode.": "'{0}' の使用が無効です。クラス定義は自動的に厳格モードになります。",
        "A class declaration without the 'default' modifier must have a name": "'default' の修飾子がないクラス宣言には名前が必要です",
        "Identifier expected. '{0}' is a reserved word in strict mode": "ID が必要です。'{0}' は厳格モードの予約語です。",
        "Identifier expected. '{0}' is a reserved word in strict mode. Class definitions are automatically in strict mode.": "ID が必要です。'{0}' は厳格モードの予約語です。クラス定義は自動的に厳格モードになります。",
        "Identifier expected. '{0}' is a reserved word in strict mode. Modules are automatically in strict mode.": "識別子が必要です。'{0}' は、厳格モードの予約語です。モジュールは自動的に厳格モードになります。",
        "Invalid use of '{0}'. Modules are automatically in strict mode.": "'{0}' の使用方法が無効です。モジュールは自動的に厳格モードになります。",
        "Export assignment is not supported when '--module' flag is 'system'.": "割り当てのエクスポートは、'--module' フラグが 'system' の場合にはサポートされません。",
        "Experimental support for decorators is a feature that is subject to change in a future release. Specify '--experimentalDecorators' to remove this warning.": "デコレータ用の実験的なサポートは、将来のリリースで変更される可能性があります。この警告を削除するには、'--experimentalDecorators' を指定します。",
        "Generators are only available when targeting ECMAScript 6 or higher.": "ジェネレーターは、ECMAScript 6 以上をターゲットにする場合のみ使用可能です。",
        "Generators are not allowed in an ambient context.": "ジェネレーターは環境コンテキストでは使用できません。",
        "An overload signature cannot be declared as a generator.": "オーバーロードのシグネチャをジェネレーターとして宣言することはできません。",
        "'{0}' tag already specified.": "'{0}' タグは既に指定されています。",
        "Signature '{0}' must have a type predicate.": "シグネチャ '{0}' には型の述語を指定する必要があります。",
        "Cannot find parameter '{0}'.": "パラメーター '{0}' が見つかりません。",
        "Type predicate '{0}' is not assignable to '{1}'.": "型の述語 '{0}' を '{1}' に割り当てることはできません。",
        "Parameter '{0}' is not in the same position as parameter '{1}'.": "パラメーター '{0}' がパラメーター '{1}' と同じ位置にありません。",
        "A type predicate is only allowed in return type position for functions and methods.": "型の述語は、関数およびメソッドの戻り値の型の位置でのみ使用できます。",
        "A type predicate cannot reference a rest parameter.": "型の述語は rest パラメーターを参照できません。",
        "A type predicate cannot reference element '{0}' in a binding pattern.": "型の述語は、バインド パターン内の要素 '{0}' を参照できません。",
        "An export assignment can only be used in a module.": "エクスポートの割り当てはモジュールでのみ使用可能です。",
        "An import declaration can only be used in a namespace or module.": "インポート宣言は名前空間またはモジュールでのみ使用可能です。",
        "An export declaration can only be used in a module.": "エクスポート宣言はモジュールでのみ使用可能です。",
        "An ambient module declaration is only allowed at the top level in a file.": "アンビエント モジュール宣言は、ファイルの最上位にのみ使用できます。",
        "A namespace declaration is only allowed in a namespace or module.": "名前空間宣言は、名前空間かモジュールでのみ使用できます。",
        "Experimental support for async functions is a feature that is subject to change in a future release. Specify '--experimentalAsyncFunctions' to remove this warning.": "非同期関数の実験的なサポートは、将来のリリースで変更される可能性があります。この警告を削除するには、'--experimentalAsyncFunctions' を指定します。",
        "'with' statements are not allowed in an async function block.": "'with' 式は、非同期関数ブロックでは使用できません。",
        "'await' expression is only allowed within an async function.": "'await' 式は、非同期関数内でのみ使用できます。",
        "Async functions are only available when targeting ECMAScript 6 and higher.": "非同期関数は、ECMAScript 6 以上をターゲットにする場合のみ使用可能です。",
        "The return type of a property decorator function must be either 'void' or 'any'.": "プロパティ デコレータ関数の戻り値の型は、'void' か 'any' である必要があります。",
        "The return type of a parameter decorator function must be either 'void' or 'any'.": "パラメーター デコレータ関数の戻り値の型は、'void' か 'any' である必要があります。",
        "Unable to resolve signature of class decorator when called as an expression.": "式として呼び出される場合、クラス デコレータのシグネチャを解決できません。",
        "Unable to resolve signature of parameter decorator when called as an expression.": "式として呼び出される場合、パラメーター デコレータのシグネチャを解決できません。",
        "Unable to resolve signature of property decorator when called as an expression.": "式として呼び出される場合、プロパティ デコレータのシグネチャを解決できません。",
        "Unable to resolve signature of method decorator when called as an expression.": "式として呼び出される場合、メソッド デコレータのシグネチャを解決できません。",
        "'abstract' modifier can only appear on a class or method declaration.": "'abstract' 識別子は、クラス宣言またはメソッド宣言内でのみ使用できます。",
        "'{0}' modifier cannot be used with '{1}' modifier.": "'{0}' 修飾子と '{1}' 修飾子は同時に使用できません。",
        "Abstract methods can only appear within an abstract class.": "抽象メソッドは抽象クラス内でのみ使用できます。",
        "Method '{0}' cannot have an implementation because it is marked abstract.": "メソッド '{0}' は abstract に指定されているため、実装を含めることができません。",
        "Duplicate identifier '{0}'.": "識別子 '{0}' が重複しています。",
        "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.": "インスタンス メンバー変数 '{0}' の初期化子はコンストラクターで宣言された識別子 '{1}' を参照できません。",
        "Static members cannot reference class type parameters.": "静的メンバーはクラスの型パラメーターを参照できません。",
        "Circular definition of import alias '{0}'.": "インポート エイリアス '{0}' の循環定義です。",
        "Cannot find name '{0}'.": "名前 '{0}' が見つかりません。",
        "Module '{0}' has no exported member '{1}'.": "モジュール '{0}' にエクスポートされたメンバー '{1}' がありません。",
        "File '{0}' is not a module.": "ファイル '{0}' はモジュールではありません。",
        "Cannot find module '{0}'.": "モジュール '{0}' を見つけることができません。",
        "An export assignment cannot be used in a module with other exported elements.": "エクスポートの割り当ては、エクスポートされた他の要素を含むモジュールでは使用できません。",
        "Type '{0}' recursively references itself as a base type.": "型 '{0}' が、基本型としてそれ自体を再帰的に参照しています。",
        "A class may only extend another class.": "クラスで拡張できるのは別のクラスだけです。",
        "An interface may only extend a class or another interface.": "インターフェイスで拡張できるのは、クラスまたは他のインターフェイスのみです。",
        "Constraint of a type parameter cannot reference any type parameter from the same type parameter list.": "型パラメーターの制約で同じ型パラメーター リストの型パラメーターを参照することはできません。",
        "Generic type '{0}' requires {1} type argument(s).": "ジェネリック型 '{0}' には {1} 個の型引数が必要です。",
        "Type '{0}' is not generic.": "型 '{0}' はジェネリックではありません。",
        "Global type '{0}' must be a class or interface type.": "グローバル型 '{0}' はクラス型またはインターフェイス型でなければなりません。",
        "Global type '{0}' must have {1} type parameter(s).": "グローバル型 '{0}' には {1} 個の型パラメーターが必要です。",
        "Cannot find global type '{0}'.": "グローバル型 '{0}' が見つかりません。",
        "Named property '{0}' of types '{1}' and '{2}' are not identical.": "'{1}' 型および '{2}' 型の名前付きプロパティ '{0}' が一致しません。",
        "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}'.": "インターフェイス '{0}' で型 '{1}' と型 '{2}' を同時には拡張できません。",
        "Excessive stack depth comparing types '{0}' and '{1}'.": "型 '{0}' と '{1}' を比較するスタックが深すぎます。",
        "Type '{0}' is not assignable to type '{1}'.": "型 '{0}' を型 '{1}' に割り当てることはできません。",
        "Property '{0}' is missing in type '{1}'.": "型 '{1}' にプロパティ '{0}' がありません。",
        "Property '{0}' is private in type '{1}' but not in type '{2}'.": "プロパティ '{0}' は型 '{1}' ではプライベートですが、型 '{2}' ではプライベートではありません。",
        "Types of property '{0}' are incompatible.": "プロパティ '{0}' の型に互換性がありません。",
        "Property '{0}' is optional in type '{1}' but required in type '{2}'.": "プロパティ '{0}' は型 '{1}' では省略可能ですが、型 '{2}' では必須です。",
        "Types of parameters '{0}' and '{1}' are incompatible.": "パラメーター '{0}' および '{1}' は型に互換性がありません。",
        "Index signature is missing in type '{0}'.": "型 '{0}' のインデックス シグネチャがありません。",
        "Index signatures are incompatible.": "インデックスの署名に互換性がありません。",
        "'this' cannot be referenced in a module or namespace body.": "'this' はモジュール本体内または名前空間本体内では参照できません。",
        "'this' cannot be referenced in current location.": "'this' は現在の場所では参照できません。",
        "'this' cannot be referenced in constructor arguments.": "'this' はコンストラクター引数では参照できません。",
        "'this' cannot be referenced in a static property initializer.": "'this' は、静的プロパティ初期化子では参照できません。",
        "'super' can only be referenced in a derived class.": "'super' は、派生クラスでのみ参照できます。",
        "'super' cannot be referenced in constructor arguments.": "'super' はコンストラクター引数では参照できません。",
        "Super calls are not permitted outside constructors or in nested functions inside constructors.": "super の呼び出しは、コンストラクターの外部、またはコンストラクター内の入れ子になった関数では使用できません。",
        "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.": "'super' プロパティ アクセスはコンストラクター、メンバー関数、または派生クラスのメンバー アクセサーでのみ許可されます。",
        "Property '{0}' does not exist on type '{1}'.": "プロパティ '{0}' は型 '{1}' に存在しません。",
        "Only public and protected methods of the base class are accessible via the 'super' keyword.": "'super' キーワードを使用してアクセスできるのは、基底クラスのパブリック メソッドと保護されたメソッドのみです。",
        "Property '{0}' is private and only accessible within class '{1}'.": "プロパティ '{0}' はプライベートで、クラス '{1}' 内でのみアクセスできます。",
        "An index expression argument must be of type 'string', 'number', 'symbol, or 'any'.": "インデックス式の引数は 'string' 型、'number' 型、'symbol' 型、または 'any' 型のいずれかでなければなりません。",
        "Type '{0}' does not satisfy the constraint '{1}'.": "型 '{0}' は制約 '{1}' を満たしていません。",
        "Argument of type '{0}' is not assignable to parameter of type '{1}'.": "型 '{0}' の引数を型 '{1}' のパラメーターに割り当てることはできません。",
        "Supplied parameters do not match any signature of call target.": "指定されたパラメーターが呼び出し対象のどのシグネチャとも一致しません。",
        "Untyped function calls may not accept type arguments.": "型指定のない関数の呼び出しで型引数を使用することはできません。",
        "Value of type '{0}' is not callable. Did you mean to include 'new'?": "型 '{0}' の値は呼び出せません。'new' を含めますか?",
        "Cannot invoke an expression whose type lacks a call signature.": "型に呼び出しシグネチャがない式を呼び出すことはできません。",
        "Only a void function can be called with the 'new' keyword.": "'new' キーワードを指定して呼び出せるのは void 関数のみです。",
        "Cannot use 'new' with an expression whose type lacks a call or construct signature.": "呼び出しシグネチャまたはコンストラクト シグネチャがない型が含まれる式では 'new' は使用できません。",
        "Neither type '{0}' nor type '{1}' is assignable to the other.": "型 '{0}' と型 '{1}' はどちらも互いの型に割り当てることができません",
        "Object literal may only specify known properties, and '{0}' does not exist in type '{1}'.": "オブジェクト リテラルは既知のプロパティのみ指定できます。'{0}' は型 '{1}' に存在しません。",
        "No best common type exists among return expressions.": "return 式に最適な共通型がありません。",
        "A function whose declared type is neither 'void' nor 'any' must return a value or consist of a single 'throw' statement.": "宣言された型が 'void' でも 'any' でもない関数は、値を戻すか、1 つの 'throw' ステートメントを含んでいる必要があります。",
        "An arithmetic operand must be of type 'any', 'number' or an enum type.": "算術オペランドは 'any' 型、'number' 型、列挙型のいずれかでなければなりません。",
        "The operand of an increment or decrement operator must be a variable, property or indexer.": "インクリメント演算子またはデクリメント演算子のオペランドには、変数、プロパティ、またはインデクサーを指定してください。",
        "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.": "instanceof' 式の左辺には、'any' 型、オブジェクト型、または型パラメーターを指定してください。",
        "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.": "instanceof' 式の右辺には、'any' 型、または 'Function' インターフェイス型に割り当てることができる型を指定してください。",
        "The left-hand side of an 'in' expression must be of type 'any', 'string', 'number', or 'symbol'.": "'in' 式の左側の型は 'any'、'string'、'number'、または 'symbol' でなければなりません。",
        "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter": "'in' 式の右側は、'any' 型、オブジェクト型、または型パラメーターでなければなりません。",
        "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "算術演算の左辺には、'any' 型、'number' 型、または列挙型を指定してください。",
        "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "算術演算の右辺には、'any' 型、'number' 型、または列挙型を指定してください。",
        "Invalid left-hand side of assignment expression.": "代入式の左辺が無効です。",
        "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": "操作 '{0}' を型 '{1}' および '{2}' に適用することはできません。",
        "Type parameter name cannot be '{0}'": "型パラメーター名を '{0}' にすることはできません",
        "A parameter property is only allowed in a constructor implementation.": "パラメーター プロパティは、コンストラクターの実装でのみ指定できます。",
        "A rest parameter must be of an array type.": "rest パラメーターは配列型でなければなりません。",
        "A parameter initializer is only allowed in a function or constructor implementation.": "パラメーター初期化子は、関数またはコンストラクターの実装でのみ指定できます。",
        "Parameter '{0}' cannot be referenced in its initializer.": "パラメーター '{0}' はその初期化子内では参照できません。",
        "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.": "パラメーター '{0}' の初期化子はその後で宣言された識別子 '{1}' を参照できません。",
        "Duplicate string index signature.": "string インデックス シグネチャが重複しています。",
        "Duplicate number index signature.": "number インデックス シグネチャが重複しています。",
        "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.": "'super' の呼び出しは、初期化されたプロパティまたはパラメーターのプロパティがクラスに含まれている場合、コンストラクターの最初のステートメントでなければなりません。",
        "Constructors for derived classes must contain a 'super' call.": "派生クラスのコンストラクターには 'super' の呼び出しを含める必要があります。",
        "A 'get' accessor must return a value or consist of a single 'throw' statement.": "'get' アクセサーは、値を戻すか、単一の 'throw' ステートメントを含んでいる必要があります。",
        "Getter and setter accessors do not agree in visibility.": "get アクセサーおよび set アクセサーで表示が許可されていません。",
        "'get' and 'set' accessor must have the same type.": "'get' アクセサーと 'set' アクセサーは同じ型でなければなりません。",
        "A signature with an implementation cannot use a string literal type.": "実装のシグネチャには文字列リテラル型は使用できません。",
        "Specialized overload signature is not assignable to any non-specialized signature.": "特殊化されたオーバーロードのシグネチャは、特殊化されていないシグネチャに割り当てることはできません。",
        "Overload signatures must all be exported or not exported.": "オーバーロードのシグネチャは、すべてエクスポートされるか、すべてエクスポートされないかのどちらかである必要があります。",
        "Overload signatures must all be ambient or non-ambient.": "オーバーロードのシグネチャは、すべてアンビエントであるか、すべてアンビエントでないかのどちらかである必要があります。",
        "Overload signatures must all be public, private or protected.": "オーバーロードのシグネチャはすべて、public、private、または protected でなければなりません。",
        "Overload signatures must all be optional or required.": "オーバーロードのシグネチャは、すべて省略可能であるか、すべて必須であるかのどちらかである必要があります。",
        "Function overload must be static.": "関数のオーバーロードは静的でなければなりません。",
        "Function overload must not be static.": "関数のオーバーロードは静的にはできせん。",
        "Function implementation name must be '{0}'.": "関数の実装名は '{0}' でなければなりません。",
        "Constructor implementation is missing.": "コンストラクターの実装がありません。",
        "Function implementation is missing or not immediately following the declaration.": "関数の実装がないか、宣言の直後に指定されていません。",
        "Multiple constructor implementations are not allowed.": "コンストラクターを複数実装することはできません。",
        "Duplicate function implementation.": "関数の実装が重複しています。",
        "Overload signature is not compatible with function implementation.": "オーバーロード シグネチャは関数の実装に対応していません。",
        "Individual declarations in merged declaration '{0}' must be all exported or all local.": "マージされた宣言 '{0}' の個々の宣言はすべてエクスポートされるか、すべてローカルであるかのどちらかである必要があります。",
        "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.": "識別子 'arguments' が重複しています。コンパイラは 'arguments' を使用して rest パラメーターを初期化します。",
        "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.": "識別子 '_this' が重複しています。コンパイラは変数宣言 '_this' を使用して '_this' の参照をキャプチャします。",
        "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.": "式は、コンパイラが 'this' の参照をキャプチャするために使用する変数宣言 '_this' に解決されます。",
        "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.": "識別子 '_super' が重複しています。コンパイラは '_super' を使用して基底クラスの参照をキャプチャします。",
        "Expression resolves to '_super' that compiler uses to capture base class reference.": "式は、コンパイラが基底クラスの参照をキャプチャするために使用する '_super' に解決されます。",
        "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.": "後続の変数宣言は同じ型でなければなりません。変数 '{0}' の型は '{1}' である必要がありますが、'{2}' になっています。",
        "The left-hand side of a 'for...in' statement cannot use a type annotation.": "'for...in' ステートメントの左側で型の注釈を使用することはできません。",
        "The left-hand side of a 'for...in' statement must be of type 'string' or 'any'.": "'for...in' ステートメントの左側の型は 'string' または 'any' でなければなりません。",
        "Invalid left-hand side in 'for...in' statement.": "'for...in' ステートメントの左側が無効です。",
        "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.": "for...in' ステートメントの右辺には、'any' 型、オブジェクト型、または型パラメーターを指定してください。",
        "Setters cannot return a value.": "セッターは値を返せません。",
        "Return type of constructor signature must be assignable to the instance type of the class": "コンストラクター シグネチャの戻り値の型は、クラスのインスタンス型に割り当て可能でなければなりません",
        "All symbols within a 'with' block will be resolved to 'any'.": "'with' ブロック内のシンボルはすべて 'any' に解決されます。",
        "Property '{0}' of type '{1}' is not assignable to string index type '{2}'.": "型 '{1}' のプロパティ '{0}' を文字列インデックス型 '{2}' に割り当てることはできません。",
        "Property '{0}' of type '{1}' is not assignable to numeric index type '{2}'.": "型 '{1}' のプロパティ '{0}' を数値インデックス型 '{2}' に割り当てることはできません。",
        "Numeric index type '{0}' is not assignable to string index type '{1}'.": "数値インデックス型 '{0}' を文字列インデックス型 '{1}' に割り当てることはできません。",
        "Class name cannot be '{0}'": "クラス名を '{0}' にすることはできません。",
        "Class '{0}' incorrectly extends base class '{1}'.": "クラス '{0}' は基底クラス '{1}' を正しく拡張していません。",
        "Class static side '{0}' incorrectly extends base class static side '{1}'.": "クラス側の静的な '{0}' が基底クラス側の静的な '{1}' を正しく拡張していません。",
        "Type name '{0}' in extends clause does not reference constructor function for '{0}'.": "extends 句の型名 '{0}' が '{0}' のコンストラクター関数を参照していません。",
        "Class '{0}' incorrectly implements interface '{1}'.": "クラス '{0}' はインターフェイス '{1}' を正しく実装していません。",
        "A class may only implement another class or interface.": "クラスで実装できるのは別のクラスまたはインターフェイスだけです。",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.": "クラス '{0}' で定義されたインスタンス メンバー関数 '{1}' が、拡張されたクラス '{2}' ではインスタンス メンバー アクセサーとして定義されています。",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.": "クラス '{0}' で定義されたインスタンス メンバー関数 '{1}' が、拡張されたクラス '{2}' ではインスタンス メンバー プロパティとして定義されています。",
        "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.": "クラス '{0}' で定義されたインスタンス メンバー プロパティ '{1}' が、拡張されたクラス '{2}' ではインスタンス メンバー関数として定義されています。",
        "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.": "クラス '{0}' で定義されたインスタンス メンバー アクセサー '{1}' が、拡張されたクラス '{2}' ではインスタンス メンバー関数として定義されています。",
        "Interface name cannot be '{0}'": "インターフェイス名を '{0}' にすることはできません",
        "All declarations of an interface must have identical type parameters.": "インターフェイスのすべての宣言に同一の型パラメーターが必要です。",
        "Interface '{0}' incorrectly extends interface '{1}'.": "インターフェイス '{0}' はインターフェイス '{1}' を正しく拡張していません。",
        "Enum name cannot be '{0}'": "列挙型の名前を '{0}' にすることはできません",
        "In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.": "複数の宣言がある列挙で、最初の列挙要素の初期化子を省略できるの宣言は 1 つのみです。",
        "A namespace declaration cannot be in a different file from a class or function with which it is merged": "名前空間の宣言は、それがマージされるクラスまたは関数と同じファイルに配置する必要があります。",
        "A namespace declaration cannot be located prior to a class or function with which it is merged": "名前空間の宣言は、それがマージされるクラスまたは関数より後に配置する必要があります",
        "Ambient modules cannot be nested in other modules.": "アンビエント モジュールは、他のモジュールの中で入れ子にすることはできません。",
        "Ambient module declaration cannot specify relative module name.": "アンビエント モジュール宣言では、相対モジュール名を指定できません。",
        "Module '{0}' is hidden by a local declaration with the same name": "モジュール '{0}' は同じ名前のローカル宣言によって非表示になっています",
        "Import name cannot be '{0}'": "インポート名を '{0}' にすることはできません",
        "Import or export declaration in an ambient module declaration cannot reference module through relative module name.": "アンビエント モジュール宣言内のインポート宣言またはエクスポート宣言は、相対モジュール名を通してモジュールを参照することはできません。",
        "Import declaration conflicts with local declaration of '{0}'": "インポート宣言が、'{0}' のローカル宣言と競合しています",
        "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module.": "識別子 '{0}' が重複しています。コンパイラは、モジュールの最上位のスコープに名前 '{1}' を予約します。",
        "Types have separate declarations of a private property '{0}'.": "複数の型に、プライベート プロパティ '{0}' の異なる宣言が含まれています。",
        "Property '{0}' is protected but type '{1}' is not a class derived from '{2}'.": "プロパティ '{0}' は保護されていますが、型 '{1}' は '{2}' から派生したクラスではありません。",
        "Property '{0}' is protected in type '{1}' but public in type '{2}'.": "プロパティ '{0}' は型 '{1}' では保護されていますが、型 '{2}' ではパブリックです。",
        "Property '{0}' is protected and only accessible within class '{1}' and its subclasses.": "プロパティ '{0}' は保護されているため、クラス '{1}' とそのサブクラス内でのみアクセスできます。",
        "Property '{0}' is protected and only accessible through an instance of class '{1}'.": "プロパティ '{0}' は保護されているため、クラス '{1}' のインスタンス経由でのみアクセスできます。",
        "The '{0}' operator is not allowed for boolean types. Consider using '{1}' instead.": "'{0}' 演算子はブール型には使用できません。代わりに '{1}' を使用してください。",
        "Block-scoped variable '{0}' used before its declaration.": "ブロック スコープの変数 '{0}' が、宣言の前に使用されています。",
        "The operand of an increment or decrement operator cannot be a constant.": "インクリメントまたはデクリメント演算子のオペランドを定数にすることはできません。",
        "Left-hand side of assignment expression cannot be a constant.": "代入式の左辺を定数にすることはできません。",
        "Cannot redeclare block-scoped variable '{0}'.": "ブロック スコープの変数 '{0}' を再宣言することはできません。",
        "An enum member cannot have a numeric name.": "列挙メンバーに数値名を含めることはできません。",
        "The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.": "型パラメーター '{0}' の型引数を使用法から推論することはできません。型引数を明示的に指定してください。",
        "Type argument candidate '{1}' is not a valid type argument because it is not a supertype of candidate '{0}'.": "型引数の候補 '{1}' は、候補 '{0}' のスーパータイプではないため、有効な型引数ではありません。",
        "Type alias '{0}' circularly references itself.": "型のエイリアス '{0}' が自身を循環参照しています。",
        "Type alias name cannot be '{0}'": "型のエイリアス名を '{0}' にはできません。",
        "An AMD module cannot have multiple name assignments.": "AMD モジュールに複数の名前を割り当てることはできません。",
        "Type '{0}' has no property '{1}' and no string index signature.": "型 '{0}' にプロパティ '{1}' および string インデックス シグネチャがありません。",
        "Type '{0}' has no property '{1}'.": "型 '{0}' にプロパティ '{1}' がありません。",
        "Type '{0}' is not an array type.": "型 '{0}' は配列型ではありません。",
        "A rest element must be last in an array destructuring pattern": "rest 要素は配列の非構造化パターンの最後に指定する必要があります。",
        "A binding pattern parameter cannot be optional in an implementation signature.": "実装シグネチャでバインド パターン パラメーターを省略可能にすることはできません。",
        "A computed property name must be of type 'string', 'number', 'symbol', or 'any'.": "計算されたプロパティ名は 'string' 型、'number' 型、'symbol' 型、または 'any' 型のいずれかでなければなりません。",
        "'this' cannot be referenced in a computed property name.": "'this' は、計算されたプロパティ名では参照できません。",
        "'super' cannot be referenced in a computed property name.": "'super' は、計算されたプロパティ名では参照できません。",
        "A computed property name cannot reference a type parameter from its containing type.": "計算されたプロパティ名は、型パラメーターをそれを含む型から参照することはできません。",
        "Cannot find global value '{0}'.": "グローバル値 '{0}' が見つかりません。",
        "The '{0}' operator cannot be applied to type 'symbol'.": "'{0}' 演算子を 'symbol' 型に適用することはできません。",
        "'Symbol' reference does not refer to the global Symbol constructor object.": "'Symbol' 参照は、グローバル シンボル コンストラクタ オブジェクトを参照しません。",
        "A computed property name of the form '{0}' must be of type 'symbol'.": "形式 '{0}' の計算されたプロパティ名は 'symbol' 型でなければなりません。",
        "Spread operator in 'new' expressions is only available when targeting ECMAScript 5 and higher.": "'new' 式のスプレッド演算子は ECMAScript 5 以上をターゲットにする場合にのみ使用できます。",
        "Enum declarations must all be const or non-const.": "enum 宣言は、すべてが定数、またはすべてが非定数でなければなりません。",
        "In 'const' enum declarations member initializer must be constant expression.": "'const' 列挙型の宣言で、メンバー初期化子は定数式でなければなりません。",
        "'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment.": "'const' 列挙型は、プロパティまたはインデックスのアクセス式、あるいはインポート宣言またはエクスポート割り当ての右辺にのみ使用できます。",
        "A const enum member can only be accessed using a string literal.": "const 列挙型メンバーは、文字列リテラルを使用してのみアクセスできます。",
        "'const' enum member initializer was evaluated to a non-finite value.": "'const' 列挙メンバーの初期化子が、無限値に評価されました。",
        "'const' enum member initializer was evaluated to disallowed value 'NaN'.": "'const' 列挙メンバーの初期化子が、許可されない値 'NaN' に評価されました。",
        "Property '{0}' does not exist on 'const' enum '{1}'.": "プロパティ '{0}' が 'const' 列挙 '{1}' に存在しません。",
        "'let' is not allowed to be used as a name in 'let' or 'const' declarations.": "'let' は、'let' 宣言または 'const' 宣言で名前として使用することはできません。",
        "Cannot initialize outer scoped variable '{0}' in the same scope as block scoped declaration '{1}'.": "ブロック スコープ宣言 '{1}' と同じスコープ内の外部スコープ変数 '{0}' を初期化できません。",
        "The left-hand side of a 'for...of' statement cannot use a type annotation.": "'for...of' ステートメントの左側で型の注釈を使用することはできません。",
        "Export declaration conflicts with exported declaration of '{0}'": "エクスポート宣言が、'{0}' のエクスポートされた宣言と競合しています",
        "The left-hand side of a 'for...of' statement cannot be a previously defined constant.": "'for...of' ステートメントの左側を以前に定義された定数にすることはできません。",
        "The left-hand side of a 'for...in' statement cannot be a previously defined constant.": "'for...in' ステートメントの左側を以前に定義された定数にすることはできません。",
        "Invalid left-hand side in 'for...of' statement.": "'for...of' ステートメントの左辺が無効です。",
        "Type must have a '[Symbol.iterator]()' method that returns an iterator.": "型には、反復子を返す '[Symbol.iterator]()' メソッドが必要です。",
        "An iterator must have a 'next()' method.": "反復子には 'next()' メソッドが必要です。",
        "The type returned by the 'next()' method of an iterator must have a 'value' property.": "反復子の 'next()' メソッドによって返される型には 'value' プロパティが必要です。",
        "The left-hand side of a 'for...in' statement cannot be a destructuring pattern.": "'for...in' ステートメントの左側を非構造化パターンにすることはできません。",
        "Cannot redeclare identifier '{0}' in catch clause": "catch 句で識別子 '{0}' を再宣言することはできません",
        "Tuple type '{0}' with length '{1}' cannot be assigned to tuple with length '{2}'.": "長さが '{1}' のタプル型 '{0}' を長さが '{2}' のタプルに割り当てることはできません。",
        "Using a string in a 'for...of' statement is only supported in ECMAScript 5 and higher.": "'for...of' ステートメントでの文字列の使用は ECMAScript 5 以上でのみサポートされています。",
        "Type '{0}' is not an array type or a string type.": "型 '{0}' は配列型でも文字列型でもありません。",
        "The 'arguments' object cannot be referenced in an arrow function in ES3 and ES5. Consider using a standard function expression.": "'arguments' オブジェクトは、ES3 および ES5 のアロー関数で参照することはできません。標準の関数式の使用を考慮してください。",
        "Module '{0}' resolves to a non-module entity and cannot be imported using this construct.": "モジュール '{0}' はモジュール以外のエンティティに解決されるため、このコンストラクトを使用してインポートできません。",
        "Module '{0}' uses 'export =' and cannot be used with 'export *'.": "モジュール '{0}' には 'export =' が使用されているため、'export *' は併用できません。",
        "An interface can only extend an identifier/qualified-name with optional type arguments.": "インターフェイスが拡張するのは、オプションの型引数が指定された ID/完全修飾名のみです。",
        "A class can only implement an identifier/qualified-name with optional type arguments.": "クラスで実装できるのは、オプションの型引数を指定した ID/完全修飾名のみです。",
        "A rest element cannot contain a binding pattern.": "rest 要素にバインド パターンを含めることはできません。",
        "'{0}' is referenced directly or indirectly in its own type annotation.": "'{0}' はそれ自身の型の注釈内で直接または間接的に参照されます。",
        "Cannot find namespace '{0}'.": "名前空間 '{0}' を見つけることができません。",
        "No best common type exists among yield expressions.": "yield 式に最適な共通型がありません。",
        "A generator cannot have a 'void' type annotation.": "ジェネレーターに 'void' 型の注釈を指定することはできません。",
        "'{0}' is referenced directly or indirectly in its own base expression.": "'{0}' はそれ自身のベース式内で直接または間接的に参照されます。",
        "Type '{0}' is not a constructor function type.": "型 '{0}' はコンストラクター関数型ではありません。",
        "No base constructor has the specified number of type arguments.": "指定した数の型引数を持つ基底コンストラクターは存在しません。",
        "Base constructor return type '{0}' is not a class or interface type.": "既定コンストラクターの戻り値の型 '{0}' は、クラス型またはインターフェイス型ではありません。",
        "Base constructors must all have the same return type.": "既定コンストラクターの戻り値の型は、すべて同じである必要があります。",
        "Cannot create an instance of the abstract class '{0}'.": "抽象クラス '{0}' のインスタンスを作成できません。",
        "Overload signatures must all be abstract or not abstract.": "オーバーロードのシグネチャは、すべて抽象か、すべて非抽象かのどちらかである必要があります。",
        "Abstract method '{0}' in class '{1}' cannot be accessed via super expression.": "クラス '{1}' の抽象メソッド '{0}' には super 式を介してアクセスできません。",
        "Classes containing abstract methods must be marked abstract.": "抽象メソッドを含むクラスは abstract に指定する必要があります。",
        "Non-abstract class '{0}' does not implement inherited abstract member '{1}' from class '{2}'.": "非抽象クラス '{0}' はクラス '{2}' からの継承抽象メンバー '{1}' を実装しません。",
        "All declarations of an abstract method must be consecutive.": "抽象メソッドの宣言はすべて連続している必要があります。",
        "Cannot assign an abstract constructor type to a non-abstract constructor type.": "抽象コンストラクター型を非抽象コンストラクター型に割り当てることはできません。",
        "Only an ambient class can be merged with an interface.": "アンビエント クラスのみインターフェイスとマージできます。",
        "Duplicate identifier '{0}'. Compiler uses declaration '{1}' to support async functions.": "識別子 '{0}' が重複しています。コンパイラは宣言 '{1}' を使用して非同期関数をサポートします。",
        "Expression resolves to variable declaration '{0}' that compiler uses to support async functions.": "式は、コンパイラが非同期関数をサポートするために使用する変数宣言 '{0}' に解決されます。",
        "The 'arguments' object cannot be referenced in an async arrow function. Consider using a standard async function expression.": "'arguments' オブジェクトは、非同期アロー関数で参照することはできません。標準の非同期関数式を使用することを検討してください。",
        "'yield' expressions cannot be used in a parameter initializer.": "'yield' 式は、パラメーター初期化子では使用できません。",
        "'await' expressions cannot be used in a parameter initializer.": "'await' 式は、パラメーター初期化子では使用できません。",
        "JSX element attributes type '{0}' must be an object type.": "JSX 要素属性の型 '{0}' はオブジェクト型である必要があります。",
        "The return type of a JSX element constructor must return an object type.": "JSX 要素コンストラクターの戻り値の型は、オブジェクト型を返す必要があります。",
        "JSX element implicitly has type 'any' because the global type 'JSX.Element' does not exist.": "グローバル型 'JSX.Element' が存在しないため、JSX 要素は暗黙的に型 'any' になります。",
        "Property '{0}' in type '{1}' is not assignable to type '{2}'": "型 '{1}' のプロパティ '{0}' を型 '{2}' に割り当てることはできません",
        "JSX element type '{0}' does not have any construct or call signatures.": "JSX 要素型 '{0}' にはコンストラクトも呼び出しシグネチャも含まれていません。",
        "JSX element type '{0}' is not a constructor function for JSX elements.": "JSX 要素型 '{0}' は JSX 要素のコンストラクター関数ではありません。",
        "Property '{0}' of JSX spread attribute is not assignable to target property.": "JSX のスプレッド属性のプロパティ '{0}' をターゲット プロパティに割り当てることはできません。",
        "JSX element class does not support attributes because it does not have a '{0}' property": "JSX 要素クラスは '{0}' プロパティを含まないため、属性をサポートしていません。",
        "The global type 'JSX.{0}' may not have more than one property": "グローバル型 'JSX.{0}' には複数のプロパティを指定できません",
        "Cannot emit namespaced JSX elements in React": "名前空間化された JSX 要素を React 内に出力できません",
        "A member initializer in a 'const' enum declaration cannot reference members declared after it, including members defined in other 'const' enums.": "'const' enum 宣言のメンバー初期化子は、その後で宣言されるメンバーを参照できません。これには、他の 'const' enum で定義されるメンバーも含まれます。",
        "Merged declaration '{0}' cannot include a default export declaration. Consider adding a separate 'export default {0}' declaration instead.": "マージされた宣言 '{0}' に既定のエクスポート宣言を含めることはできません。代わりに、'export default {0}' 宣言を別個に追加することを検討してください。",
        "Import declaration '{0}' is using private name '{1}'.": "インポート宣言 '{0}' がプライベート名 '{1}' を使用しています。",
        "Type parameter '{0}' of exported class has or is using private name '{1}'.": "エクスポートされたクラスの型パラメーター '{0}' が、プライベート名 '{1}' を使用しています。",
        "Type parameter '{0}' of exported interface has or is using private name '{1}'.": "エクスポートされたインターフェイスの型パラメーター '{0}' が、プライベート名 '{1}' を使用しています。",
        "Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.": "エクスポートされたインターフェイスのコンストラクター シグネチャの型パラメーター '{0}' が、プライベート名 '{1}' を使用しています。",
        "Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'.": "エクスポートされたインターフェイスの呼び出しシグネチャの型パラメーター '{0}' が、プライベート名 '{1}' を使用しています。",
        "Type parameter '{0}' of public static method from exported class has or is using private name '{1}'.": "エクスポートされたクラスのパブリック静的メソッドの型パラメーター '{0}' が、プライベート名 '{1}' を使用しています。",
        "Type parameter '{0}' of public method from exported class has or is using private name '{1}'.": "エクスポートされたクラスのパブリック メソッドの型パラメーター '{0}' が、プライベート名 '{1}' を使用しています。",
        "Type parameter '{0}' of method from exported interface has or is using private name '{1}'.": "エクスポートされたインターフェイスのメソッドの型パラメーター '{0}' が、プライベート名 '{1}' を使用しています。",
        "Type parameter '{0}' of exported function has or is using private name '{1}'.": "エクスポートされた関数の型パラメーター '{0}' が、プライベート名 '{1}' を使用しています。",
        "Implements clause of exported class '{0}' has or is using private name '{1}'.": "エクスポートされたクラス '{0}' の Implements 句がプライベート名 '{1}' を使用しています。",
        "Extends clause of exported class '{0}' has or is using private name '{1}'.": "エクスポートされたクラス '{0}' の Extends 句がプライベート名 '{1}' を使用しています。",
        "Extends clause of exported interface '{0}' has or is using private name '{1}'.": "エクスポートされたインターフェイス '{0}' の Extends 句がプライベート名 '{1}' を使用しています。",
        "Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named.": "エクスポートされた変数 '{0}' が外部モジュール {2} の名前 '{1}' を使用していますが、名前を指定することはできません。",
        "Exported variable '{0}' has or is using name '{1}' from private module '{2}'.": "エクスポートされた変数 '{0}' がプライベート モジュール '{2}' の名前 '{1}' を使用しています。",
        "Exported variable '{0}' has or is using private name '{1}'.": "エクスポートされた変数 '{0}' がプライベート名 '{1}' を使用しています。",
        "Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.": "エクスポートされたクラスのパブリック静的プロパティ '{0}' が外部モジュール {2} の名前 '{1}' を使用していますが、名前を指定することはできません。",
        "Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'.": "エクスポートされたクラスのパブリック静的プロパティ '{0}' が、プライベート モジュール '{2}' の名前 '{1}' を使用しています。",
        "Public static property '{0}' of exported class has or is using private name '{1}'.": "エクスポートされたクラスのパブリック静的プロパティ '{0}' が、プライベート名 '{1}' を使用しています。",
        "Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.": "エクスポートされたクラスのパブリック プロパティ '{0}' が外部モジュール {2} の名前 '{1}' を使用していますが、名前を指定することはできません。",
        "Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'.": "エクスポートされたクラスのパブリック プロパティ '{0}' が、プライベート モジュール '{2}' の名前 '{1}' を使用しています。",
        "Public property '{0}' of exported class has or is using private name '{1}'.": "エクスポートされたクラスのパブリック プロパティ '{0}' が、プライベート名 '{1}' を使用しています。",
        "Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'.": "エクスポートされたインターフェイスのプロパティ '{0}'が、プライベート モジュール '{2}' の名前 '{1}' を使用しています。",
        "Property '{0}' of exported interface has or is using private name '{1}'.": "エクスポートされたインターフェイスのプロパティ '{0}' が、プライベート名 '{1}' を使用しています。",
        "Parameter '{0}' of public static property setter from exported class has or is using name '{1}' from private module '{2}'.": "エクスポートされたクラスのパブリック静的プロパティ セッターのパラメーター '{0}' が、プライベート モジュール '{2}' の名前 '{1}' を使用しています。",
        "Parameter '{0}' of public static property setter from exported class has or is using private name '{1}'.": "エクスポートされたクラスのパブリック静的プロパティ セッターのパラメーター '{0}' が、プライベート名 '{1}' を使用しています。",
        "Parameter '{0}' of public property setter from exported class has or is using name '{1}' from private module '{2}'.": "エクスポートされたクラスのパブリック プロパティ セッターのパラメーター '{0}' が、プライベート モジュール '{2}' の名前 '{1}' を使用しています。",
        "Parameter '{0}' of public property setter from exported class has or is using private name '{1}'.": "エクスポートされたクラスのパブリック プロパティ セッターのパラメーター '{0}' が、プライベート名 '{1}' を使用しています。",
        "Return type of public static property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.": "エクスポートされたクラスのパブリック静的プロパティ ゲッターの戻り値の型が外部モジュール {1} の名前 '{0}' を使用していますが、名前を指定することはできません。",
        "Return type of public static property getter from exported class has or is using name '{0}' from private module '{1}'.": "エクスポートされたクラスのパブリック静的プロパティ ゲッターの戻り値の型が、プライベート モジュール '{1}' の名前 '{0}' を使用しています。",
        "Return type of public static property getter from exported class has or is using private name '{0}'.": "エクスポートされたクラスのパブリック静的プロパティ ゲッターの戻り値の型が、プライベート名 '{0}' を使用しています。",
        "Return type of public property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.": "エクスポートされたクラスのパブリック プロパティ ゲッターの戻り値の型が外部モジュール {1} の名前 '{0}' を使用していますが、名前を指定することはできません。",
        "Return type of public property getter from exported class has or is using name '{0}' from private module '{1}'.": "エクスポートされたクラスのパブリック プロパティ ゲッターの戻り値の型が、プライベート モジュール '{1}' の名前 '{0}' を使用しています。",
        "Return type of public property getter from exported class has or is using private name '{0}'.": "エクスポートされたクラスのパブリック プロパティ ゲッターの戻り値の型が、プライベート名 '{0}' を使用しています。",
        "Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'.": "エクスポートされたインターフェイスのコンストラクター シグネチャの戻り値の型が、プライベート モジュール '{1}' の名前 '{0}' を使用しています。",
        "Return type of constructor signature from exported interface has or is using private name '{0}'.": "エクスポートされたインターフェイスのコンストラクター シグネチャの戻り値の型が、プライベート名 '{0}' を使用しています。",
        "Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'.": "エクスポートされたインターフェイスの呼び出しシグネチャの戻り値の型が、プライベート モジュール '{1}' の名前 '{0}' を使用しています。",
        "Return type of call signature from exported interface has or is using private name '{0}'.": "エクスポートされたインターフェイスの呼び出しシグネチャの戻り値の型が、プライベート名 '{0}' を使用しています。",
        "Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'.": "エクスポートされたインターフェイスのインデックス シグネチャの戻り値の型が、プライベート モジュール '{1}' の名前 '{0}' を使用しています。",
        "Return type of index signature from exported interface has or is using private name '{0}'.": "エクスポートされたインターフェイスのインデックス シグネチャの戻り値の型が、プライベート名 '{0}' を使用しています。",
        "Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named.": "エクスポートされたクラスのパブリック静的メソッドの戻り値の型が外部モジュール {1} の名前 '{0}' を使用していますが、名前を指定することはできません。",
        "Return type of public static method from exported class has or is using name '{0}' from private module '{1}'.": "エクスポートされたクラスのパブリック静的メソッドの戻り値の型が、プライベート モジュール '{1}' の名前 '{0}' を使用しています。",
        "Return type of public static method from exported class has or is using private name '{0}'.": "エクスポートされたクラスのパブリック静的メソッドの戻り値の型が、プライベート名 '{0}' を使用しています。",
        "Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named.": "エクスポートされたクラスのパブリック メソッドの戻り値の型が外部モジュール {1} の名前 '{0}' を使用していますが、名前を指定することはできません。",
        "Return type of public method from exported class has or is using name '{0}' from private module '{1}'.": "エクスポートされたクラスのパブリック メソッドの戻り値の型が、プライベート モジュール '{1}' の名前 '{0}' を使用しています。",
        "Return type of public method from exported class has or is using private name '{0}'.": "エクスポートされたクラスのパブリック メソッドの戻り値の型が、プライベート名 '{0}' を使用しています。",
        "Return type of method from exported interface has or is using name '{0}' from private module '{1}'.": "エクスポートされたインターフェイスのメソッドの戻り値の型が、プライベート モジュール '{1}' の名前 '{0}' を使用しています。",
        "Return type of method from exported interface has or is using private name '{0}'.": "エクスポートされたインターフェイスのメソッドの戻り値の型が、プライベート名 '{0}' を使用しています。",
        "Return type of exported function has or is using name '{0}' from external module {1} but cannot be named.": "エクスポートされた関数の戻り値の型が外部モジュール {1} の名前 '{0}' を使用していますが、名前を指定することはできません。",
        "Return type of exported function has or is using name '{0}' from private module '{1}'.": "エクスポートされた関数の戻り値の型が、プライベート モジュール '{1}' の名前 '{0}' を使用しています。",
        "Return type of exported function has or is using private name '{0}'.": "エクスポートされた関数の戻り値の型が、プライベート名 '{0}' を使用しています。",
        "Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named.": "エクスポートされたクラスのコンストラクターのパラメーター '{0}' が外部モジュール {2} の名前 '{1}' を使用していますが、名前を指定することはできません。",
        "Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'.": "エクスポートされたクラスのコンストラクターのパラメーター '{0}' が、プライベート モジュール '{2}' の名前 '{1}' を使用しています。",
        "Parameter '{0}' of constructor from exported class has or is using private name '{1}'.": "エクスポートされたクラスのコンストラクターのパラメーター '{0}' がプライベート名 '{1}' を使用しています。",
        "Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'.": "エクスポートされたインターフェイスのコンストラクター シグネチャのパラメーター '{0}' が、プライベート モジュール '{2}' の名前 '{1}' を使用しています。",
        "Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.": "エクスポートされたインターフェイスのコンストラクター シグネチャのパラメーター '{0}' が、プライベート名 '{1}' を使用しています。",
        "Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'.": "エクスポートされたインターフェイスの呼び出しシグネチャのパラメーター '{0}' が、プライベート モジュール '{2}' の名前 '{1}' を使用しています。",
        "Parameter '{0}' of call signature from exported interface has or is using private name '{1}'.": "エクスポートされたインターフェイスの呼び出しシグネチャのパラメーター '{0}' が、プライベート名 '{1}' を使用しています。",
        "Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named.": "エクスポートされたクラスのパブリック静的メソッドのパラメーター '{0}' が外部モジュール {2} の名前 '{1}' を使用していますが、名前を指定することはできません。",
        "Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'.": "エクスポートされたクラスのパブリック静的メソッドのパラメーター '{0}' が、プライベート モジュール '{2}' の名前 '{1}' を使用しています。",
        "Parameter '{0}' of public static method from exported class has or is using private name '{1}'.": "エクスポートされたクラスのパブリック静的メソッドのパラメーター '{0}' が、プライベート名 '{1}' を使用しています。",
        "Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named.": "エクスポートされたクラスのパブリック メソッドのパラメーター '{0}' が外部モジュール {2} の名前 '{1}' を使用していますが、名前を指定することはできません。",
        "Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'.": "エクスポートされたクラスのパブリック メソッドのパラメーター '{0}' が、プライベート モジュール '{2}' の名前 '{1}' を使用しています。",
        "Parameter '{0}' of public method from exported class has or is using private name '{1}'.": "エクスポートされたクラスのパブリック メソッドのパラメーター '{0}' がプライベート名 '{1}' を使用しています。",
        "Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'.": "エクスポートされたインターフェイスのメソッドのパラメーター '{0}' が、プライベート モジュール '{2}' の名前 '{1}' を使用しています。",
        "Parameter '{0}' of method from exported interface has or is using private name '{1}'.": "エクスポートされたインターフェイスのメソッドのパラメーター '{0}' がプライベート名 '{1}' を使用しています。",
        "Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named.": "エクスポートされた関数のパラメーター '{0}' が外部モジュール {2} の名前 '{1}' を使用していますが、名前を指定することはできません。",
        "Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'.": "エクスポートされた関数のパラメーター '{0}' が、プライベート モジュール '{2}' の名前 '{1}' を使用しています。",
        "Parameter '{0}' of exported function has or is using private name '{1}'.": "エクスポートされた関数のパラメーター '{0}' がプライベート名 '{1}' を使用しています。",
        "Exported type alias '{0}' has or is using private name '{1}'.": "エクスポートされた型のエイリアス '{0}' にプライベート名 '{1}' が付いているか、その名前を使用しています。",
        "Default export of the module has or is using private name '{0}'.": "モジュールの既定エクスポートがプライベート名 '{0}' を使用しています。",
        "Loop contains block-scoped variable '{0}' referenced by a function in the loop. This is only supported in ECMAScript 6 or higher.": "ループには、ループ内の関数によって参照されたブロック スコープの変数 '{0}' が含まれます。これは、ECMAScript 6 以上でのみサポートされています。",
        "The current host does not support the '{0}' option.": "現在のホストは '{0}' オプションをサポートしていません。",
        "Cannot find the common subdirectory path for the input files.": "入力ファイルの共通サブディレクトリ パスが見つかりません。",
        "Cannot read file '{0}': {1}": "ファイル '{0}' を読み取れません: {1}",
        "Unsupported file encoding.": "サポートされていないファイルのエンコードです。",
        "Failed to parse file '{0}': {1}.": "ファイル '{0}' を解析できませんでした。{1}。",
        "Unknown compiler option '{0}'.": "コンパイラ オプション '{0}' が不明です。",
        "Compiler option '{0}' requires a value of type {1}.": "コンパイラ オプション '{0}' には {1} の型の値が必要です。",
        "Could not write file '{0}': {1}": "ファイル '{0}' に書き込めませんでした: {1}",
        "Option 'mapRoot' cannot be specified without specifying 'sourceMap' option.": "'sourceMap' オプションを指定せずにオプション 'mapRoot' を指定することはできません。",
        "Option 'sourceRoot' cannot be specified without specifying 'sourceMap' option.": "'sourceMap' オプションを指定せずにオプション 'sourceRoot' を指定することはできません。",
        "Option 'noEmit' cannot be specified with option 'out' or 'outDir'.": "オプション 'noEmit' をオプション 'out' または 'outDir' と一緒に指定することはできません。",
        "Option 'noEmit' cannot be specified with option 'declaration'.": "オプション 'noEmit' をオプション 'declaration' と一緒に指定することはできません。",
        "Option 'project' cannot be mixed with source files on a command line.": "オプション 'project' をコマンド ライン上でソース ファイルと一緒に指定することはできません。",
        "Option 'declaration' cannot be specified with option 'isolatedModules'.": "オプション 'declaration' をオプション 'isolatedModules' と一緒に指定することはできません。",
        "Option 'noEmitOnError' cannot be specified with option 'isolatedModules'.": "オプション 'noEmitOnError' をオプション 'isolatedModules' と一緒に指定することはできません。",
        "Option 'out' cannot be specified with option 'isolatedModules'.": "オプション 'out' をオプション 'isolatedModules' と一緒に指定することはできません。",
        "Option 'isolatedModules' can only be used when either option'--module' is provided or option 'target' is 'ES6' or higher.": "オプション 'isolatedModules' を使用できるのは、オプション '--module' を指定した場合、またはオプション 'target' が 'ES6' 以降の場合のみです。",
        "Option 'sourceMap' cannot be specified with option 'inlineSourceMap'.": "オプション 'sourceMap' をオプション 'inlineSourceMap' と一緒に指定することはできません。",
        "Option 'sourceRoot' cannot be specified with option 'inlineSourceMap'.": "オプション 'sourceRoot' をオプション 'inlineSourceMap' と一緒に指定することはできません。",
        "Option 'mapRoot' cannot be specified with option 'inlineSourceMap'.": "オプション 'mapRoot' をオプション 'inlineSourceMap' と一緒に指定することはできません。",
        "Option 'inlineSources' can only be used when either option '--inlineSourceMap' or option '--sourceMap' is provided.": "オプション 'inlineSources' を使用できるのは、オプション '--inlineSourceMap' またはオプション '--sourceMap' のいずれかを指定した場合のみです。",
        "Concatenate and emit output to single file.": "出力を連結して 1 つのファイルを生成します。",
        "Generates corresponding '.d.ts' file.": "対応する '.d.ts' ファイルを生成します。",
        "Specifies the location where debugger should locate map files instead of generated locations.": "生成された場所ではなくデバッガーがマップ ファイルを探す場所を指定します。",
        "Specifies the location where debugger should locate TypeScript files instead of source locations.": "ソースの場所ではなくデバッガーが TypeScript ファイルを探す必要がある場所を指定します。",
        "Watch input files.": "入力ファイルを監視します。",
        "Redirect output structure to the directory.": "ディレクトリへ出力構造をリダイレクトします。",
        "Do not erase const enum declarations in generated code.": "生成されたコード内で const enum 宣言を消去しないでください。",
        "Do not emit outputs if any errors were reported.": "エラーが報告される場合は、出力しないでください。",
        "Do not emit comments to output.": "コメントを出力しません。",
        "Do not emit outputs.": "出力しないでください。",
        "Specify ECMAScript target version: 'ES3' (default), 'ES5', or 'ES6' (experimental)": "ECMAScript のターゲット バージョンを指定してください: 'ES3' (既定値)、 'ES5'、または 'ES6' (試験段階)",
        "Specify module code generation: 'commonjs', 'amd', 'system' or 'umd'": "モジュール コード生成を指定します: 'commonjs'、'amd'、'system'、または 'umd'",
        "Print this message.": "このメッセージを表示します。",
        "Print the compiler's version.": "コンパイラのバージョンを表示します。",
        "Compile the project in the given directory.": "指定されたディレクトリでプロジェクトをコンパイルします。",
        "Syntax: {0}": "構文: {0}",
        "options": "オプション",
        "file1": "ファイル",
        "Examples: {0}": "例: {0}",
        "Options:": "オプション:",
        "Version {0}": "バージョン {0}",
        "Insert command line options and files from a file.": "コマンド ライン オプションとファイルをファイルから挿入します。",
        "File change detected. Starting incremental compilation...": "ファイルの変更が検出されました。インクリメンタル コンパイルを開始しています...",
        "KIND": "種類",
        "file2": "ファイル",
        "VERSION": "バージョン",
        "LOCATION": "位置",
        "DIRECTORY": "ディレクトリ",
        "Compilation complete. Watching for file changes.": "コンパイルが完了しました。ファイルの変更を監視しています。",
        "Generates corresponding '.map' file.": "対応する '.map' ファイルを生成します。",
        "Compiler option '{0}' expects an argument.": "コンパイラ オプション '{0}' には引数が必要です。",
        "Unterminated quoted string in response file '{0}'.": "応答ファイル '{0}' の文字列の終了引用符がありません。",
        "Argument for '--module' option must be 'commonjs', 'amd', 'system' or 'umd'.": "'--module' オプションの引数は、'commonjs'、'amd'、'system'、または 'umd' である必要があります。",
        "Argument for '--target' option must be 'ES3', 'ES5', or 'ES6'.": "'--target' オプションの引数は 'es3'、'es5'、または 'es6' でなければなりません。",
        "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.": "ロケールは <language> または <language>-<territory> の形式で指定する必要があります (例: '{0}'、'{1}')。",
        "Unsupported locale '{0}'.": "ロケール '{0}' はサポートされていません。",
        "Unable to open file '{0}'.": "ファイル '{0}' を開くことができません。",
        "Corrupted locale file {0}.": "ロケール ファイル {0} は破損しています。",
        "Raise error on expressions and declarations with an implied 'any' type.": "暗黙的な 'any' 型を含む式と宣言に関するエラーを発生させます。",
        "File '{0}' not found.": "ファイル '{0}' が見つかりません。",
        "File '{0}' has unsupported extension. The only supported extensions are {1}.": "ファイル '{0}' はサポートされていない拡張子を含んでいます。サポートされている拡張子は {1} のみです。",
        "Suppress noImplicitAny errors for indexing objects lacking index signatures.": "インデックス シグニチャのないオブジェクトにインデックスを作成するため、noImplicitAny エラーを抑制します。",
        "Do not emit declarations for code that has an '@internal' annotation.": "'@internal' の注釈を含むコードの宣言を生成しないでください。",
        "Specifies the root directory of input files. Use to control the output directory structure with --outDir.": "入力ファイルのルート ディレクトリを指定します。--outDir と一緒に出力ディレクトリ構造を制御するために使用します。",
        "File '{0}' is not under 'rootDir' '{1}'. 'rootDir' is expected to contain all source files.": "ファイル '{0}' が 'rootDir' '{1}' の下にありません。'rootDir' にすべてにソース ファイルが含まれている必要があります。",
        "Specifies the end of line sequence to be used when emitting files: 'CRLF' (dos) or 'LF' (unix).": "ファイルの作成時に使用される行末シーケンス ('CRLF' (DOS) または 'LF' (UNIX)) を指定します。",
        "NEWLINE": "改行",
        "Argument for '--newLine' option must be 'CRLF' or 'LF'.": "'--newLine' オプションの引数は、'CRLF' または 'LF' である必要があります。",
        "Specify JSX code generation: 'preserve' or 'react'": "JSX コード生成を 'preserve' または 'react' に指定します",
        "Argument for '--jsx' must be 'preserve' or 'react'.": "'--jsx' の引数は 'preserve' か 'react' である必要があります。",
        "Option 'experimentalDecorators' must also be specified when option 'emitDecoratorMetadata' is specified.": "オプション 'emitDecoratorMetadata' を指定するときは、オプション 'experimentalDecorators' も指定する必要があります。",
        "Enables experimental support for ES7 decorators.": "ES7 デコレータ用の実験的なサポートを有効にします。",
        "Enables experimental support for emitting type metadata for decorators.": "デコレータ用の型メタデータを発行するための実験的なサポートを有効にします。",
        "Option 'experimentalAsyncFunctions' cannot be specified when targeting ES5 or lower.": "ES5 以下をターゲットにする場合、オプション 'experimentalAsyncFunctions' は指定できません。",
        "Enables experimental support for ES7 async functions.": "ES7 非同期関数用の実験的なサポートを有効にします。",
        "Variable '{0}' implicitly has an '{1}' type.": "変数 '{0}' の型は暗黙的に '{1}' になります。",
        "Parameter '{0}' implicitly has an '{1}' type.": "パラメーター '{0}' の型は暗黙的に '{1}' になります。",
        "Member '{0}' implicitly has an '{1}' type.": "メンバー '{0}' の型は暗黙的に '{1}' になります。",
        "'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.": "ターゲットにコンストラクト シグネチャがない 'new' 式の型は、暗黙的に 'any' になります。",
        "'{0}', which lacks return-type annotation, implicitly has an '{1}' return type.": "'{0}' には戻り値の型の注釈がないため、戻り値の型は暗黙的に '{1}' になります。",
        "Function expression, which lacks return-type annotation, implicitly has an '{0}' return type.": "戻り値の型の注釈がない関数式の戻り値の型は、暗黙的に '{0}' になります。",
        "Construct signature, which lacks return-type annotation, implicitly has an 'any' return type.": "戻り値の型の注釈がないコンストラト シグネチャの戻り値の型は、暗黙的に 'any' になります。",
        "Property '{0}' implicitly has type 'any', because its 'set' accessor lacks a type annotation.": "'set' アクセサーに型の注釈がないため、プロパティの型 '{0}' は暗黙的に 'any' になります。",
        "Index signature of object type implicitly has an 'any' type.": "オブジェクト型のインデックス シグネチャは暗黙的に 'any' 型になります。",
        "Object literal's property '{0}' implicitly has an '{1}' type.": "オブジェクト リテラルのプロパティ '{0}' の型は暗黙的に '{1}' になります。",
        "Rest parameter '{0}' implicitly has an 'any[]' type.": "Rest パラメーター '{0}' の型は暗黙的に 'any[]' になります。",
        "Call signature, which lacks return-type annotation, implicitly has an 'any' return type.": "戻り値の型の注釈がない呼び出しシグネチャの戻り値の型は、暗黙的に 'any' になります。",
        "'{0}' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.": "'{0}' には型の注釈がなく、直接または間接的に初期化子で参照されているため、暗黙的に 'any' 型が含まれています。",
        "'{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.": "'{0}' は、戻り値の型の注釈がなく、いずれかの return 式で直接的にまたは間接的に参照されているため、戻り値の型は暗黙的に 'any' になります。",
        "Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.": "関数は、戻り値の型の注釈がなく、いずれかの return 式で直接的にまたは間接的に参照されているため、戻り値の型は暗黙的に 'any' になります。",
        "Generator implicitly has type '{0}' because it does not yield any values. Consider supplying a return type.": "ジェネレーターは値を生成しないため、暗黙的に型 '{0}' になります。戻り値の型を指定することを検討してください。",
        "JSX element implicitly has type 'any' because no interface 'JSX.{0}' exists": "インターフェイス 'JSX.{0}' が存在しないため、JSX 要素は暗黙的に型 'any' になります。",
        "You cannot rename this element.": "この要素の名前を変更することはできません。",
        "You cannot rename elements that are defined in the standard TypeScript library.": "標準の TypeScript ライブラリで定義された要素の名前を変更することはできません。",
        "'import ... =' can only be used in a .ts file.": "'import ... =' を使用できるのは .ts ファイル内のみです。",
        "'export=' can only be used in a .ts file.": "'export=' を使用できるのは .ts ファイル内のみです。",
        "'type parameter declarations' can only be used in a .ts file.": "'型パラメーター宣言' を使用できるのは .ts ファイル内のみです。",
        "'implements clauses' can only be used in a .ts file.": "'implements 句' を使用できるのは .ts ファイル内のみです。",
        "'interface declarations' can only be used in a .ts file.": "'インターフェイス宣言' を使用できるのは .ts ファイル内のみです。",
        "'module declarations' can only be used in a .ts file.": "'モジュール宣言' を使用できるのは .ts ファイル内のみです。",
        "'type aliases' can only be used in a .ts file.": "'型のエイリアス' を使用できるのは .ts ファイル内のみです。",
        "'{0}' can only be used in a .ts file.": "'{0}' を使用できるのは .ts ファイル内のみです。",
        "'types' can only be used in a .ts file.": "'型' を使用できるのは .ts ファイル内のみです。",
        "'type arguments' can only be used in a .ts file.": "'型引数' を使用できるのは .ts ファイル内のみです。",
        "'parameter modifiers' can only be used in a .ts file.": "'パラメーター修飾子' を使用できるのは .ts ファイル内のみです。",
        "'property declarations' can only be used in a .ts file.": "'プロパティ宣言' を使用できるのは.ts ファイル内のみです。",
        "'enum declarations' can only be used in a .ts file.": "'enum 宣言' を使用できるのは .ts ファイル内のみです。",
        "'type assertion expressions' can only be used in a .ts file.": "'型アサーション式' を使用できるのは、.ts ファイル内のみです。",
        "'decorators' can only be used in a .ts file.": "'decorators' を使用できるのは .ts ファイル内のみです。",
        "Only identifiers/qualified-names with optional type arguments are currently supported in a class 'extends' clauses.": "クラス 'extends' 句で現在サポートされているのは、オプションの型パラメーターが指定された ID/完全修飾名のみです。",
        "'class' expressions are not currently supported.": "'class' 式は現在サポートされていません。",
        "JSX attributes must only be assigned a non-empty 'expression'.": "JSX 属性は、空ではない '式' にのみ割り当てる必要があります。",
        "JSX elements cannot have multiple attributes with the same name.": "JSX 要素に同じ名前の複数の属性を指定することはできません。",
        "Expected corresponding JSX closing tag for '{0}'.": "'{0}' の対応する JSX 終了タグが必要です。",
        "JSX attribute expected.": "JSX 属性が必要です。",
        "Cannot use JSX unless the '--jsx' flag is provided.": "'--jsx' フラグが指定されていないと、JSX を使用できません。",
        "A constructor cannot contain a 'super' call when its class extends 'null'": "コンストラクターのクラスが 'null' を拡張する場合、そのコンストラクターに 'super' の呼び出しを含めることはできません。"
}