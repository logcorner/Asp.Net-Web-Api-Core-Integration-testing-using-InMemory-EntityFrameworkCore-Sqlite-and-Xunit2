{
        "Unterminated string literal.": "종결되지 않은 문자열 리터럴입니다.",
        "Identifier expected.": "식별자가 필요합니다.",
        "'{0}' expected.": "'{0}'이(가) 필요합니다.",
        "A file cannot have a reference to itself.": "파일은 자신에 대한 참조를 포함할 수 없습니다.",
        "Trailing comma not allowed.": "후행 쉼표는 허용되지 않습니다.",
        "'*/' expected.": "'*/'가 필요합니다.",
        "Unexpected token.": "예기치 않은 토큰입니다.",
        "A rest parameter must be last in a parameter list.": "rest 매개 변수는 매개 변수 목록 마지막에 있어야 합니다.",
        "Parameter cannot have question mark and initializer.": "매개 변수에 물음표와 이니셜라이저를 사용할 수 없습니다.",
        "A required parameter cannot follow an optional parameter.": "필수 매개 변수는 선택적 매개 변수 뒤에 올 수 없습니다.",
        "An index signature cannot have a rest parameter.": "인덱스 시그니처에는 rest 매개 변수를 사용할 수 없습니다.",
        "An index signature parameter cannot have an accessibility modifier.": "인덱스 시그니처 매개 변수에는 액세스 가능성 한정자를 사용할 수 없습니다.",
        "An index signature parameter cannot have a question mark.": "인덱스 시그니처 매개 변수에는 물음표를 사용할 수 없습니다.",
        "An index signature parameter cannot have an initializer.": "인덱스 시그니처 매개 변수에는 이니셜라이저를 사용할 수 없습니다.",
        "An index signature must have a type annotation.": "인덱스 시그니처에는 형식 주석을 사용할 수 없습니다.",
        "An index signature parameter must have a type annotation.": "인덱스 시그니처 매개 변수에는 형식 주석을 사용할 수 없습니다.",
        "An index signature parameter type must be 'string' or 'number'.": "인덱스 시그니처 매개 변수 형식은 'string' 또는 'number'여야 합니다.",
        "Accessibility modifier already seen.": "액세스 가능성 한정자가 이미 있습니다.",
        "'{0}' modifier must precede '{1}' modifier.": "'{0}' 한정자는 '{1}' 한정자 앞에 와야 합니다.",
        "'{0}' modifier already seen.": "'{0}' 한정자가 이미 있습니다.",
        "'{0}' modifier cannot appear on a class element.": "'{0}' 한정자는 클래스 요소에 나타날 수 없습니다.",
        "'super' must be followed by an argument list or member access.": "'super' 다음에는 인수 목록 또는 멤버 액세스가 와야 합니다.",
        "Only ambient modules can use quoted names.": "앰비언트 모듈만 따옴표가 붙은 이름을 사용할 수 있습니다.",
        "Statements are not allowed in ambient contexts.": "앰비언트 컨텍스트에서는 문이 허용되지 않습니다.",
        "A 'declare' modifier cannot be used in an already ambient context.": "'declare' 한정자는 이미 존재하는 앰비언트 컨텍스트에서 사용할 수 없습니다.",
        "Initializers are not allowed in ambient contexts.": "앰비언트 컨텍스트에서는 이니셜라이저가 허용되지 않습니다.",
        "'{0}' modifier cannot be used in an ambient context.": "'{0}' 한정자는 앰비언트 컨텍스트에서 사용할 수 없습니다.",
        "'{0}' modifier cannot be used with a class declaration.": "'{0}' 한정자는 클래스 선언에서 사용할 수 없습니다.",
        "'{0}' modifier cannot be used here.": "'{0}' 한정자는 여기에 사용할 수 없습니다.",
        "'{0}' modifier cannot appear on a data property.": "'{0}' 한정자는 데이터 속성에 나타날 수 없습니다.",
        "'{0}' modifier cannot appear on a module element.": "'{0}' 한정자는 모듈 요소에 나타날 수 없습니다.",
        "A '{0}' modifier cannot be used with an interface declaration.": "'{0}' 한정자는 인터페이스 선언에서 사용할 수 없습니다.",
        "A 'declare' modifier is required for a top level declaration in a .d.ts file.": "'declare' 한정자는 .d.ts 파일의 최상위 선언에 필요합니다.",
        "A rest parameter cannot be optional.": "rest 매개 변수는 선택 사항이 될 수 없습니다.",
        "A rest parameter cannot have an initializer.": "rest 매개 변수에는 이니셜라이저를 사용할 수 없습니다.",
        "A 'set' accessor must have exactly one parameter.": "'set' 접근자에는 매개 변수를 하나만 사용해야 합니다.",
        "A 'set' accessor cannot have an optional parameter.": "'set' 접근자에는 선택적 매개 변수를 사용할 수 없습니다.",
        "A 'set' accessor parameter cannot have an initializer.": "'set' 접근자 매개 변수에는 이니셜라이저를 사용할 수 없습니다.",
        "A 'set' accessor cannot have rest parameter.": "'set' 접근자에는 rest 매개 변수를 사용할 수 없습니다.",
        "A 'get' accessor cannot have parameters.": "'get' 접근자에는 매개 변수를 사용할 수 없습니다.",
        "Type '{0}' is not a valid async function return type.": "'{0}' 형식은 유효한 비동기 함수 반환 형식이 아닙니다.",
        "Accessors are only available when targeting ECMAScript 5 and higher.": "접근자는 ECMAScript 5 이상을 대상으로 지정할 때만 사용할 수 있습니다.",
        "An async function or method must have a valid awaitable return type.": "비동기 함수 또는 메서드에는 유효한 대기 가능 반환 형식이 있어야 합니다.",
        "Operand for 'await' does not have a valid callable 'then' member.": "'await'에 대한 피연산자에 유효한 호출 가능 'then' 멤버가 없습니다.",
        "Return expression in async function does not have a valid callable 'then' member.": "비동기 함수의 반환 식에 유효한 호출 가능 'then' 멤버가 없습니다.",
        "Expression body for async arrow function does not have a valid callable 'then' member.": "비동기 화살표 함수의 식 본문에 유효한 호출 가능 'then' 멤버가 없습니다.",
        "Enum member must have initializer.": "열거형 멤버에는 이니셜라이저가 있어야 합니다.",
        "{0} is referenced directly or indirectly in the fulfillment callback of its own 'then' method.": "{0}은(는) 자체 'then' 메서드의 처리 콜백에서 직간접적으로 참조됩니다.",
        "An export assignment cannot be used in a namespace.": "내보내기 할당은 네임스페이스에서 사용될 수 없습니다.",
        "Ambient enum elements can only have integer literal initializers.": "앰비언트 열거형 요소에는 정수 리터럴 이니셜라이저만 사용할 수 있습니다.",
        "Unexpected token. A constructor, method, accessor, or property was expected.": "예기치 않은 토큰입니다. 생성자, 메서드, 접근자 또는 속성이 필요합니다.",
        "A '{0}' modifier cannot be used with an import declaration.": "'{0}' 한정자는 가져오기 선언에서 사용할 수 없습니다.",
        "Invalid 'reference' directive syntax.": "'reference' 지시문 구문이 잘못되었습니다.",
        "Octal literals are not available when targeting ECMAScript 5 and higher.": "ECMAScript 5 이상을 대상으로 지정할 때는 8진수 리터럴을 사용할 수 없습니다.",
        "An accessor cannot be declared in an ambient context.": "접근자는 앰비언트 컨텍스트에서 선언될 수 없습니다.",
        "'{0}' modifier cannot appear on a constructor declaration.": "'{0}' 한정자는 생성자 선언에 나타날 수 없습니다.",
        "'{0}' modifier cannot appear on a parameter.": "{0}' 한정자는 매개 변수에 표시될 수 없습니다.",
        "Only a single variable declaration is allowed in a 'for...in' statement.": "'for...in' 문에는 단일 변수 선언만 허용됩니다.",
        "Type parameters cannot appear on a constructor declaration.": "형식 매개 변수는 생성자 선언에 표시될 수 없습니다.",
        "Type annotation cannot appear on a constructor declaration.": "형식 주석은 생성자 선언에 표시될 수 없습니다.",
        "An accessor cannot have type parameters.": "접근자에는 형식 매개 변수를 사용할 수 없습니다.",
        "A 'set' accessor cannot have a return type annotation.": "'set' 접근자에는 반환 형식 주석을 사용할 수 없습니다.",
        "An index signature must have exactly one parameter.": "인덱스 시그니처에는 한 개의 매개 변수만 사용할 수 있습니다.",
        "'{0}' list cannot be empty.": "'{0}' 목록은 비워 둘 수 없습니다.",
        "Type parameter list cannot be empty.": "형식 매개 변수 목록은 비워 둘 수 없습니다.",
        "Type argument list cannot be empty.": "형식 인수 목록은 비워 둘 수 없습니다.",
        "Invalid use of '{0}' in strict mode.": "strict 모드에서 '{0}'을(를) 잘못 사용했습니다.",
        "'with' statements are not allowed in strict mode.": "'with' 문은 strict 모드에서 사용할 수 없습니다.",
        "'delete' cannot be called on an identifier in strict mode.": "strict 모드에서는 식별자에 대해 'delete'를 호출할 수 없습니다.",
        "A 'continue' statement can only be used within an enclosing iteration statement.": "'continue' 문은 이 문을 둘러싼 반복 문 내에서만 사용할 수 있습니다.",
        "A 'break' statement can only be used within an enclosing iteration or switch statement.": "'break' 문은 이 문을 둘러싼 반복 문 또는 switch 문 내에서만 사용할 수 있습니다.",
        "Jump target cannot cross function boundary.": "점프 대상은 함수 경계를 벗어날 수 없습니다.",
        "A 'return' statement can only be used within a function body.": "'return' 문은 함수 본문 내에서만 사용할 수 있습니다.",
        "Expression expected.": "식이 필요합니다.",
        "Type expected.": "형식이 필요합니다.",
        "A class member cannot be declared optional.": "클래스 멤버는 선택적으로 선언될 수 없습니다.",
        "A 'default' clause cannot appear more than once in a 'switch' statement.": "'default' 절은 'switch' 문에 두 번 이상 나올 수 없습니다.",
        "Duplicate label '{0}'": "중복된 레이블 '{0}'",
        "A 'continue' statement can only jump to a label of an enclosing iteration statement.": "'continue' 문은 이 문을 둘러싼 문의 레이블로만 이동할 수 있습니다.",
        "A 'break' statement can only jump to a label of an enclosing statement.": "'break' 문은 이 문을 둘러싼 문의 레이블로만 이동할 수 있습니다.",
        "An object literal cannot have multiple properties with the same name in strict mode.": "strict 모드에서는 개체 리터럴에 이름이 같은 여러 개의 속성을 사용할 수 없습니다.",
        "An object literal cannot have multiple get/set accessors with the same name.": "개체 리터럴에 이름이 같은 여러 개의 get/set 접근자를 사용할 수 없습니다.",
        "An object literal cannot have property and accessor with the same name.": "개체 리터럴에 이름이 같은 속성과 접근자를 사용할 수 없습니다.",
        "An export assignment cannot have modifiers.": "내보내기 할당에는 한정자를 사용할 수 없습니다.",
        "Octal literals are not allowed in strict mode.": "strict 모드에서는 8진수 리터럴이 허용되지 않습니다.",
        "A tuple type element list cannot be empty.": "튜플 형식 요소 목록은 비워 둘 수 없습니다.",
        "Variable declaration list cannot be empty.": "변수 선언 목록은 비워 둘 수 없습니다.",
        "Digit expected.": "숫자가 필요합니다.",
        "Hexadecimal digit expected.": "16진수가 필요합니다.",
        "Unexpected end of text.": "예기치 않은 텍스트 끝입니다.",
        "Invalid character.": "잘못된 문자입니다.",
        "Declaration or statement expected.": "선언 또는 문이 필요합니다.",
        "Statement expected.": "문이 필요합니다.",
        "'case' or 'default' expected.": "'case' 또는 'default'가 필요합니다.",
        "Property or signature expected.": "속성 또는 시그니처가 필요합니다.",
        "Enum member expected.": "열거형 멤버가 필요합니다.",
        "Variable declaration expected.": "변수 선언이 필요합니다.",
        "Argument expression expected.": "인수 식이 필요합니다.",
        "Property assignment expected.": "속성 할당이 필요합니다.",
        "Expression or comma expected.": "식 또는 쉼표가 필요합니다.",
        "Parameter declaration expected.": "매개 변수 선언이 필요합니다.",
        "Type parameter declaration expected.": "형식 매개 변수 선언이 필요합니다.",
        "Type argument expected.": "형식 인수가 필요합니다.",
        "String literal expected.": "문자열 리터럴이 필요합니다.",
        "Line break not permitted here.": "여기서는 줄 바꿈이 허용되지 않습니다.",
        "'{' or ';' expected.": "'{' 또는 ';'이(가) 필요합니다.",
        "Modifiers not permitted on index signature members.": "인덱스 시그니처 멤버에는 한정자가 허용되지 않습니다.",
        "Declaration expected.": "선언이 필요합니다.",
        "Import declarations in a namespace cannot reference a module.": "네임스페이스의 가져오기 선언은 모듈을 참조할 수 없습니다.",
        "Cannot compile modules unless the '--module' flag is provided.": "'--module' 플래그를 제공하지 않으면 모듈을 컴파일할 수 없습니다.",
        "File name '{0}' differs from already included file name '{1}' only in casing": "'{0}' 파일 이름은 이미 포함된 '{1}' 파일 이름과 대/소문자만 다릅니다.",
        "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.": "배열을 만드는 데 'new T[]'를 사용할 수 없습니다. 대신 'new Array<T>()'를 사용하세요.",
        "'const' declarations must be initialized": "'const' 선언은 초기화해야 합니다.",
        "'const' declarations can only be declared inside a block.": "'const' 선언은 블록 내부에서만 선언할 수 있습니다.",
        "'let' declarations can only be declared inside a block.": "'let' 선언은 블록 내부에서만 선언될 수 있습니다.",
        "Unterminated template literal.": "종결되지 않은 템플릿 리터럴입니다.",
        "Unterminated regular expression literal.": "종결되지 않은 정규식 리터럴입니다.",
        "An object member cannot be declared optional.": "개체 멤버는 선택적으로 선언될 수 없습니다.",
        "A 'yield' expression is only allowed in a generator body.": "'yield' 식은 생성기 본문에서만 사용할 수 있습니다.",
        "Computed property names are not allowed in enums.": "컴퓨팅된 속성 이름은 열거형에 사용할 수 없습니다.",
        "A computed property name in an ambient context must directly refer to a built-in symbol.": "앰비언트 컨텍스트의 계산된 속성 이름은 기본 제공 기호를 직접 참조해야 합니다.",
        "A computed property name in a class property declaration must directly refer to a built-in symbol.": "클래스 속성 선언의 계산된 속성 이름은 기본 제공 기호를 직접 참조해야 합니다.",
        "A computed property name in a method overload must directly refer to a built-in symbol.": "메서드 오버로드의 계산된 속성 이름은 기본 제공 기호를 직접 참조해야 합니다.",
        "A computed property name in an interface must directly refer to a built-in symbol.": "인터페이스의 계산된 속성 이름은 기본 제공 기호를 직접 참조해야 합니다.",
        "A computed property name in a type literal must directly refer to a built-in symbol.": "형식 리터럴의 계산된 속성 이름은 기본 제공 기호를 직접 참조해야 합니다.",
        "A comma expression is not allowed in a computed property name.": "쉼표 식은 컴퓨팅된 속성 이름에 사용할 수 없습니다.",
        "'extends' clause already seen.": "'extends' 절이 이미 있습니다.",
        "'extends' clause must precede 'implements' clause.": "'extends' 절은 'implements' 절 앞에 와야 합니다.",
        "Classes can only extend a single class.": "클래스는 단일 클래스만 확장할 수 있습니다.",
        "'implements' clause already seen.": "'implements' 절이 이미 있습니다.",
        "Interface declaration cannot have 'implements' clause.": "인터페이스 선언에는 'implements' 절을 사용할 수 없습니다.",
        "Binary digit expected.": "이진수가 있어야 합니다.",
        "Octal digit expected.": "8진수가 있어야 합니다.",
        "Unexpected token. '{' expected.": "예기치 않은 토큰입니다. '{'가 있어야 합니다.",
        "Property destructuring pattern expected.": "속성 구조 파괴 패턴이 필요합니다.",
        "Array element destructuring pattern expected.": "배열 요소 구조 파괴 패턴이 필요합니다.",
        "A destructuring declaration must have an initializer.": "구조 파괴 선언에 이니셜라이저가 있어야 합니다.",
        "An implementation cannot be declared in ambient contexts.": "앰비언트 컨텍스트에서는 구현을 선언할 수 없습니다.",
        "Modifiers cannot appear here.": "한정자를 여기에 표시할 수 없습니다.",
        "Merge conflict marker encountered.": "병합 충돌 표식을 발견했습니다.",
        "A rest element cannot have an initializer.": "rest 요소에는 이니셜라이저를 사용할 수 없습니다.",
        "A parameter property may not be a binding pattern.": "매개 변수 속성에 바인딩 패턴을 사용할 수 없습니다.",
        "Only a single variable declaration is allowed in a 'for...of' statement.": "'for...of' 문에는 단일 변수 선언만 허용됩니다.",
        "The variable declaration of a 'for...in' statement cannot have an initializer.": "'for...in' 문의 변수 선언에 이니셜라이저가 포함될 수 없습니다.",
        "The variable declaration of a 'for...of' statement cannot have an initializer.": "'for...of' 문의 변수 선언에 이니셜라이저가 포함될 수 없습니다.",
        "An import declaration cannot have modifiers.": "가져오기 선언에는 한정자를 사용할 수 없습니다.",
        "Module '{0}' has no default export.": "모듈 '{0}'에는 기본 내보내기가 없습니다.",
        "An export declaration cannot have modifiers.": "내보내기 선언에는 한정자를 사용할 수 없습니다.",
        "Export declarations are not permitted in a namespace.": "네임스페이스에서는 내보내기 선언이 허용되지 않습니다.",
        "Catch clause variable name must be an identifier.": "Catch 절 변수 이름은 식별자여야 합니다.",
        "Catch clause variable cannot have a type annotation.": "Catch 절 변수에 형식 주석을 사용할 수 없습니다.",
        "Catch clause variable cannot have an initializer.": "Catch 절 변수에 이니셜라이저를 사용할 수 없습니다.",
        "An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.": "확장된 유니코드 이스케이프 값은 0x0과 0x10FFFF(포함) 사이여야 합니다.",
        "Unterminated Unicode escape sequence.": "종결되지 않은 유니코드 이스케이프 시퀀스입니다.",
        "Line terminator not permitted before arrow.": "줄 마침 표시는 화살표 앞에 사용할 수 없습니다.",
        "Import assignment cannot be used when targeting ECMAScript 6 or higher. Consider using 'import * as ns from \"mod\"', 'import {a} from \"mod\"' or 'import d from \"mod\"' instead.": "ECMAScript 6 이상을 대상으로 지정하는 경우 가져오기 할당을 사용할 수 없습니다. 'import * as ns from \"mod\"', 'import {a} from \"mod\"' 또는 'import d from \"mod\"'를 대신 사용하세요.",
        "Export assignment cannot be used when targeting ECMAScript 6 or higher. Consider using 'export default' instead.": "ECMAScript 6 이상을 대상으로 지정할 경우 내보내기 할당을 사용할 수 없습니다. 대신 'export default'를 사용하세요.",
        "Cannot compile modules into 'commonjs', 'amd', 'system' or 'umd' when targeting 'ES6' or higher.": "'ES6' 이상을 대상으로 지정할 때 모듈을 'commonjs', 'amd', 'system' 또는 'umd'로 컴파일할 수 없습니다.",
        "Decorators are only available when targeting ECMAScript 5 and higher.": "데코레이터는 ECMAScript 5 이상을 대상으로 할 때만 사용할 수 있습니다.",
        "Decorators are not valid here.": "데코레이터는 여기에 사용할 수 없습니다.",
        "Decorators cannot be applied to multiple get/set accessors of the same name.": "동일한 이름의 여러 get/set 접근자에 데코레이터를 적용할 수 없습니다.",
        "Cannot compile namespaces when the '--isolatedModules' flag is provided.": "'--isolatedModules' 플래그가 제공된 경우 네임스페이스를 컴파일할 수 없습니다.",
        "Ambient const enums are not allowed when the '--isolatedModules' flag is provided.": "'--isolatedModules' 플래그가 제공된 경우 앰비언트 const 열거형이 허용되지 않습니다.",
        "Invalid use of '{0}'. Class definitions are automatically in strict mode.": "'{0}'을(를) 잘못 사용했습니다. 클래스 정의는 자동으로 strict 모드가 됩니다.",
        "A class declaration without the 'default' modifier must have a name": "'default' 한정자를 사용하지 않는 클래스 선언에는 이름이 있어야 합니다.",
        "Identifier expected. '{0}' is a reserved word in strict mode": "식별자가 필요합니다. '{0}'은(는) strict 모드의 예약어입니다.",
        "Identifier expected. '{0}' is a reserved word in strict mode. Class definitions are automatically in strict mode.": "식별자가 필요합니다. '{0}'은(는) strict 모드의 예약어입니다. 클래스 정의는 자동으로 strict 모드가 됩니다.",
        "Identifier expected. '{0}' is a reserved word in strict mode. Modules are automatically in strict mode.": "식별자가 필요합니다. '{0}'은(는) strict 모드의 예약어입니다. 모듈은 자동으로 strict 모드가 됩니다.",
        "Invalid use of '{0}'. Modules are automatically in strict mode.": "'{0}'을(를) 잘못 사용했습니다. 모듈은 자동으로 strict 모드가 됩니다.",
        "Export assignment is not supported when '--module' flag is 'system'.": "'--module' 플래그가 'system'이면 내보내기 할당은 지원되지 않습니다.",
        "Experimental support for decorators is a feature that is subject to change in a future release. Specify '--experimentalDecorators' to remove this warning.": "데코레이터에 대한 실험적 지원 기능은 이후 릴리스에서 변경될 수 있습니다. 이 경고를 제거하려면 '--experimentalDecorators'를 지정하세요.",
        "Generators are only available when targeting ECMAScript 6 or higher.": "생성기는 ECMAScript 6 이상을 대상으로 할 때만 사용할 수 있습니다.",
        "Generators are not allowed in an ambient context.": "생성기는 앰비언트 컨텍스트에서 사용할 수 없습니다.",
        "An overload signature cannot be declared as a generator.": "오버로드 서명은 생성기로 선언할 수 없습니다.",
        "'{0}' tag already specified.": "'{0}' 태그가 이미 지정되었습니다.",
        "Signature '{0}' must have a type predicate.": "'{0}' 서명에는 형식 조건자가 있어야 합니다.",
        "Cannot find parameter '{0}'.": "'{0}' 매개 변수를 찾을 수 없습니다.",
        "Type predicate '{0}' is not assignable to '{1}'.": "형식 조건자 '{0}'을(를) '{1}'에 할당할 수 없습니다.",
        "Parameter '{0}' is not in the same position as parameter '{1}'.": "'{0}' 매개 변수는 '{1}' 매개 변수와 같은 위치에 있지 않습니다.",
        "A type predicate is only allowed in return type position for functions and methods.": "형식 조건자는 함수 및 메서드의 반환 형식 위치에서만 사용할 수 있습니다.",
        "A type predicate cannot reference a rest parameter.": "형식 조건자는 rest 매개 변수를 참조할 수 없습니다.",
        "A type predicate cannot reference element '{0}' in a binding pattern.": "형식 조건자는 바인딩 패턴에서 '{0}' 요소를 참조할 수 없습니다.",
        "An export assignment can only be used in a module.": "내보내기 할당은 모듈에서만 사용할 수 있습니다.",
        "An import declaration can only be used in a namespace or module.": "내보내기 선언은 네임스페이스 또는 모듈에서만 사용할 수 있습니다.",
        "An export declaration can only be used in a module.": "내보내기 선언은 모듈에서만 사용할 수 있습니다.",
        "An ambient module declaration is only allowed at the top level in a file.": "앰비언트 모듈 선언은 파일의 최상위에서만 사용할 수 있습니다.",
        "A namespace declaration is only allowed in a namespace or module.": "네임스페이스 선언은 네임스페이스 또는 모듈에서만 사용할 수 있습니다.",
        "Experimental support for async functions is a feature that is subject to change in a future release. Specify '--experimentalAsyncFunctions' to remove this warning.": "비동기 함수에 대한 실험적 지원은 이후 릴리스에서 변경될 수 있습니다. 이 경고를 제거하려면 '--experimentalAsyncFunctions'를 지정하세요.",
        "'with' statements are not allowed in an async function block.": "'with' 문은 비동기 함수 블록에서 사용할 수 없습니다.",
        "'await' expression is only allowed within an async function.": "'await' 식은 비동기 함수 내에서만 사용할 수 있습니다.",
        "Async functions are only available when targeting ECMAScript 6 and higher.": "비동기 함수는 ECMAScript 6 이상을 대상으로 할 때만 사용할 수 있습니다.",
        "The return type of a property decorator function must be either 'void' or 'any'.": "속성 데코레이터 함수의 반환 형식은 'void' 또는 'any'여야 합니다.",
        "The return type of a parameter decorator function must be either 'void' or 'any'.": "매개 변수 데코레이터 함수의 반환 형식은 'void' 또는 'any'여야 합니다.",
        "Unable to resolve signature of class decorator when called as an expression.": "식으로 호출된 경우 클래스 데코레이터의 서명을 확인할 수 없습니다.",
        "Unable to resolve signature of parameter decorator when called as an expression.": "식으로 호출된 경우 매개 변수 데코레이터의 서명을 확인할 수 없습니다.",
        "Unable to resolve signature of property decorator when called as an expression.": "식으로 호출된 경우 속성 데코레이터의 서명을 확인할 수 없습니다.",
        "Unable to resolve signature of method decorator when called as an expression.": "식으로 호출된 경우 메서드 데코레이터의 서명을 확인할 수 없습니다.",
        "'abstract' modifier can only appear on a class or method declaration.": "'abstract' 한정자는 클래스 또는 메서드 선언에만 사용할 수 있습니다.",
        "'{0}' modifier cannot be used with '{1}' modifier.": "'{0}' 한정자는 '{1}' 한정자와 함께 사용할 수 없습니다.",
        "Abstract methods can only appear within an abstract class.": "추상 메서드는 추상 클래스 내에서만 사용할 수 있습니다.",
        "Method '{0}' cannot have an implementation because it is marked abstract.": "'{0}' 메서드는 abstract로 표시되어 있으므로 구현이 있을 수 없습니다.",
        "Duplicate identifier '{0}'.": "'{0}' 식별자가 중복되었습니다.",
        "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.": "인스턴스 멤버 변수 '{0}'의 이니셜라이저는 생성자에 선언된 식별자 '{1}'을(를) 참조할 수 없습니다.",
        "Static members cannot reference class type parameters.": "정적 멤버는 클래스 형식 매개 변수를 참조할 수 없습니다.",
        "Circular definition of import alias '{0}'.": "가져오기 별칭 '{0}'의 순환 정의입니다.",
        "Cannot find name '{0}'.": "'{0}' 이름을 찾을 수 없습니다.",
        "Module '{0}' has no exported member '{1}'.": "'{0}' 모듈에 내보낸 멤버 '{1}'이(가) 없습니다.",
        "File '{0}' is not a module.": "'{0}' 파일은 모듈이 아닙니다.",
        "Cannot find module '{0}'.": "'{0}' 모듈을 찾을 수 없습니다.",
        "An export assignment cannot be used in a module with other exported elements.": "내보내기 할당은 다른 내보낸 요소가 있는 모듈에서 사용될 수 없습니다.",
        "Type '{0}' recursively references itself as a base type.": "Type '{0}' 형식은 자기 자신을 기본 형식으로 재귀적으로 참조합니다.",
        "A class may only extend another class.": "클래스는 다른 클래스만 확장할 수 있습니다.",
        "An interface may only extend a class or another interface.": "인터페이스는 클래스 또는 다른 인터페이스만 확장할 수 있습니다.",
        "Constraint of a type parameter cannot reference any type parameter from the same type parameter list.": "형식 매개 변수의 제약 조건은 동일 형식의 매개 변수 목록에서 형식 매개 변수를 참조할 수 없습니다.",
        "Generic type '{0}' requires {1} type argument(s).": "'{0}' 제네릭 형식에 {1} 형식 인수가 필요합니다.",
        "Type '{0}' is not generic.": "'{0}' 형식이 제네릭이 아닙니다.",
        "Global type '{0}' must be a class or interface type.": "전역 형식 '{0}'은 클래스 또는 인터페이스 형식이어야 합니다.",
        "Global type '{0}' must have {1} type parameter(s).": "전역 형식 '{0}'에는 {1} 형식 매개 변수를 사용해야 합니다.",
        "Cannot find global type '{0}'.": "전역 형식 '{0}'을(를) 찾을 수 없습니다.",
        "Named property '{0}' of types '{1}' and '{2}' are not identical.": "명명된 속성 '{0}'의 형식 '{1}' 및 '{2}'이(가) 동일하지 않습니다.",
        "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}'.": "'{0}' 인터페이스는 '{1}' 및 '{2}' 형식을 동시에 확장할 수 없습니다.",
        "Excessive stack depth comparing types '{0}' and '{1}'.": "'{0}' 및 '{1}' 형식을 비교하는 스택 깊이가 과도합니다.",
        "Type '{0}' is not assignable to type '{1}'.": "'{0}' 형식은 '{1}' 형식에 할당할 수 없습니다.",
        "Property '{0}' is missing in type '{1}'.": "'{0}' 속성이 '{1}' 형식에 없습니다.",
        "Property '{0}' is private in type '{1}' but not in type '{2}'.": "'{0}' 속성은 '{1}' 형식에서 private이지만 '{2}' 형식에서는 그렇지 않습니다.",
        "Types of property '{0}' are incompatible.": "'{0}' 속성의 형식이 호환되지 않습니다.",
        "Property '{0}' is optional in type '{1}' but required in type '{2}'.": "'{0}' 속성은 '{1}' 형식에서 선택적이지만 '{2}' 형식에서는 필수입니다.",
        "Types of parameters '{0}' and '{1}' are incompatible.": "'{0}' 및 '{1}' 매개 변수의 형식이 호환되지 않습니다.",
        "Index signature is missing in type '{0}'.": "'{0}' 형식에 인덱스 시그니처가 없습니다.",
        "Index signatures are incompatible.": "인덱스 시그니처가 호환되지 않습니다.",
        "'this' cannot be referenced in a module or namespace body.": "'this'는 모듈 또는 네임스페이스 본문에서 참조될 수 없습니다.",
        "'this' cannot be referenced in current location.": "현재 위치에서 'this'를 참조할 수 없습니다.",
        "'this' cannot be referenced in constructor arguments.": "생성자 인수에서 'this'를 참조할 수 없습니다.",
        "'this' cannot be referenced in a static property initializer.": "정적 속성 이니셜라이저에서 'this'를 참조할 수 없습니다.",
        "'super' can only be referenced in a derived class.": "파생 클래스에서만 'super'를 참조할 수 있습니다.",
        "'super' cannot be referenced in constructor arguments.": "super'는 생성자 인수에서 참조할 수 없습니다.",
        "Super calls are not permitted outside constructors or in nested functions inside constructors.": "생성자 밖이나 생성자 내부에 중첩된 함수에서는 Super 호출이 허용되지 않습니다.",
        "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.": "'super' 속성 액세스는 생성자, 멤버 함수 또는 파생 클래스의 멤버 접근자에서만 허용됩니다.",
        "Property '{0}' does not exist on type '{1}'.": "'{1}' 형식에 '{0}' 속성이 없습니다.",
        "Only public and protected methods of the base class are accessible via the 'super' keyword.": "기본 클래스의 공용 및 보호된 메서드만 'super' 키워드를 통해 액세스할 수 있습니다.",
        "Property '{0}' is private and only accessible within class '{1}'.": "'{0}' 속성은 private이며 '{1}' 클래스 내에서만 액세스할 수 있습니다.",
        "An index expression argument must be of type 'string', 'number', 'symbol, or 'any'.": "인덱스 식 인수는 'string', 'number', 'symbol' 또는 'any' 형식이어야 합니다.",
        "Type '{0}' does not satisfy the constraint '{1}'.": "'{0}' 형식이 '{1}' 제약 조건을 만족하지 않습니다.",
        "Argument of type '{0}' is not assignable to parameter of type '{1}'.": "'{0}' 형식의 인수는 '{1}' 형식의 매개 변수에 할당될 수 없습니다.",
        "Supplied parameters do not match any signature of call target.": "제공된 매개 변수가 호출 대상의 시그니처와 일치하지 않습니다.",
        "Untyped function calls may not accept type arguments.": "형식화되지 않은 함수 호출에는 형식 인수를 사용할 수 없습니다.",
        "Value of type '{0}' is not callable. Did you mean to include 'new'?": "'{0}' 형식의 값은 호출할 수 없습니다. 'new'를 포함하려고 했습니까?",
        "Cannot invoke an expression whose type lacks a call signature.": "형식에 호출 시그니처가 없는 식을 호출할 수 없습니다.",
        "Only a void function can be called with the 'new' keyword.": "void 함수만 'new' 키워드로 호출할 수 있습니다.",
        "Cannot use 'new' with an expression whose type lacks a call or construct signature.": "형식에 호출 또는 구문 시그니처가 없는 식에는 'new'를 사용할 수 없습니다.",
        "Neither type '{0}' nor type '{1}' is assignable to the other.": "'{0}' 형식과 '{1}' 형식을 서로에게 할당할 수 없습니다.",
        "Object literal may only specify known properties, and '{0}' does not exist in type '{1}'.": "개체 리터럴은 알려진 속성만 지정할 수 있으며 '{1}' 형식에 '{0}'이(가) 없습니다.",
        "No best common type exists among return expressions.": "반환 식 사이에 가장 적합한 공용 형식이 없습니다.",
        "A function whose declared type is neither 'void' nor 'any' must return a value or consist of a single 'throw' statement.": "선언된 형식이 'void' 또는 'any'가 아닌 함수는 값을 반환하거나 단일 'throw' 문으로 구성되어야 합니다.",
        "An arithmetic operand must be of type 'any', 'number' or an enum type.": "산술 피연산자는 'any', 'number' 또는 열거형 형식이어야 합니다.",
        "The operand of an increment or decrement operator must be a variable, property or indexer.": "증가 연산자 또는 감소 연산자의 피연산자는 변수, 속성 또는 인덱서여야 합니다.",
        "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.": "'instanceof' 식 왼쪽은 'any' 형식, 개체 형식 또는 형식 매개 변수여야 합니다.",
        "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.": "'instanceof' 식 오른쪽은 'any' 형식이거나 'Function' 인터페이스 형식에 할당할 수 있는 형식이어야 합니다.",
        "The left-hand side of an 'in' expression must be of type 'any', 'string', 'number', or 'symbol'.": "'in' 식의 왼쪽은 'any', 'string', 'number' 또는 'symbol' 유형이어야 합니다.",
        "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter": "'in' 식의 오른쪽은 'any' 형식, 개체 형식 또는 형식 매개 변수여야 합니다.",
        "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "산술 연산 왼쪽은 'any', 'number' 또는 열거형 형식이어야 합니다.",
        "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "산술 연산 오른쪽은 'any', 'number' 또는 열거형 형식이어야 합니다.",
        "Invalid left-hand side of assignment expression.": "할당 식 왼쪽이 잘못되었습니다.",
        "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": "'{0}' 연산자를 '{1}' 및 '{2}' 형식에 적용할 수 없습니다.",
        "Type parameter name cannot be '{0}'": "형식 매개 변수 이름은 '{0}'일 수 없습니다.",
        "A parameter property is only allowed in a constructor implementation.": "매개 변수 속성은 생성자 구현에서만 허용됩니다.",
        "A rest parameter must be of an array type.": "rest 매개 변수는 배열 형식이어야 합니다.",
        "A parameter initializer is only allowed in a function or constructor implementation.": "매개 변수 이니셜라이저는 함수 또는 생성자 구현에서만 허용됩니다.",
        "Parameter '{0}' cannot be referenced in its initializer.": "매개 변수 '{0}'은(는) 해당 이니셜라이저에서 참조할 수 없습니다.",
        "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.": "매개 변수 '{0}'의 이니셜라이저는 그 다음에 선언된 식별자 '{1}'을(를) 참조할 수 없습니다.",
        "Duplicate string index signature.": "중복 문자열 인덱스 시그니처입니다.",
        "Duplicate number index signature.": "중복 숫자 인덱스 시그니처입니다.",
        "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.": "클래스에 초기화된 속성이 있거나 매개 변수 속성이 있으면 'super' 호출이 생성자에서 첫 번째 문이어야 합니다.",
        "Constructors for derived classes must contain a 'super' call.": "파생 클래스의 생성자는 'super' 호출을 포함해야 합니다.",
        "A 'get' accessor must return a value or consist of a single 'throw' statement.": "'get' 접근자는 값을 반환하거나 단일 'throw' 문으로 구성되어야 합니다.",
        "Getter and setter accessors do not agree in visibility.": "Getter 및 Setter 접근자의 표시 유형이 다릅니다.",
        "'get' and 'set' accessor must have the same type.": "'get' 및 'set' 접근자의 형식이 같아야 합니다.",
        "A signature with an implementation cannot use a string literal type.": "구현이 있는 시그니처에는 문자열 리터럴 형식을 사용할 수 없습니다.",
        "Specialized overload signature is not assignable to any non-specialized signature.": "특수화된 오버로드 시그니처는 특수화되지 않은 시그니처에 할당할 수 없습니다.",
        "Overload signatures must all be exported or not exported.": "오버로드 시그니처는 모두 내보내거나 모두 내보내지 않아야 합니다.",
        "Overload signatures must all be ambient or non-ambient.": "오버로드 시그니처는 모두 앰비언트이거나 앰비언트가 아니어야 합니다.",
        "Overload signatures must all be public, private or protected.": "오버로드 시그니처는 모두 공용, 전용 또는 보호된 상태여야 합니다.",
        "Overload signatures must all be optional or required.": "오버로드 시그니처는 모두 선택 사항이거나 필수 사항이어야 합니다.",
        "Function overload must be static.": "함수 오버로드는 정적이어야 합니다.",
        "Function overload must not be static.": "함수 오버로드는 정적이 아니어야 합니다.",
        "Function implementation name must be '{0}'.": "함수 구현 이름이 '{0}'이어야 합니다.",
        "Constructor implementation is missing.": "생성자 구현이 없습니다.",
        "Function implementation is missing or not immediately following the declaration.": "함수 구현이 없거나 선언 바로 다음에 나오지 않습니다.",
        "Multiple constructor implementations are not allowed.": "여러 생성자 구현은 허용되지 않습니다.",
        "Duplicate function implementation.": "중복된 함수 구현입니다.",
        "Overload signature is not compatible with function implementation.": "오버로드 시그니처가 함수 구현과 호환되지 않습니다.",
        "Individual declarations in merged declaration '{0}' must be all exported or all local.": "병합된 선언 '{0}'의 개별 선언은 모두 내보내 졌거나 모두 로컬이어야 합니다.",
        "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.": "중복 식별자 'arguments'입니다. 컴파일러는 'arguments'를 사용해서 rest 매개 변수를 초기화합니다.",
        "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.": "중복 식별자 '_this'입니다. 컴파일러는 변수 선언 '_this'를 사용해서 'this' 참조를 캡처합니다.",
        "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.": "컴파일러가 'this' 참조를 캡처하기 위해 사용하는 변수 선언 '_this'로 식이 확인됩니다.",
        "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.": "중복 식별자 '_super'입니다. 컴파일러는 '_super'를 사용해서 기본 클래스 참조를 캡처합니다.",
        "Expression resolves to '_super' that compiler uses to capture base class reference.": "컴파일러가 기본 클래스 참조를 캡처하기 위해 사용하는 '_super'로 식이 확인됩니다.",
        "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.": "후속 변수 선언에 같은 형식이 있어야 합니다.  '{0}' 변수가 '{1}' 형식이어야 하는데 여기에는 '{2}' 형식이 있습니다.",
        "The left-hand side of a 'for...in' statement cannot use a type annotation.": "'for...in' 문의 왼쪽에는 형식 주석을 사용할 수 없습니다.",
        "The left-hand side of a 'for...in' statement must be of type 'string' or 'any'.": "'for...in' 문의 왼쪽은 'string' 또는 'any' 형식이어야 합니다.",
        "Invalid left-hand side in 'for...in' statement.": "'for...in' 문의 왼쪽이 잘못되었습니다.",
        "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.": "'for...in' 문 오른쪽은 'any' 형식, 개체 형식 또는 형식 매개 변수여야 합니다.",
        "Setters cannot return a value.": "Setter가 값을 반환할 수 없습니다.",
        "Return type of constructor signature must be assignable to the instance type of the class": "생성자 시그니처의 반환 형식을 클래스의 인스턴스 형식에 할당할 수 있어야 합니다.",
        "All symbols within a 'with' block will be resolved to 'any'.": "'with' 블록 안의 모든 기호는 'any'로 확인됩니다.",
        "Property '{0}' of type '{1}' is not assignable to string index type '{2}'.": "'{1}' 형식의 '{0}' 속성을 문자열 인덱스 형식 '{2}'에 할당할 수 없습니다.",
        "Property '{0}' of type '{1}' is not assignable to numeric index type '{2}'.": "'{1}' 형식의 '{0}' 속성을 숫자 인덱스 형식 '{2}'에 할당할 수 없습니다.",
        "Numeric index type '{0}' is not assignable to string index type '{1}'.": "숫자 인덱스 형식 '{0}'을(를) 문자열 인덱스 형식 '{1}'에 할당할 수 없습니다.",
        "Class name cannot be '{0}'": "클래스 이름은 '{0}'일 수 없습니다.",
        "Class '{0}' incorrectly extends base class '{1}'.": "'{0}' 클래스가 기본 클래스 '{1}'을(를) 잘못 확장합니다.",
        "Class static side '{0}' incorrectly extends base class static side '{1}'.": "클래스 정적 측면 '{0}'이(가) 기본 클래스 정적 측면 '{1}'을(를) 잘못 확장합니다.",
        "Type name '{0}' in extends clause does not reference constructor function for '{0}'.": "extends 절의 형식 이름 '{0}'은(는) '{0}'에 대한 생성자 함수를 참조하지 않습니다.",
        "Class '{0}' incorrectly implements interface '{1}'.": "'{0}' 클래스가 '{1}' 인터페이스를 잘못 구현합니다.",
        "A class may only implement another class or interface.": "클래스는 다른 클래스나 인터페이스만 구현할 수 있습니다.",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.": "'{0}' 클래스가 인스턴스 멤버 함수 '{1}'을(를) 정의하지만 확장 클래스 '{2}'은(는) 이 함수를 인스턴스 멤버 접근자로 정의합니다.",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.": "'{0}' 클래스가 인스턴스 멤버 함수 '{1}'을(를) 정의하지만 확장 클래스 '{2}'은(는) 이 함수를 인스턴스 멤버 속성으로 정의합니다.",
        "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.": "'{0}' 클래스가 인스턴스 멤버 속성 '{1}'을(를) 정의하지만 확장 클래스 '{2}'은(는) 이 속성을 인스턴스 멤버 함수로 정의합니다.",
        "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.": "'{0}' 클래스는 인스턴스 멤버 접근자 '{1}'을(를) 정의하지만 확장 클래스 '{2}'은(는) 이 접근자를 인스턴스 멤버 함수로 정의합니다.",
        "Interface name cannot be '{0}'": "인터페이스 이름은 '{0}'일 수 없습니다.",
        "All declarations of an interface must have identical type parameters.": "인터페이스의 모든 선언에는 동일한 형식 매개 변수가 포함되어야 합니다.",
        "Interface '{0}' incorrectly extends interface '{1}'.": "'{0}' 인터페이스가 '{1}' 인터페이스를 잘못 확장합니다.",
        "Enum name cannot be '{0}'": "열거형 이름은 '{0}'일 수 없습니다.",
        "In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.": "다중 선언이 포함된 열거형에서는 하나의 선언만 첫 번째 열거형 요소에 대한 이니셜라이저를 생략할 수 있습니다.",
        "A namespace declaration cannot be in a different file from a class or function with which it is merged": "네임스페이스 선언은 해당 선언이 병합된 클래스나 함수와 다른 파일에 있을 수 없습니다,",
        "A namespace declaration cannot be located prior to a class or function with which it is merged": "네임스페이스 선언은 해당 선언이 병합된 클래스나 함수 앞에 있을 수 없습니다.",
        "Ambient modules cannot be nested in other modules.": "앰비언트 모듈은 다른 모듈에 중첩될 수 없습니다.",
        "Ambient module declaration cannot specify relative module name.": "앰비언트 모듈 선언은 상대적 모듈 이름을 지정할 수 없습니다.",
        "Module '{0}' is hidden by a local declaration with the same name": "'{0}' 모듈은 이름이 같은 로컬 선언으로 숨겨집니다.",
        "Import name cannot be '{0}'": "가져오기 이름은 '{0}'일 수 없습니다.",
        "Import or export declaration in an ambient module declaration cannot reference module through relative module name.": "앰비언트 모듈 선언의 가져오기 또는 내보내기 선언은 상대적 모듈 이름을 통해 모듈을 참조할 수 없습니다.",
        "Import declaration conflicts with local declaration of '{0}'": "가져오기 선언이 '{0}'의 로컬 선언과 충돌합니다.",
        "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module.": "'{0}' 식별자가 중복되었습니다. 컴파일러는 모듈의 최상위 범위에 이름 '{1}'을(를) 예약합니다.",
        "Types have separate declarations of a private property '{0}'.": "형식에 별도의 전용 속성 '{0}' 선언이 있습니다.",
        "Property '{0}' is protected but type '{1}' is not a class derived from '{2}'.": "'{0}' 속성은 보호된 속성이지만 '{1}' 형식은 '{2}'에서 파생된 클래스가 아닙니다.",
        "Property '{0}' is protected in type '{1}' but public in type '{2}'.": "'{0}' 속성은 '{1}' 형식에서는 보호된 속성이지만 '{2}' 형식에서는 공용입니다.",
        "Property '{0}' is protected and only accessible within class '{1}' and its subclasses.": "'{0}' 속성은 보호된 속성이며 '{1}' 클래스 및 해당 하위 클래스 내에서만 액세스할 수 있습니다.",
        "Property '{0}' is protected and only accessible through an instance of class '{1}'.": "'{0}' 속성은 보호된 속성이며 '{1}' 클래스의 인스턴스를 통해서만 액세스할 수 있습니다.",
        "The '{0}' operator is not allowed for boolean types. Consider using '{1}' instead.": "'{0}' 연산자는 부울 형식에 사용할 수 없습니다. 대신 '{1}'을(를) 사용하세요.",
        "Block-scoped variable '{0}' used before its declaration.": "선언 전에 사용된 블록 범위 변수 '{0}'입니다.",
        "The operand of an increment or decrement operator cannot be a constant.": "증가 또는 감소 연산자의 피연산자는 상수일 수 없습니다.",
        "Left-hand side of assignment expression cannot be a constant.": "할당 식의 왼쪽은 상수일 수 없습니다.",
        "Cannot redeclare block-scoped variable '{0}'.": "블록 범위 변수 '{0}'을(를) 다시 선언할 수 없습니다.",
        "An enum member cannot have a numeric name.": "열거형 멤버는 숫자 이름을 가질 수 없습니다.",
        "The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.": "형식 매개 변수 '{0}'의 형식 인수를 유추할 수 없습니다. 형식 인수를 명시적으로 지정하세요.",
        "Type argument candidate '{1}' is not a valid type argument because it is not a supertype of candidate '{0}'.": "형식 인수 후보 '{1}'은(는) '{0}' 후보의 상위 형식이 아니기 때문에 유효한 형식 인수가 아닙니다.",
        "Type alias '{0}' circularly references itself.": "'{0}' 형식 별칭은 순환적으로 자신을 참조합니다.",
        "Type alias name cannot be '{0}'": "형식 별칭 이름은 '{0}'일 수 없습니다.",
        "An AMD module cannot have multiple name assignments.": "AMD 모듈에는 여러 이름이 할당될 수 없습니다.",
        "Type '{0}' has no property '{1}' and no string index signature.": "'{0}' 형식에 '{1}' 속성과 문자열 인덱스 서명이 없습니다.",
        "Type '{0}' has no property '{1}'.": "'{0}' 형식에 '{1}' 속성이 없습니다.",
        "Type '{0}' is not an array type.": "'{0}' 형식은 배열 형식이 아닙니다.",
        "A rest element must be last in an array destructuring pattern": "rest 요소는 배열 구조 파괴 패턴의 마지막 요소여야 합니다.",
        "A binding pattern parameter cannot be optional in an implementation signature.": "바인딩 패턴 매개 변수는 구현 서명에서 선택 사항이 될 수 없습니다.",
        "A computed property name must be of type 'string', 'number', 'symbol', or 'any'.": "계산된 속성 이름은 'string', 'number', 'symbol' 또는 'any' 형식이어야 합니다.",
        "'this' cannot be referenced in a computed property name.": "'this'는 계산된 속성 이름에서 참조할 수 없습니다.",
        "'super' cannot be referenced in a computed property name.": "'super'는 계산된 속성 이름에서 참조할 수 없습니다.",
        "A computed property name cannot reference a type parameter from its containing type.": "계산된 속성 이름에서는 포함하는 형식의 형식 매개 변수를 참조할 수 없습니다.",
        "Cannot find global value '{0}'.": "전역 값 '{0}'을(를) 찾을 수 없습니다.",
        "The '{0}' operator cannot be applied to type 'symbol'.": "'{0}' 연산자는 'symbol' 유형에 적용될 수 없습니다.",
        "'Symbol' reference does not refer to the global Symbol constructor object.": "'기호' 참조에서 전역 기호 생성자 개체를 참조하지 않습니다.",
        "A computed property name of the form '{0}' must be of type 'symbol'.": "'{0}' 양식의 계산된 속성 이름은 'symbol' 형식이어야 합니다.",
        "Spread operator in 'new' expressions is only available when targeting ECMAScript 5 and higher.": "'new' 식에서 Spread 연산자는 ECMAScript 5 이상을 대상으로 하는 경우에만 사용할 수 있습니다.",
        "Enum declarations must all be const or non-const.": "열거형 선언은 모두 const 또는 비const여야 합니다.",
        "In 'const' enum declarations member initializer must be constant expression.": "'const' 열거형 선언에서 멤버 이니셜라이저는 상수 식이어야 합니다.",
        "'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment.": "'const' 열거형은 속성 또는 인덱스 액세스 식 또는 내보내기 할당 또는 가져오기 선언의 오른쪽에서만 사용할 수 있습니다.",
        "A const enum member can only be accessed using a string literal.": "const 열거형 멤버는 문자열 리터럴을 통해서만 액세스할 수 있습니다.",
        "'const' enum member initializer was evaluated to a non-finite value.": "'const' 열거형 멤버 이니셜라이저가 무한 값에 대해 평가되었습니다.",
        "'const' enum member initializer was evaluated to disallowed value 'NaN'.": "'const' 열거형 멤버 이니셜라이저가 허용되지 않은 'NaN' 값에 대해 평가되었습니다.",
        "Property '{0}' does not exist on 'const' enum '{1}'.": "'const' 열거형 '{1}'에 '{0}' 속성이 없습니다.",
        "'let' is not allowed to be used as a name in 'let' or 'const' declarations.": "'let'은 'let' 또는 'const' 선언에서 이름으로 사용할 수 없습니다.",
        "Cannot initialize outer scoped variable '{0}' in the same scope as block scoped declaration '{1}'.": "블록 범위 선언 '{1}'과(와) 동일한 범위 내에서 외부 범위 변수 '{0}'을(를) 초기화할 수 없습니다.",
        "The left-hand side of a 'for...of' statement cannot use a type annotation.": "'for...of' 문의 왼쪽에는 형식 주석을 사용할 수 없습니다.",
        "Export declaration conflicts with exported declaration of '{0}'": "내보내기 선언이 '{0}'의 내보낸 선언과 충돌함",
        "The left-hand side of a 'for...of' statement cannot be a previously defined constant.": "'for...of' 문의 왼쪽에는 이전에 정의된 상수를 사용할 수 없습니다.",
        "The left-hand side of a 'for...in' statement cannot be a previously defined constant.": "'for...in' 문의 왼쪽에는 이전에 정의된 상수를 사용할 수 없습니다.",
        "Invalid left-hand side in 'for...of' statement.": "'for...of' 문의 왼쪽이 잘못되었습니다.",
        "Type must have a '[Symbol.iterator]()' method that returns an iterator.": "형식에는 반복기를 반환하는 '[Symbol.iterator]()' 메서드가 있어야 합니다.",
        "An iterator must have a 'next()' method.": "반복기에는 'next()' 메서드가 있어야 합니다.",
        "The type returned by the 'next()' method of an iterator must have a 'value' property.": "반복기의 'next()' 메서드에 의해 반환되는 형식에는 'value' 속성이 있어야 합니다.",
        "The left-hand side of a 'for...in' statement cannot be a destructuring pattern.": "'for...in' 문의 왼쪽에는 구조 파괴 패턴을 사용할 수 없습니다.",
        "Cannot redeclare identifier '{0}' in catch clause": "catch 절에서 식별자 '{0}'을(를) 다시 선언할 수 없습니다.",
        "Tuple type '{0}' with length '{1}' cannot be assigned to tuple with length '{2}'.": "길이가 '{1}'인 튜플 형식 '{0}'을(를) 길이가 '{2}'인 튜플에 할당할 수 없습니다.",
        "Using a string in a 'for...of' statement is only supported in ECMAScript 5 and higher.": "ECMAScript 5 이상에서만 'for...of' 문에서 문자열을 사용할 수 있습니다.",
        "Type '{0}' is not an array type or a string type.": "'{0}' 형식은 배열 형식 또는 문자열 형식이 아닙니다.",
        "The 'arguments' object cannot be referenced in an arrow function in ES3 and ES5. Consider using a standard function expression.": "'arguments' 개체는 ES3 및 ES5의 화살표 함수에서 참조할 수 없습니다. 표준 함수 식을 사용해 보세요.",
        "Module '{0}' resolves to a non-module entity and cannot be imported using this construct.": "모듈 '{0}'은(는) 모듈이 아닌 엔터티로 확인되므로 이 구문을 사용하여 가져올 수 없습니다.",
        "Module '{0}' uses 'export =' and cannot be used with 'export *'.": "모듈 '{0}'은(는) 'export ='을 사용하며 'export *'와 함께 사용할 수 없습니다.",
        "An interface can only extend an identifier/qualified-name with optional type arguments.": "인터페이스는 선택적 형식 인수가 포함된 식별자/정규화된 이름만 확장할 수 있습니다.",
        "A class can only implement an identifier/qualified-name with optional type arguments.": "클래스는 선택적 형식 인수가 포함된 식별자/정규화된 이름만 구현할 수 있습니다.",
        "A rest element cannot contain a binding pattern.": "rest 요소에는 바인딩 패턴이 포함될 수 없습니다.",
        "'{0}' is referenced directly or indirectly in its own type annotation.": "'{0}'은(는) 자체 형식 주석에서 직간접적으로 참조됩니다.",
        "Cannot find namespace '{0}'.": "'{0}' 네임스페이스를 찾을 수 없습니다.",
        "No best common type exists among yield expressions.": "yield 식 중에 가장 적합한 공용 형식이 없습니다.",
        "A generator cannot have a 'void' type annotation.": "생성기에는 'void' 형식 주석을 사용할 수 없습니다.",
        "'{0}' is referenced directly or indirectly in its own base expression.": "'{0}'은(는) 자체 기본 식에서 직간접적으로 참조됩니다.",
        "Type '{0}' is not a constructor function type.": "'{0}' 형식은 생성자 함수 형식이 아닙니다.",
        "No base constructor has the specified number of type arguments.": "기본 생성자에 지정된 수의 형식 인수가 없습니다.",
        "Base constructor return type '{0}' is not a class or interface type.": "기본 생성자 반환 형식 '{0}'은(는) 클래스 또는 인터페이스 형식이 아닙니다.",
        "Base constructors must all have the same return type.": "기본 생성자는 모두 반환 형식이 같아야 합니다.",
        "Cannot create an instance of the abstract class '{0}'.": "추상 클래스 '{0}'의 인스턴스를 만들 수 없습니다.",
        "Overload signatures must all be abstract or not abstract.": "오버로드 서명은 모두 abstract이거나 abstract가 아니어야 합니다.",
        "Abstract method '{0}' in class '{1}' cannot be accessed via super expression.": "super 식을 통해 '{1}' 클래스의 추상 메서드 '{0}'에 액세스할 수 없습니다.",
        "Classes containing abstract methods must be marked abstract.": "추상 메서드를 포함하는 클래스는 abstract로 표시되어 있어야 합니다.",
        "Non-abstract class '{0}' does not implement inherited abstract member '{1}' from class '{2}'.": "비추상 클래스 '{0}'은(는) '{2}' 클래스에서 상속된 추상 멤버 '{1}'을(를) 구현하지 않습니다.",
        "All declarations of an abstract method must be consecutive.": "추상 메서드의 모든 선언은 연속적이어야 합니다.",
        "Cannot assign an abstract constructor type to a non-abstract constructor type.": "추상 생성자 형식을 비추상 생성자 형식에 할당할 수 없습니다.",
        "Only an ambient class can be merged with an interface.": "앰비언트 클래스만 인터페이스와 병합될 수 있습니다.",
        "Duplicate identifier '{0}'. Compiler uses declaration '{1}' to support async functions.": "중복 식별자 '{0}'입니다. 컴파일러는 '{1}' 선언을 사용하여 비동기 함수를 지원합니다.",
        "Expression resolves to variable declaration '{0}' that compiler uses to support async functions.": "컴파일러가 비동기 함수를 지원하기 위해 사용하는 변수 선언 '{0}'(으)로 식이 확인됩니다.",
        "The 'arguments' object cannot be referenced in an async arrow function. Consider using a standard async function expression.": "'arguments' 개체는 비동기 화살표 함수에서 참조할 수 없습니다. 표준 비동기 함수 식을 사용해 보세요.",
        "'yield' expressions cannot be used in a parameter initializer.": "'yield' 식은 매개 변수 이니셜라이저에서 사용할 수 없습니다.",
        "'await' expressions cannot be used in a parameter initializer.": "'await' 식은 매개 변수 이니셜라이저에서 사용할 수 없습니다.",
        "JSX element attributes type '{0}' must be an object type.": "JSX 요소 특성 형식 '{0}'은(는) 개체 형식이어야 합니다.",
        "The return type of a JSX element constructor must return an object type.": "JSX 요소 생성자의 반환 형식은 개체 형식을 반환해야 합니다.",
        "JSX element implicitly has type 'any' because the global type 'JSX.Element' does not exist.": "전역 형식 'JSX.Element'가 없으므로 JSX 요소는 암시적으로 'any' 형식입니다.",
        "Property '{0}' in type '{1}' is not assignable to type '{2}'": "'{1}' 형식의 '{0}' 속성을 '{2}' 형식에 할당할 수 없습니다.",
        "JSX element type '{0}' does not have any construct or call signatures.": "JSX 요소 형식 '{0}'에 구문 또는 호출 서명이 없습니다.",
        "JSX element type '{0}' is not a constructor function for JSX elements.": "JSX 요소 형식 '{0}'은(는) JSX 요소에 대한 생성자 함수가 아닙니다.",
        "Property '{0}' of JSX spread attribute is not assignable to target property.": "JSX 분배 특성의 '{0}' 속성을 대상 속성에 할당할 수 없습니다.",
        "JSX element class does not support attributes because it does not have a '{0}' property": "JSX 요소 클래스는 '{0}' 속성이 없으므로 특성을 지원하지 않습니다.",
        "The global type 'JSX.{0}' may not have more than one property": "전역 형식 'JSX.{0}'에 속성이 둘 이상 있을 수 없습니다.",
        "Cannot emit namespaced JSX elements in React": "React에서 네임스페이스 지정된 JSX 요소를 내보낼 수 없습니다.",
        "A member initializer in a 'const' enum declaration cannot reference members declared after it, including members defined in other 'const' enums.": "'const' 열거형 선언의 멤버 이니셜라이저는 다른 'const' 열거형에 정의된 멤버를 포함하여 그다음에 선언된 멤버를 참조할 수 없습니다.",
        "Merged declaration '{0}' cannot include a default export declaration. Consider adding a separate 'export default {0}' declaration instead.": "병합된 선언 '{0}'에는 기본 내보내기 선언을 포함할 수 없습니다. 대신 별도의 'export default {0}' 선언을 추가하세요.",
        "Import declaration '{0}' is using private name '{1}'.": "가져오기 선언 '{0}'이(가) 전용 이름 '{1}'을(를) 사용하고 있습니다.",
        "Type parameter '{0}' of exported class has or is using private name '{1}'.": "내보낸 클래스의 형식 매개 변수 '{0}'이(가) 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Type parameter '{0}' of exported interface has or is using private name '{1}'.": "내보낸 인터페이스의 형식 매개 변수 '{0}'이(가) 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.": "내보낸 인터페이스에 있는 생성자 시그니처의 형식 매개 변수 '{0}'이(가) 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'.": "내보낸 인터페이스에 있는 호출 시그니처의 형식 매개 변수 '{0}'이(가) 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Type parameter '{0}' of public static method from exported class has or is using private name '{1}'.": "내보낸 클래스에 있는 공용 정적 메서드의 형식 매개 변수 '{0}'이(가) 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Type parameter '{0}' of public method from exported class has or is using private name '{1}'.": "내보낸 클래스에 있는 공용 메서드의 형식 매개 변수 '{0}'이(가) 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Type parameter '{0}' of method from exported interface has or is using private name '{1}'.": "내보낸 인터페이스에 있는 메서드의 형식 매개 변수 '{0}'이(가) 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Type parameter '{0}' of exported function has or is using private name '{1}'.": "내보낸 함수의 형식 매개 변수 '{0}'이(가) 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Implements clause of exported class '{0}' has or is using private name '{1}'.": "내보낸 클래스 '{0}'의 Implements 절이 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Extends clause of exported class '{0}' has or is using private name '{1}'.": "내보낸 클래스 '{0}'의 Extends 절이 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Extends clause of exported interface '{0}' has or is using private name '{1}'.": "내보낸 인터페이스 '{0}'의 Extends 절이 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named.": "내보낸 변수 '{0}'이(가) 외부 모듈 {2}의 '{1}' 이름을 가지고 있거나 사용 중이지만 명명할 수 없습니다.",
        "Exported variable '{0}' has or is using name '{1}' from private module '{2}'.": "내보낸 변수 '{0}'이(가) 전용 모듈 '{2}'의 '{1}' 이름을 가지고 있거나 사용 중입니다.",
        "Exported variable '{0}' has or is using private name '{1}'.": "내보낸 변수 '{0}'이(가) 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.": "내보낸 클래스에 있는 공용 정적 속성 '{0}'이(가) 외부 모듈 {2}의 '{1}' 이름을 가지고 있거나 사용 중이지만 명명할 수 없습니다.",
        "Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'.": "내보낸 클래스의 공용 정적 속성 '{0}'이(가) 전용 모듈 '{2}'의 '{1}' 이름을 가지고 있거나 사용 중입니다.",
        "Public static property '{0}' of exported class has or is using private name '{1}'.": "내보낸 클래스의 공용 정적 속성 '{0}'이(가) 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.": "내보낸 클래스의 공용 속성 '{0}'이(가) 외부 모듈 {2}의 '{1}' 이름을 가지고 있거나 사용 중이지만 명명할 수 없습니다.",
        "Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'.": "내보낸 클래스의 공용 속성 '{0}'이(가) 전용 모듈 '{2}'의 '{1}' 이름을 가지고 있거나 사용 중입니다.",
        "Public property '{0}' of exported class has or is using private name '{1}'.": "내보낸 클래스의 공용 속성 '{0}'이(가) 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'.": "내보낸 인터페이스의 '{0}' 속성이 전용 모듈 '{2}'의 '{1}' 이름을 가지고 있거나 사용 중입니다.",
        "Property '{0}' of exported interface has or is using private name '{1}'.": "내보낸 인터페이스의 '{0}' 속성이 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of public static property setter from exported class has or is using name '{1}' from private module '{2}'.": "내보낸 클래스에 있는 공용 정적 속성 setter의 '{0}' 매개 변수가 전용 모듈 '{2}'의 '{1}' 이름을 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of public static property setter from exported class has or is using private name '{1}'.": "내보낸 클래스에 있는 공용 정적 속성 setter의 '{0}' 매개 변수가 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of public property setter from exported class has or is using name '{1}' from private module '{2}'.": "내보낸 클래스에 있는 공용 속성 setter의 '{0}' 매개 변수가 전용 모듈 '{2}'의 '{1}' 이름을 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of public property setter from exported class has or is using private name '{1}'.": "내보낸 클래스에 있는 공용 속성 setter의 '{0}' 매개 변수가 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Return type of public static property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.": "내보낸 클래스에 있는 공용 정적 속성 getter의 반환 형식이 외부 모듈 {1}의 '{0}' 이름을 가지고 있거나 사용 중이지만 명명할 수 없습니다.",
        "Return type of public static property getter from exported class has or is using name '{0}' from private module '{1}'.": "내보낸 클래스에 있는 공용 정적 속성 getter의 반환 형식이 전용 모듈 '{1}'의 '{0}' 이름을 가지고 있거나 사용 중입니다.",
        "Return type of public static property getter from exported class has or is using private name '{0}'.": "내보낸 클래스에 있는 공용 정적 속성 getter의 반환 형식이 전용 이름 '{0}'을(를) 가지고 있거나 사용 중입니다.",
        "Return type of public property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.": "내보낸 클래스에 있는 공용 속성 getter의 반환 형식이 외부 모듈 {1}의 '{0}' 이름을 가지고 있거나 사용 중이지만 명명할 수 없습니다.",
        "Return type of public property getter from exported class has or is using name '{0}' from private module '{1}'.": "내보낸 클래스에 있는 공용 속성 getter의 반환 형식이 전용 모듈 '{1}'의 '{0}' 이름을 가지고 있거나 사용 중입니다.",
        "Return type of public property getter from exported class has or is using private name '{0}'.": "내보낸 클래스에 있는 공용 속성 getter의 반환 형식이 전용 이름 '{0}'을(를) 가지고 있거나 사용 중입니다.",
        "Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'.": "내보낸 인터페이스에 있는 생성자 시그니처의 반환 형식이 전용 모듈 '{1}'의 '{0}' 이름을 가지고 있거나 사용 중입니다.",
        "Return type of constructor signature from exported interface has or is using private name '{0}'.": "내보낸 인터페이스에 있는 생성자 시그니처의 반환 형식이 전용 이름 '{0}'을(를) 가지고 있거나 사용 중입니다.",
        "Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'.": "내보낸 인터페이스에 있는 호출 시그니처의 반환 형식이 전용 모듈 '{1}'의 '{0}' 이름을 가지고 있거나 사용 중입니다.",
        "Return type of call signature from exported interface has or is using private name '{0}'.": "내보낸 인터페이스에 있는 호출 시그니처의 반환 형식이 전용 이름 '{0}'을(를) 가지고 있거나 사용 중입니다.",
        "Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'.": "내보낸 인터페이스에 있는 인덱스 시그니처의 반환 형식이 전용 모듈 '{1}'의 '{0}' 이름을 가지고 있거나 사용 중입니다.",
        "Return type of index signature from exported interface has or is using private name '{0}'.": "내보낸 인터페이스에 있는 인덱스 시그니처의 반환 형식이 전용 이름 '{0}'을(를) 가지고 있거나 사용 중입니다.",
        "Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named.": "내보낸 클래스에 있는 공용 정적 메서드의 반환 형식이 외부 모듈 {1}의 '{0}' 이름을 가지고 있거나 사용 중이지만 명명할 수 없습니다.",
        "Return type of public static method from exported class has or is using name '{0}' from private module '{1}'.": "내보낸 클래스에 있는 공용 정적 메서드의 반환 형식이 전용 모듈 '{1}'의 '{0}' 이름을 가지고 있거나 사용 중입니다.",
        "Return type of public static method from exported class has or is using private name '{0}'.": "내보낸 클래스에 있는 공용 정적 메서드의 반환 형식이 전용 이름 '{0}'을(를) 가지고 있거나 사용 중입니다.",
        "Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named.": "내보낸 클래스에 있는 공용 메서드의 반환 형식이 외부 모듈 {1}의 '{0}' 이름을 가지고 있거나 사용 중이지만 명명할 수 없습니다.",
        "Return type of public method from exported class has or is using name '{0}' from private module '{1}'.": "내보낸 클래스에 있는 공용 메서드의 반환 형식이 전용 모듈 '{1}'의 '{0}' 이름을 가지고 있거나 사용 중입니다.",
        "Return type of public method from exported class has or is using private name '{0}'.": "내보낸 클래스에 있는 공용 메서드의 반환 형식이 전용 이름 '{0}'을(를) 가지고 있거나 사용 중입니다.",
        "Return type of method from exported interface has or is using name '{0}' from private module '{1}'.": "내보낸 인터페이스에 있는 메서드의 반환 형식이 전용 모듈 '{1}'의 '{0}' 이름을 가지고 있거나 사용 중입니다.",
        "Return type of method from exported interface has or is using private name '{0}'.": "내보낸 인터페이스에 있는 메서드의 반환 형식이 전용 이름 '{0}'을(를) 가지고 있거나 사용 중입니다.",
        "Return type of exported function has or is using name '{0}' from external module {1} but cannot be named.": "내보낸 함수의 반환 형식이 외부 모듈 {1}의 '{0}' 이름을 가지고 있거나 사용 중이지만 명명할 수 없습니다.",
        "Return type of exported function has or is using name '{0}' from private module '{1}'.": "내보낸 함수의 반환 형식이 전용 모듈 '{1}'의 '{0}' 이름을 가지고 있거나 사용 중입니다.",
        "Return type of exported function has or is using private name '{0}'.": "내보낸 함수의 반환 형식이 전용 이름 '{0}'을(를) 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named.": "내보낸 클래스에 있는 생성자의 '{0}' 매개 변수가 외부 모듈 {2}의 '{1}' 이름을 가지고 있거나 사용 중이지만 명명할 수 없습니다.",
        "Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'.": "내보낸 클래스에 있는 생성자의 '{0}' 매개 변수가 전용 모듈 '{2}'의 '{1}' 이름을 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of constructor from exported class has or is using private name '{1}'.": "내보낸 클래스에 있는 생성자의 '{0}' 매개 변수가 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'.": "내보낸 인터페이스에 있는 생성자 시그니처의 '{0}' 매개 변수가 전용 모듈 '{2}'의 '{1}' 이름을 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.": "내보낸 인터페이스에 있는 생성자 시그니처의 '{0}' 매개 변수가 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'.": "내보낸 인터페이스에 있는 호출 시그니처의 '{0}' 매개 변수가 전용 모듈 '{2}'의 '{1}' 이름을 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of call signature from exported interface has or is using private name '{1}'.": "내보낸 인터페이스에 있는 호출 시그니처의 '{0}' 매개 변수가 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named.": "내보낸 클래스에 있는 공용 정적 메서드의 '{0}' 매개 변수가 외부 모듈 {2}의 '{1}' 이름을 가지고 있거나 사용 중이지만 명명할 수 없습니다.",
        "Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'.": "내보낸 클래스에 있는 공용 정적 메서드의 '{0}' 매개 변수가 전용 모듈 '{2}'의 '{1}' 이름을 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of public static method from exported class has or is using private name '{1}'.": "내보낸 클래스에 있는 공용 정적 메서드의 '{0}' 매개 변수가 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named.": "내보낸 클래스에 있는 공용 메서드의 '{0}' 매개 변수가 외부 모듈 {2}의 '{1}' 이름을 가지고 있거나 사용 중이지만 명명할 수 없습니다.",
        "Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'.": "내보낸 클래스에 있는 공용 메서드의 '{0}' 매개 변수가 전용 모듈 '{2}'의 '{1}' 이름을 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of public method from exported class has or is using private name '{1}'.": "내보낸 클래스에 있는 공용 메서드의 '{0}' 매개 변수가 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'.": "내보낸 인터페이스에 있는 메서드의 '{0}' 매개 변수가 전용 모듈 '{2}'의 '{1}' 이름을 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of method from exported interface has or is using private name '{1}'.": "내보낸 인터페이스에 있는 메서드의 '{0}' 매개 변수가 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named.": "내보낸 함수의 '{0}' 매개 변수가 외부 모듈 {2}의 '{1}' 이름을 가지고 있거나 사용 중이지만 명명할 수 없습니다.",
        "Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'.": "내보낸 함수의 '{0}' 매개 변수가 전용 모듈 '{2}'의 '{1}' 이름을 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of exported function has or is using private name '{1}'.": "내보낸 함수의 '{0}' 매개 변수가 전용 이름 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Exported type alias '{0}' has or is using private name '{1}'.": "내보낸 형식 별칭 '{0}'은(는) '{1}' 전용 이름을 포함하거나 사용 중입니다.",
        "Default export of the module has or is using private name '{0}'.": "모듈의 기본 내보내기에서 전용 이름 '{0}'을(를) 가지고 있거나 사용 중입니다.",
        "Loop contains block-scoped variable '{0}' referenced by a function in the loop. This is only supported in ECMAScript 6 or higher.": "루프에 루프의 함수에서 참조되는 블록 범위 변수 '{0}'이(가) 포함되어 있습니다. 이 변수는 ECMAScript 6 이상에서만 지원됩니다.",
        "The current host does not support the '{0}' option.": "현재 호스트가 '{0}' 옵션을 지원하지 않습니다.",
        "Cannot find the common subdirectory path for the input files.": "입력 파일의 공용 하위 디렉터리 경로를 찾을 수 없습니다.",
        "Cannot read file '{0}': {1}": "파일 '{0}'을(를) 읽을 수 없습니다. {1}",
        "Unsupported file encoding.": "지원되지 않는 파일 인코딩입니다.",
        "Failed to parse file '{0}': {1}.": "'{0}' 파일의 구분을 분석하지 못했습니다. {1}.",
        "Unknown compiler option '{0}'.": "알 수 없는 컴파일러 옵션 '{0}'입니다.",
        "Compiler option '{0}' requires a value of type {1}.": "컴파일러 옵션 '{0}'에 {1} 형식의 값이 필요합니다.",
        "Could not write file '{0}': {1}": "'{0}' 파일을 쓸 수 없습니다. {1}",
        "Option 'mapRoot' cannot be specified without specifying 'sourceMap' option.": "'sourceMap' 옵션을 지정하지 않고 'mapRoot' 옵션을 지정할 수 없습니다.",
        "Option 'sourceRoot' cannot be specified without specifying 'sourceMap' option.": "'sourceMap' 옵션을 지정하지 않고 'sourceRoot' 옵션을 지정할 수 없습니다.",
        "Option 'noEmit' cannot be specified with option 'out' or 'outDir'.": "'out' 또는 'outDir' 옵션을 사용하여 'noEmit' 옵션을 지정할 수 없습니다.",
        "Option 'noEmit' cannot be specified with option 'declaration'.": "'declaration' 옵션을 사용하여 'noEmit' 옵션을 지정할 수 없습니다.",
        "Option 'project' cannot be mixed with source files on a command line.": "명령줄에서 'project' 옵션을 원본 파일과 혼합하여 사용할 수 없습니다.",
        "Option 'declaration' cannot be specified with option 'isolatedModules'.": "'declaration' 옵션은 'isolatedModules' 옵션과 함께 지정할 수 없습니다.",
        "Option 'noEmitOnError' cannot be specified with option 'isolatedModules'.": "'noEmitOnError' 옵션은 'isolatedModules' 옵션과 함께 지정할 수 없습니다.",
        "Option 'out' cannot be specified with option 'isolatedModules'.": "'out' 옵션은 'isolatedModules' 옵션과 함께 지정할 수 없습니다.",
        "Option 'isolatedModules' can only be used when either option'--module' is provided or option 'target' is 'ES6' or higher.": "'isolatedModules' 옵션은 '--module' 옵션이 제공되거나 'target' 옵션이 'ES6' 이상인 경우에만 사용할 수 있습니다.",
        "Option 'sourceMap' cannot be specified with option 'inlineSourceMap'.": "'sourceMap' 옵션은 'inlineSourceMap' 옵션과 함께 지정할 수 없습니다.",
        "Option 'sourceRoot' cannot be specified with option 'inlineSourceMap'.": "'sourceRoot' 옵션은 'inlineSourceMap' 옵션과 함께 지정할 수 없습니다.",
        "Option 'mapRoot' cannot be specified with option 'inlineSourceMap'.": "'mapRoot' 옵션은 'inlineSourceMap' 옵션과 함께 지정할 수 없습니다.",
        "Option 'inlineSources' can only be used when either option '--inlineSourceMap' or option '--sourceMap' is provided.": "'inlineSources' 옵션은 '--inlineSourceMap' 또는 '--sourceMap' 옵션이 제공되는 경우에만 사용할 수 있습니다.",
        "Concatenate and emit output to single file.": "출력을 연결하고 단일 파일로 내보냅니다.",
        "Generates corresponding '.d.ts' file.": "해당 '.d.ts' 파일을 생성합니다.",
        "Specifies the location where debugger should locate map files instead of generated locations.": "디버거가 생성된 위치 대신 맵 파일을 찾아야 하는 위치를 지정합니다.",
        "Specifies the location where debugger should locate TypeScript files instead of source locations.": "디버거가 소스 위치 대신 TypeScript 파일을 찾아야 하는 위치를 지정합니다.",
        "Watch input files.": "조사식 입력 파일입니다.",
        "Redirect output structure to the directory.": "출력 구조를 디렉터리로 리디렉션합니다.",
        "Do not erase const enum declarations in generated code.": "생성된 코드에서 const 열거형 선언을 지우지 마세요.",
        "Do not emit outputs if any errors were reported.": "오류가 보고되면 출력을 내보내지 않습니다.",
        "Do not emit comments to output.": "주석을 출력에 내보내지 마세요.",
        "Do not emit outputs.": "출력을 내보내지 않습니다.",
        "Specify ECMAScript target version: 'ES3' (default), 'ES5', or 'ES6' (experimental)": "ECMAScript 대상 버전 지정: 'ES3'(기본값), 'ES5' 또는 'ES6'(실험)",
        "Specify module code generation: 'commonjs', 'amd', 'system' or 'umd'": "모듈 코드 생성('commonjs', 'amd', 'system' 또는 'umd')을 지정합니다.",
        "Print this message.": "이 메시지를 출력합니다.",
        "Print the compiler's version.": "컴파일러 버전을 인쇄합니다.",
        "Compile the project in the given directory.": "지정된 디렉터리에서 프로젝트를 컴파일합니다.",
        "Syntax: {0}": "구문: {0}",
        "options": "옵션",
        "file1": "파일",
        "Examples: {0}": "예: {0}",
        "Options:": "옵션:",
        "Version {0}": "버전 {0}",
        "Insert command line options and files from a file.": "파일에서 명령줄 옵션 및 파일을 삽입합니다.",
        "File change detected. Starting incremental compilation...": "파일 변경이 검색되었습니다. 증분 컴파일을 시작하는 중...",
        "KIND": "KIND",
        "file2": "파일",
        "VERSION": "버전",
        "LOCATION": "위치",
        "DIRECTORY": "디렉터리",
        "Compilation complete. Watching for file changes.": "컴파일이 완료되었습니다. 파일이 변경되었는지 확인하는 중입니다.",
        "Generates corresponding '.map' file.": "해당 '.map' 파일을 생성합니다.",
        "Compiler option '{0}' expects an argument.": "컴파일러 옵션 '{0}'에는 인수가 필요합니다.",
        "Unterminated quoted string in response file '{0}'.": "응답 파일 '{0}'의 종결되지 않은 따옴표 붙은 문자열입니다.",
        "Argument for '--module' option must be 'commonjs', 'amd', 'system' or 'umd'.": "'--module' 옵션의 인수는 'commonjs', 'amd', 'system' 또는 'umd'여야 합니다.",
        "Argument for '--target' option must be 'ES3', 'ES5', or 'ES6'.": "'--target' 옵션에 대한 인수는 'ES3', 'ES5' 또는 'ES6'여야 합니다.",
        "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.": "로캘이 <language> 또는 <language>-<territory> 형식이어야 합니다. 예를 들어 '{0}' 또는 '{1}'입니다.",
        "Unsupported locale '{0}'.": "지원되지 않는 로캘 '{0}'입니다.",
        "Unable to open file '{0}'.": "'{0}' 파일을 열 수 없습니다.",
        "Corrupted locale file {0}.": "로캘 파일 {0}이(가) 손상되었습니다.",
        "Raise error on expressions and declarations with an implied 'any' type.": "암시된 'any' 형식이 있는 식 및 선언에서 오류를 발생합니다.",
        "File '{0}' not found.": "'{0}' 파일을 찾을 수 없습니다.",
        "File '{0}' has unsupported extension. The only supported extensions are {1}.": "'{0}' 파일의 확장명이 지원되지 않습니다. 지원되는 확장명은 {1}뿐입니다.",
        "Suppress noImplicitAny errors for indexing objects lacking index signatures.": "인덱스 서명이 없는 개체 인덱싱에 대한 noImplicitAny 오류를 표시하지 않습니다.",
        "Do not emit declarations for code that has an '@internal' annotation.": "'@internal' 주석이 있는 코드에 대한 선언을 내보내지 마세요.",
        "Specifies the root directory of input files. Use to control the output directory structure with --outDir.": "입력 파일의 루트 디렉터리를 지정합니다. outDir이 포함된 출력 디렉터리 구조를 제어하는 데 사용됩니다.",
        "File '{0}' is not under 'rootDir' '{1}'. 'rootDir' is expected to contain all source files.": "'{0}' 파일이 'rootDir' '{1}' 아래에 있지 않습니다. 'rootDir'에는 모든 소스 파일이 포함되어 있어야 합니다.",
        "Specifies the end of line sequence to be used when emitting files: 'CRLF' (dos) or 'LF' (unix).": "파일을 내보낼 때 사용할 줄 시퀀스의 끝을 지정하며, 'CRLF'(dos) 또는 'LF'(unix)입니다.",
        "NEWLINE": "줄 바꿈",
        "Argument for '--newLine' option must be 'CRLF' or 'LF'.": "'--newLine' 옵션의 인수는 'CRLF' 또는 'LF'여야 합니다.",
        "Specify JSX code generation: 'preserve' or 'react'": "JSX 코드 생성 지정: 'preserve' 또는 'react'",
        "Argument for '--jsx' must be 'preserve' or 'react'.": "'--jsx'에 대한 인수는 'preserve' 또는 'react'여야 합니다.",
        "Option 'experimentalDecorators' must also be specified when option 'emitDecoratorMetadata' is specified.": "'emitDecoratorMetadata' 옵션이 지정된 경우 'experimentalDecorators' 옵션도 지정해야 합니다.",
        "Enables experimental support for ES7 decorators.": "ES7 데코레이터에 대해 실험적 지원을 사용합니다.",
        "Enables experimental support for emitting type metadata for decorators.": "데코레이터에 대한 형식 메타데이터를 내보내기 위해 실험적 지원을 사용합니다.",
        "Option 'experimentalAsyncFunctions' cannot be specified when targeting ES5 or lower.": "ES5 이하를 대상으로 할 때는 'experimentalAsyncFunctions' 옵션을 지정할 수 없습니다.",
        "Enables experimental support for ES7 async functions.": "ES7 비동기 함수에 대해 실험적 지원을 사용합니다.",
        "Variable '{0}' implicitly has an '{1}' type.": "'{0}' 변수에는 암시적으로 '{1}' 형식이 포함됩니다.",
        "Parameter '{0}' implicitly has an '{1}' type.": "'{0}' 매개 변수에는 암시적으로 '{1}' 형식이 포함됩니다.",
        "Member '{0}' implicitly has an '{1}' type.": "'{0}' 멤버에는 암시적으로 '{1}' 형식이 포함됩니다.",
        "'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.": "대상에 구문 시그니처가 없는 'new' 식에는 암시적으로 'any' 형식이 포함됩니다.",
        "'{0}', which lacks return-type annotation, implicitly has an '{1}' return type.": "반환 형식 주석이 없는 '{0}'에는 암시적으로 '{1}' 반환 형식이 포함됩니다.",
        "Function expression, which lacks return-type annotation, implicitly has an '{0}' return type.": "반환 형식 주석이 없는 함수 식에는 암시적으로 '{0}' 반환 형식이 포함됩니다.",
        "Construct signature, which lacks return-type annotation, implicitly has an 'any' return type.": "반환 형식 주석이 없는 구문 시그니처에는 암시적으로 'any' 반환 형식이 포함됩니다.",
        "Property '{0}' implicitly has type 'any', because its 'set' accessor lacks a type annotation.": "'{0}' 속성에는 해당 'set' 접근자에 형식 주석이 없으므로 암시적으로 'any' 형식이 포함됩니다.",
        "Index signature of object type implicitly has an 'any' type.": "개체 형식의 인덱스 시그니처에는 암시적으로 'any' 형식이 포함됩니다.",
        "Object literal's property '{0}' implicitly has an '{1}' type.": "개체 리터럴의 '{0}' 속성에는 암시적으로 '{1}' 형식이 포함됩니다.",
        "Rest parameter '{0}' implicitly has an 'any[]' type.": "Rest 매개 변수 '{0}'에는 암시적으로 'any[]' 형식이 포함됩니다.",
        "Call signature, which lacks return-type annotation, implicitly has an 'any' return type.": "반환 형식 주석이 없는 호출 시그니처에는 암시적으로 'any' 반환 형식이 포함됩니다.",
        "'{0}' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.": "'{0}'은(는) 형식 주석이 없고 자체 이니셜라이저에서 직간접적으로 참조되므로 암시적으로 'any' 형식입니다.",
        "'{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.": "반환 형식 주석이 없고 반환 식 중 하나에서 직간접적으로 참조되므로 '{0}'에는 암시적으로 'any' 반환 형식이 포함됩니다.",
        "Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.": "반환 형식 주석이 없고 반환 식 중 하나에서 직간접적으로 참조되므로 함수에는 암시적으로 반환 형식 'any'가 포함됩니다.",
        "Generator implicitly has type '{0}' because it does not yield any values. Consider supplying a return type.": "생성기는 값을 생성하지 않으므로 암시적으로 '{0}' 형식입니다. 반환 형식을 제공하세요.",
        "JSX element implicitly has type 'any' because no interface 'JSX.{0}' exists": "'JSX.{0}' 인터페이스가 없으므로 JSX 요소는 암시적으로 'any' 형식입니다.",
        "You cannot rename this element.": "이 요소의 이름을 바꿀 수 없습니다.",
        "You cannot rename elements that are defined in the standard TypeScript library.": "표준 TypeScript 라이브러리에 정의된 요소의 이름을 바꿀 수 없습니다.",
        "'import ... =' can only be used in a .ts file.": "'import ... ='는 .ts 파일에서만 사용할 수 있습니다.",
        "'export=' can only be used in a .ts file.": "'export='는 .ts 파일에서만 사용할 수 있습니다.",
        "'type parameter declarations' can only be used in a .ts file.": "'type parameter declarations'는 .ts 파일에서만 사용할 수 있습니다.",
        "'implements clauses' can only be used in a .ts file.": "'implements clauses'는 .ts 파일에서만 사용할 수 있습니다.",
        "'interface declarations' can only be used in a .ts file.": "'interface declarations'는 .ts 파일에서만 사용할 수 있습니다.",
        "'module declarations' can only be used in a .ts file.": "'module declarations'는 .ts 파일에서만 사용할 수 있습니다.",
        "'type aliases' can only be used in a .ts file.": "'type aliases'는 .ts 파일에서만 사용할 수 있습니다.",
        "'{0}' can only be used in a .ts file.": "'{0}'은(는) .ts 파일에서만 사용할 수 있습니다.",
        "'types' can only be used in a .ts file.": "'types'는 .ts 파일에서만 사용할 수 있습니다.",
        "'type arguments' can only be used in a .ts file.": "'type arguments'는 .ts 파일에서만 사용할 수 있습니다.",
        "'parameter modifiers' can only be used in a .ts file.": "'parameter modifiers'는 .ts 파일에서만 사용할 수 있습니다.",
        "'property declarations' can only be used in a .ts file.": "'property declarations'는 .ts 파일에서만 사용할 수 있습니다.",
        "'enum declarations' can only be used in a .ts file.": "'enum declarations'는 .ts 파일에서만 사용할 수 있습니다.",
        "'type assertion expressions' can only be used in a .ts file.": "'type assertion expressions'는 .ts 파일에서만 사용할 수 있습니다.",
        "'decorators' can only be used in a .ts file.": "'decorators'는 .ts 파일에서만 사용할 수 있습니다.",
        "Only identifiers/qualified-names with optional type arguments are currently supported in a class 'extends' clauses.": "선택적 형식 인수가 포함된 식별자/정규화된 이름만 현재 클래스 'extends' 절에서 지원됩니다.",
        "'class' expressions are not currently supported.": "'class' 식은 현재 지원되지 않습니다.",
        "JSX attributes must only be assigned a non-empty 'expression'.": "JSX 특성에는 비어 있지 않은 '식'만 할당할 수 있습니다.",
        "JSX elements cannot have multiple attributes with the same name.": "JSX 요소에 이름이 같은 특성을 여러 개 사용할 수 없습니다.",
        "Expected corresponding JSX closing tag for '{0}'.": "'{0}'에 해당하는 JSX 닫는 태그가 필요합니다.",
        "JSX attribute expected.": "JSX 특성이 필요합니다.",
        "Cannot use JSX unless the '--jsx' flag is provided.": "'--jsx' 플래그를 제공하지 않으면 JSX를 사용할 수 없습니다.",
        "A constructor cannot contain a 'super' call when its class extends 'null'": "생성자는 해당 클래스가 'null'을 확장하는 경우 'super' 호출을 포함할 수 없습니다."
}