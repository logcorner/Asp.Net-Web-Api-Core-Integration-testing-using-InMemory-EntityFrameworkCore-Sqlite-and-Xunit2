{
        "Unterminated string literal.": "Littéral de chaîne inachevé.",
        "Identifier expected.": "Identificateur attendu.",
        "'{0}' expected.": "'{0}' attendu.",
        "A file cannot have a reference to itself.": "Un fichier ne peut pas contenir une référence à lui-même.",
        "Trailing comma not allowed.": "Virgule de fin non autorisée.",
        "'*/' expected.": "'*/' attendu.",
        "Unexpected token.": "Jeton inattendu.",
        "A rest parameter must be last in a parameter list.": "Un paramètre rest doit être le dernier dans une liste de paramètres.",
        "Parameter cannot have question mark and initializer.": "Un paramètre ne peut pas contenir de point d'interrogation et d'initialiseur.",
        "A required parameter cannot follow an optional parameter.": "Un paramètre obligatoire ne peut pas suivre un paramètre optionnel.",
        "An index signature cannot have a rest parameter.": "Une signature d'index ne peut pas avoir de paramètre rest.",
        "An index signature parameter cannot have an accessibility modifier.": "Un paramètre de signature d'index ne peut pas avoir de modificateur d'accessibilité.",
        "An index signature parameter cannot have a question mark.": "Un paramètre de signature d'index ne peut pas contenir de point d'interrogation.",
        "An index signature parameter cannot have an initializer.": "Un paramètre de signature d'index ne peut pas avoir d'initialiseur.",
        "An index signature must have a type annotation.": "Une signature d'index doit avoir une annotation de type.",
        "An index signature parameter must have a type annotation.": "Un paramètre de signature d'index doit avoir une annotation de type.",
        "An index signature parameter type must be 'string' or 'number'.": "Le type d'un paramètre de signature d'index doit être 'string' ou 'number'.",
        "Accessibility modifier already seen.": "Modificateur d'accessibilité déjà rencontré.",
        "'{0}' modifier must precede '{1}' modifier.": "Le modificateur '{0}' doit précéder le modificateur '{1}'.",
        "'{0}' modifier already seen.": "Modificateur '{0}' déjà rencontré.",
        "'{0}' modifier cannot appear on a class element.": "Le modificateur '{0}' ne peut pas apparaître dans un élément de classe.",
        "'super' must be followed by an argument list or member access.": "'super' doit être suivi d'une liste d'arguments ou d'un accesseur membre.",
        "Only ambient modules can use quoted names.": "Seuls les modules ambiants peuvent utiliser de noms entre guillemets.",
        "Statements are not allowed in ambient contexts.": "Les instructions ne sont pas autorisées dans les contextes ambiants.",
        "A 'declare' modifier cannot be used in an already ambient context.": "Un modificateur 'declare' ne peut pas être utilisé dans un contexte déjà ambiant.",
        "Initializers are not allowed in ambient contexts.": "Les initialiseurs ne sont pas autorisés dans les contextes ambiants.",
        "'{0}' modifier cannot be used in an ambient context.": "Le modificateur '{0}' ne peut pas être utilisé dans un contexte ambiant.",
        "'{0}' modifier cannot be used with a class declaration.": "Le modificateur '{0}' ne peut pas être utilisé avec une déclaration de classe.",
        "'{0}' modifier cannot be used here.": "Le modificateur '{0}' ne peut pas être utilisé ici.",
        "'{0}' modifier cannot appear on a data property.": "Le modificateur '{0}' ne peut pas apparaître dans une propriété de données.",
        "'{0}' modifier cannot appear on a module element.": "Le modificateur '{0}' ne peut pas apparaître dans un élément de module.",
        "A '{0}' modifier cannot be used with an interface declaration.": "Un modificateur '{0}' ne peut pas être utilisé avec une déclaration d'interface.",
        "A 'declare' modifier is required for a top level declaration in a .d.ts file.": "Un modificateur 'declare' est obligatoire pour une déclaration de niveau supérieur dans un fichier .d.ts.",
        "A rest parameter cannot be optional.": "Un paramètre rest ne peut pas être facultatif.",
        "A rest parameter cannot have an initializer.": "Un paramètre rest ne peut pas avoir d'initialiseur.",
        "A 'set' accessor must have exactly one parameter.": "Un accesseur 'set' doit avoir un seul paramètre.",
        "A 'set' accessor cannot have an optional parameter.": "Un accesseur 'set' ne peut pas avoir de paramètre optionnel.",
        "A 'set' accessor parameter cannot have an initializer.": "Un paramètre d'accesseur 'set' ne peut pas avoir d'initialiseur.",
        "A 'set' accessor cannot have rest parameter.": "Un accesseur 'set' ne peut pas avoir de paramètre rest.",
        "A 'get' accessor cannot have parameters.": "Un accesseur 'get' ne peut pas avoir de paramètres.",
        "Type '{0}' is not a valid async function return type.": "Le type '{0}' n'est pas un type de retour valide de fonction async.",
        "Accessors are only available when targeting ECMAScript 5 and higher.": "Les accesseurs sont disponibles uniquement lors du ciblage d'EcmaScript 5 et ultérieur.",
        "An async function or method must have a valid awaitable return type.": "Une fonction ou une méthode async doit avoir un type de retour valide pouvant être attendu.",
        "Operand for 'await' does not have a valid callable 'then' member.": "L'opérande de 'await' n'a pas de membre 'then' valide pouvant être appelé.",
        "Return expression in async function does not have a valid callable 'then' member.": "L'expression de retour de la fonction async n'a pas de membre 'then' valide pouvant être appelé.",
        "Expression body for async arrow function does not have a valid callable 'then' member.": "Le corps de l'expression pour la fonction arrow async n'a pas de membre 'then' valide pouvant être appelé.",
        "Enum member must have initializer.": "Un membre enum doit posséder un initialiseur.",
        "{0} is referenced directly or indirectly in the fulfillment callback of its own 'then' method.": "{0} est directement ou indirectement référencé dans le rappel d'exécution de sa propre méthode 'then'.",
        "An export assignment cannot be used in a namespace.": "Une affectation d'exportation ne peut pas être utilisée dans un espace de noms.",
        "Ambient enum elements can only have integer literal initializers.": "Les éléments d'enum ambiants peuvent uniquement avoir des initialiseurs de littéral d'entier.",
        "Unexpected token. A constructor, method, accessor, or property was expected.": "Jeton inattendu. Un constructeur, une méthode, un accesseur ou une propriété est attendu.",
        "A '{0}' modifier cannot be used with an import declaration.": "Un modificateur '{0}' ne peut pas être utilisé avec une déclaration d'importation.",
        "Invalid 'reference' directive syntax.": "Syntaxe de directive 'reference' non valide.",
        "Octal literals are not available when targeting ECMAScript 5 and higher.": "Les littéraux octaux ne sont pas disponibles lors du ciblage d'ECMAScript 5 et versions ultérieures.",
        "An accessor cannot be declared in an ambient context.": "Un accesseur ne peut pas être déclaré dans un contexte ambiant.",
        "'{0}' modifier cannot appear on a constructor declaration.": "Le modificateur '{0}' ne peut pas apparaître sur une déclaration de constructeur.",
        "'{0}' modifier cannot appear on a parameter.": "Le modificateur '{0}' ne peut pas apparaître dans un paramètre.",
        "Only a single variable declaration is allowed in a 'for...in' statement.": "Une seule déclaration de variable est autorisée dans une instruction 'for...in'.",
        "Type parameters cannot appear on a constructor declaration.": "Les paramètres de type ne peuvent pas apparaître sur une déclaration de constructeur.",
        "Type annotation cannot appear on a constructor declaration.": "Une annotation de type ne peut pas apparaître sur une déclaration de constructeur.",
        "An accessor cannot have type parameters.": "Un accesseur ne peut pas avoir de paramètres de type.",
        "A 'set' accessor cannot have a return type annotation.": "Un accesseur 'set' ne peut pas avoir d'annotation de type de retour.",
        "An index signature must have exactly one parameter.": "Une signature d'index doit avoir un seul paramètre.",
        "'{0}' list cannot be empty.": "La liste '{0}' ne peut pas être vide.",
        "Type parameter list cannot be empty.": "La liste des paramètres de type ne peut pas être vide.",
        "Type argument list cannot be empty.": "La liste des arguments de type ne peut pas être vide.",
        "Invalid use of '{0}' in strict mode.": "Utilisation non valide de '{0}' en mode strict.",
        "'with' statements are not allowed in strict mode.": "Les instructions 'with' ne sont pas autorisées en mode strict.",
        "'delete' cannot be called on an identifier in strict mode.": "'delete' ne peut pas être appelé dans un identificateur en mode strict.",
        "A 'continue' statement can only be used within an enclosing iteration statement.": "Une instruction 'continue' peut être utilisée uniquement dans une instruction d'itération englobante.",
        "A 'break' statement can only be used within an enclosing iteration or switch statement.": "Une instruction 'break' peut être utilisée uniquement dans une itération englobante ou une instruction switch.",
        "Jump target cannot cross function boundary.": "La cible du saut ne peut pas traverser une limite de fonction.",
        "A 'return' statement can only be used within a function body.": "Une instruction 'return' peut être utilisée uniquement dans un corps de fonction.",
        "Expression expected.": "Expression attendue.",
        "Type expected.": "Type attendu.",
        "A class member cannot be declared optional.": "Un membre de classe ne peut pas être déclaré facultatif.",
        "A 'default' clause cannot appear more than once in a 'switch' statement.": "Une clause 'default' ne peut pas figurer plusieurs fois dans une instruction 'switch'.",
        "Duplicate label '{0}'": "Étiquette '{0}' en double",
        "A 'continue' statement can only jump to a label of an enclosing iteration statement.": "Une instruction 'continue' peut accéder uniquement à une étiquette d'une instruction d'itération englobante.",
        "A 'break' statement can only jump to a label of an enclosing statement.": "Une instruction 'break' peut accéder uniquement à une étiquette d'une instruction englobante.",
        "An object literal cannot have multiple properties with the same name in strict mode.": "Un littéral d'objet ne peut pas avoir plusieurs propriétés du même nom en mode strict.",
        "An object literal cannot have multiple get/set accessors with the same name.": "Un littéral d'objet ne peut pas avoir plusieurs accesseurs get/set du même nom.",
        "An object literal cannot have property and accessor with the same name.": "Un littéral d'objet ne peut pas avoir une propriété et un accesseur du même nom.",
        "An export assignment cannot have modifiers.": "Une assignation d'exportation ne peut pas avoir de modificateurs.",
        "Octal literals are not allowed in strict mode.": "Les littéraux octaux ne sont pas autorisés en mode strict.",
        "A tuple type element list cannot be empty.": "Une liste d'éléments de type tuple ne peut pas être vide.",
        "Variable declaration list cannot be empty.": "La liste des déclarations de variable ne peut pas être vide.",
        "Digit expected.": "Chiffre attendu.",
        "Hexadecimal digit expected.": "Chiffre hexadécimal attendu.",
        "Unexpected end of text.": "Fin de texte inattendue.",
        "Invalid character.": "Caractère non valide.",
        "Declaration or statement expected.": "Déclaration ou instruction attendue.",
        "Statement expected.": "Instruction attendue.",
        "'case' or 'default' expected.": "'case' ou 'default' attendu.",
        "Property or signature expected.": "Propriété ou signature attendue.",
        "Enum member expected.": "Membre enum attendu.",
        "Variable declaration expected.": "Déclaration de variable attendue.",
        "Argument expression expected.": "Expression d'argument attendue.",
        "Property assignment expected.": "Assignation de propriété attendue.",
        "Expression or comma expected.": "Expression ou virgule attendue.",
        "Parameter declaration expected.": "Déclaration de paramètre attendue.",
        "Type parameter declaration expected.": "Déclaration du paramètre de type attendue.",
        "Type argument expected.": "Argument de type attendu.",
        "String literal expected.": "Littéral de chaîne attendu.",
        "Line break not permitted here.": "Saut de ligne non autorisé ici.",
        "'{' or ';' expected.": "'{' ou ';' attendu.",
        "Modifiers not permitted on index signature members.": "Modificateurs non autorisés sur les membres de signature d'index.",
        "Declaration expected.": "Déclaration attendue.",
        "Import declarations in a namespace cannot reference a module.": "Les déclarations d'importation dans un espace de noms ne peuvent pas référencer un module.",
        "Cannot compile modules unless the '--module' flag is provided.": "Impossible de compiler des modules tant que l'indicateur '--module' n'est pas spécifié.",
        "File name '{0}' differs from already included file name '{1}' only in casing": "Le nom de fichier '{0}' diffère du nom de fichier '{1}' déjà inclus uniquement par la casse",
        "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.": "'new T[]' ne peut pas être utilisé pour créer un tableau. Utilisez 'new Array<T>()' à la place.",
        "'const' declarations must be initialized": "Les déclarations 'const' doivent être initialisées.",
        "'const' declarations can only be declared inside a block.": "Les déclarations 'const' ne peuvent être déclarées que dans un bloc.",
        "'let' declarations can only be declared inside a block.": "Les déclarations 'let' ne peuvent être déclarées que dans un bloc.",
        "Unterminated template literal.": "Littéral de modèle inachevé.",
        "Unterminated regular expression literal.": "Littéral d'expression régulière inachevé.",
        "An object member cannot be declared optional.": "Un membre d'objet ne peut pas être déclaré comme étant facultatif.",
        "A 'yield' expression is only allowed in a generator body.": "Une expression 'yield' est autorisée uniquement dans le corps d'un générateur.",
        "Computed property names are not allowed in enums.": "Les noms de propriétés calculées ne sont pas autorisés dans les énumérations.",
        "A computed property name in an ambient context must directly refer to a built-in symbol.": "Un nom de propriété calculée dans un contexte ambiant doit faire directement référence à un symbole intégré.",
        "A computed property name in a class property declaration must directly refer to a built-in symbol.": "Un nom de propriété calculée dans une déclaration de propriété de classe doit faire directement référence à un symbole intégré.",
        "A computed property name in a method overload must directly refer to a built-in symbol.": "Un nom de propriété calculée dans une surcharge de méthode doit faire directement référence à un symbole intégré.",
        "A computed property name in an interface must directly refer to a built-in symbol.": "Un nom de propriété calculée dans une interface doit faire directement référence à un symbole intégré.",
        "A computed property name in a type literal must directly refer to a built-in symbol.": "Un nom de propriété calculée dans un littéral de type doit faire directement référence à un symbole intégré.",
        "A comma expression is not allowed in a computed property name.": "Une expression avec virgule n'est pas autorisée dans un nom de propriété calculée.",
        "'extends' clause already seen.": "Clause 'extends' déjà rencontrée.",
        "'extends' clause must precede 'implements' clause.": "La clause 'extends' doit précéder la clause 'implements'.",
        "Classes can only extend a single class.": "Les classes ne peuvent étendre qu'une seule classe.",
        "'implements' clause already seen.": "Clause 'implements' déjà rencontrée.",
        "Interface declaration cannot have 'implements' clause.": "Une déclaration d'interface ne peut pas avoir de clause 'implements'.",
        "Binary digit expected.": "Chiffre binaire attendu.",
        "Octal digit expected.": "Chiffre octal attendu.",
        "Unexpected token. '{' expected.": "Jeton inattendu. '{' est attendu.",
        "Property destructuring pattern expected.": "Modèle de déstructuration de propriété attendu.",
        "Array element destructuring pattern expected.": "Modèle de déstructuration d'élément de tableau attendu.",
        "A destructuring declaration must have an initializer.": "Une déclaration de déstructuration doit avoir un initialiseur.",
        "An implementation cannot be declared in ambient contexts.": "Une implémentation ne peut pas être déclarée dans des contextes ambiants.",
        "Modifiers cannot appear here.": "Les modificateurs ne peuvent pas apparaître ici.",
        "Merge conflict marker encountered.": "Marqueur de conflit de fusion rencontré.",
        "A rest element cannot have an initializer.": "Un élément rest ne peut pas avoir d'initialiseur.",
        "A parameter property may not be a binding pattern.": "Une propriété de paramètre ne peut pas être un modèle de liaison.",
        "Only a single variable declaration is allowed in a 'for...of' statement.": "Seule une déclaration de variable unique est autorisée dans une instruction 'for...of'.",
        "The variable declaration of a 'for...in' statement cannot have an initializer.": "La déclaration de variable d'une instruction 'for...in' ne peut pas avoir d'initialiseur.",
        "The variable declaration of a 'for...of' statement cannot have an initializer.": "La déclaration de variable d'une instruction 'for...of' ne peut pas avoir d'initialiseur.",
        "An import declaration cannot have modifiers.": "Une déclaration d'importation ne peut pas avoir de modificateurs.",
        "Module '{0}' has no default export.": "Le module '{0}' n'a pas d'exportation par défaut.",
        "An export declaration cannot have modifiers.": "Une déclaration d'exportation ne peut pas avoir de modificateurs.",
        "Export declarations are not permitted in a namespace.": "Les déclarations d'exportation ne sont pas autorisées dans un espace de noms.",
        "Catch clause variable name must be an identifier.": "Une variable de clause catch ne peut pas être un identificateur.",
        "Catch clause variable cannot have a type annotation.": "Une variable de clause catch ne peut pas avoir d'annotation de type.",
        "Catch clause variable cannot have an initializer.": "Une variable de clause catch ne peut pas avoir d'initialiseur.",
        "An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.": "Une valeur d'échappement Unicode étendue doit être comprise entre 0x0 et 0x10FFFF inclus.",
        "Unterminated Unicode escape sequence.": "Séquence d'échappement Unicode non terminée.",
        "Line terminator not permitted before arrow.": "Marque de fin de ligne non autorisée devant une flèche.",
        "Import assignment cannot be used when targeting ECMAScript 6 or higher. Consider using 'import * as ns from \"mod\"', 'import {a} from \"mod\"' or 'import d from \"mod\"' instead.": "L'assignation d'importation ne peut pas être utilisée quand ECMAScript 6 ou version supérieure est ciblé. Utilisez plutôt 'import * as ns from \"mod\"', 'import {a} from \"mod\"' ou 'import d from \"mod\"'.",
        "Export assignment cannot be used when targeting ECMAScript 6 or higher. Consider using 'export default' instead.": "L'assignation d'exportation ne peut pas être utilisée quand ECMAScript 6 ou version supérieure est ciblé. Utilisez plutôt 'export default'.",
        "Cannot compile modules into 'commonjs', 'amd', 'system' or 'umd' when targeting 'ES6' or higher.": "Impossible de compiler des modules dans 'commonjs', 'amd', 'system' ou 'umd' lors d'un ciblage de 'ES6' ou supérieur.",
        "Decorators are only available when targeting ECMAScript 5 and higher.": "Les Decorators sont disponibles uniquement quand ECMAScript 5 et version supérieure est ciblé.",
        "Decorators are not valid here.": "Les Decorators ne sont pas valides ici.",
        "Decorators cannot be applied to multiple get/set accessors of the same name.": "Les Decorators ne peuvent pas être appliqués à plusieurs accesseurs get/set du même nom.",
        "Cannot compile namespaces when the '--isolatedModules' flag is provided.": "Impossible de compiler des espaces de noms quand l'indicateur '--isolatedModules' est spécifié.",
        "Ambient const enums are not allowed when the '--isolatedModules' flag is provided.": "Les énumérations const ambiantes ne sont pas autorisées quand l'indicateur '--isolatedModules' est spécifié.",
        "Invalid use of '{0}'. Class definitions are automatically in strict mode.": "Utilisation non valide de '{0}'. Les définitions de classe sont automatiquement en mode strict.",
        "A class declaration without the 'default' modifier must have a name": "Une déclaration de classe sans modificateur 'default' doit porter un nom.",
        "Identifier expected. '{0}' is a reserved word in strict mode": "Identificateur attendu. '{0}' est un mot réservé en mode strict.",
        "Identifier expected. '{0}' is a reserved word in strict mode. Class definitions are automatically in strict mode.": "Type attendu. '{0}' est un mot réservé en mode strict. Les définitions de classe sont automatiquement en mode strict.",
        "Identifier expected. '{0}' is a reserved word in strict mode. Modules are automatically in strict mode.": "Identificateur attendu. '{0}' est un mot réservé en mode strict. Les modules sont automatiquement en mode strict.",
        "Invalid use of '{0}'. Modules are automatically in strict mode.": "Utilisation non valide de '{0}'. Les modules sont automatiquement en mode strict.",
        "Export assignment is not supported when '--module' flag is 'system'.": "L'affectation d'exportation n'est pas prise en charge quand l'indicateur '--module' est 'system'.",
        "Experimental support for decorators is a feature that is subject to change in a future release. Specify '--experimentalDecorators' to remove this warning.": "La prise en charge expérimentale pour les décorateurs est une fonctionnalité sujette à modification dans une édition future. Spécifiez '--experimentalDecorators' pour supprimer cet avertissement.",
        "Generators are only available when targeting ECMAScript 6 or higher.": "Les générateurs sont disponibles uniquement quand ECMAScript 6 ou version supérieure est ciblé.",
        "Generators are not allowed in an ambient context.": "Les générateurs ne sont pas autorisés dans un contexte ambiant.",
        "An overload signature cannot be declared as a generator.": "Une signature de surcharge ne peut pas être déclarée en tant que générateur.",
        "'{0}' tag already specified.": "La balise '{0}' est déjà spécifiée.",
        "Signature '{0}' must have a type predicate.": "La signature '{0}' doit avoir un prédicat de type.",
        "Cannot find parameter '{0}'.": "Paramètre '{0}' introuvable.",
        "Type predicate '{0}' is not assignable to '{1}'.": "Le prédicat de type '{0}' n'est pas attribuable à '{1}'.",
        "Parameter '{0}' is not in the same position as parameter '{1}'.": "Le paramètre '{0}' n'est pas à la même position que le paramètre '{1}'.",
        "A type predicate is only allowed in return type position for functions and methods.": "Un prédicat de type est autorisé uniquement dans une position de type de retour pour les fonctions et les méthodes.",
        "A type predicate cannot reference a rest parameter.": "Un prédicat de type ne peut pas référencer un paramètre rest.",
        "A type predicate cannot reference element '{0}' in a binding pattern.": "Un prédicat de type ne peut pas référencer un élément '{0}' dans un modèle de liaison.",
        "An export assignment can only be used in a module.": "Une attribution d'exportation peut uniquement être utilisée dans un module.",
        "An import declaration can only be used in a namespace or module.": "Une déclaration d'importation peut uniquement être utilisée dans un espace de noms ou un module.",
        "An export declaration can only be used in a module.": "Une déclaration d'exportation peut uniquement être utilisée dans un module.",
        "An ambient module declaration is only allowed at the top level in a file.": "Une déclaration de module ambiant est uniquement autorisée au niveau supérieur dans un fichier.",
        "A namespace declaration is only allowed in a namespace or module.": "Une déclaration d'espace de noms est autorisée uniquement dans un espace de noms ou un module.",
        "Experimental support for async functions is a feature that is subject to change in a future release. Specify '--experimentalAsyncFunctions' to remove this warning.": "La prise en charge expérimentale des fonctions async est une fonctionnalité susceptible d'être changée dans une prochaine version. Spécifiez '--experimentalAsyncFunctions' pour supprimer cet avertissement.",
        "'with' statements are not allowed in an async function block.": "Les instructions 'with' ne sont pas autorisées dans un bloc de fonctions async.",
        "'await' expression is only allowed within an async function.": "L'expression 'await' est autorisée uniquement dans une fonction async.",
        "Async functions are only available when targeting ECMAScript 6 and higher.": "Les fonctions async sont uniquement disponibles quand ECMAScript 6 ou version supérieure est ciblé.",
        "The return type of a property decorator function must be either 'void' or 'any'.": "Le type de retour d'une fonction decorator de propriété doit être 'void' ou 'any'.",
        "The return type of a parameter decorator function must be either 'void' or 'any'.": "Le type de retour d'une fonction decorator de paramètre doit être 'void' ou 'any'.",
        "Unable to resolve signature of class decorator when called as an expression.": "Impossible de résoudre la signature d'un decorator de classe quand il est appelé en tant qu'expression.",
        "Unable to resolve signature of parameter decorator when called as an expression.": "Impossible de résoudre la signature d'un decorator de paramètre quand il est appelé en tant qu'expression.",
        "Unable to resolve signature of property decorator when called as an expression.": "Impossible de résoudre la signature d'un decorator de propriété quand il est appelé en tant qu'expression.",
        "Unable to resolve signature of method decorator when called as an expression.": "Impossible de résoudre la signature d'un decorator de méthode quand il est appelé en tant qu'expression.",
        "'abstract' modifier can only appear on a class or method declaration.": "Le modificateur 'abstract' peut apparaître uniquement sur une déclaration de classe ou de méthode.",
        "'{0}' modifier cannot be used with '{1}' modifier.": "Le modificateur '{0}' ne peut pas être utilisé avec le modificateur '{1}'.",
        "Abstract methods can only appear within an abstract class.": "Les méthodes abstraites peuvent uniquement apparaître dans une classe abstraite.",
        "Method '{0}' cannot have an implementation because it is marked abstract.": "La méthode '{0}' ne peut pas avoir d'implémentation, car elle est marquée comme étant abstraite.",
        "Duplicate identifier '{0}'.": "Identificateur '{0}' en double.",
        "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.": "L'initialiseur de la variable membre d'instance '{0}' ne peut pas faire référence à l'identificateur '{1}' déclaré dans le constructeur.",
        "Static members cannot reference class type parameters.": "Les membres statiques ne peuvent pas faire référence à des paramètres de type de classe.",
        "Circular definition of import alias '{0}'.": "Définition circulaire de l'alias d'importation '{0}'.",
        "Cannot find name '{0}'.": "Le nom '{0}' est introuvable.",
        "Module '{0}' has no exported member '{1}'.": "Le module '{0}' n'a aucun membre exporté '{1}'.",
        "File '{0}' is not a module.": "Le fichier '{0}' n'est pas un module.",
        "Cannot find module '{0}'.": "Le module '{0}' est introuvable.",
        "An export assignment cannot be used in a module with other exported elements.": "Une assignation d'exportation ne peut pas être utilisée dans un module comportant d'autres éléments exportés.",
        "Type '{0}' recursively references itself as a base type.": "Le type '{0}' fait référence à lui-même de manière récursive en tant que type de base.",
        "A class may only extend another class.": "Une classe peut uniquement étendre une autre classe.",
        "An interface may only extend a class or another interface.": "Une interface peut uniquement étendre une classe ou une autre interface.",
        "Constraint of a type parameter cannot reference any type parameter from the same type parameter list.": "La contrainte d'un paramètre de type ne peut pas faire référence à un paramètre de type de la même liste de paramètres de type.",
        "Generic type '{0}' requires {1} type argument(s).": "Le type générique '{0}' requiert {1} arguments de type.",
        "Type '{0}' is not generic.": "Le type '{0}' n'est pas générique.",
        "Global type '{0}' must be a class or interface type.": "Le type global '{0}' doit être un type de classe ou d'interface.",
        "Global type '{0}' must have {1} type parameter(s).": "Le type global '{0}' doit avoir {1} paramètre(s) de type.",
        "Cannot find global type '{0}'.": "Le type global '{0}' est introuvable.",
        "Named property '{0}' of types '{1}' and '{2}' are not identical.": "La propriété nommée '{0}' des types '{1}' et '{2}' n'est pas identique.",
        "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}'.": "L'interface '{0}' ne peut pas étendre simultanément les types '{1}' et '{2}'.",
        "Excessive stack depth comparing types '{0}' and '{1}'.": "Profondeur excessive de la pile pour la comparaison des types '{0}' et '{1}'.",
        "Type '{0}' is not assignable to type '{1}'.": "Le type '{0}' n'est pas attribuable au type '{1}'.",
        "Property '{0}' is missing in type '{1}'.": "La propriété '{0}' est manquante dans le type '{1}'.",
        "Property '{0}' is private in type '{1}' but not in type '{2}'.": "La propriété '{0}' est privée dans le type '{1}' mais pas dans le type '{2}'.",
        "Types of property '{0}' are incompatible.": "Les types de la propriété '{0}' sont incompatibles.",
        "Property '{0}' is optional in type '{1}' but required in type '{2}'.": "La propriété '{0}' est facultative dans le type '{1}' mais obligatoire dans le type '{2}'.",
        "Types of parameters '{0}' and '{1}' are incompatible.": "Les types des paramètres '{0}' et '{1}' sont incompatibles.",
        "Index signature is missing in type '{0}'.": "Signature d'index manquante dans le type '{0}'.",
        "Index signatures are incompatible.": "Les signatures d'index sont incompatibles.",
        "'this' cannot be referenced in a module or namespace body.": "'this' ne peut pas être référencé dans le corps d'un module ou d'un espace de noms.",
        "'this' cannot be referenced in current location.": "'this' ne peut pas être référencé dans l'emplacement actuel.",
        "'this' cannot be referenced in constructor arguments.": "'this' ne peut pas être référencé dans les arguments de constructeur.",
        "'this' cannot be referenced in a static property initializer.": "'this' ne peut pas être référencé dans un initialiseur de propriété statique.",
        "'super' can only be referenced in a derived class.": "'super' ne peut être référencé que dans une classe dérivée.",
        "'super' cannot be referenced in constructor arguments.": "'super' ne peut pas être référencé dans des arguments de constructeur.",
        "Super calls are not permitted outside constructors or in nested functions inside constructors.": "Les appels de 'super' ne sont pas autorisés hors des constructeurs ou dans des fonctions imbriquées dans des constructeurs.",
        "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.": "L'accès aux propriétés 'super' est autorisé uniquement dans un constructeur, une fonction membre ou un accesseur membre d'une classe dérivée.",
        "Property '{0}' does not exist on type '{1}'.": "La propriété '{0}' n'existe pas sur le type '{1}'.",
        "Only public and protected methods of the base class are accessible via the 'super' keyword.": "Seules des méthodes publiques et protégées de la classe de base sont accessibles via le mot clé 'super'.",
        "Property '{0}' is private and only accessible within class '{1}'.": "La propriété '{0}' est privée et uniquement accessible dans la classe '{1}'.",
        "An index expression argument must be of type 'string', 'number', 'symbol, or 'any'.": "Un argument d'expression d'index doit être de type 'string', 'number', 'symbol' ou 'any'.",
        "Type '{0}' does not satisfy the constraint '{1}'.": "Le type '{0}' ne satisfait pas la contrainte '{1}'.",
        "Argument of type '{0}' is not assignable to parameter of type '{1}'.": "L'argument de type '{0}' n'est pas attribuable au paramètre de type '{1}'.",
        "Supplied parameters do not match any signature of call target.": "Les paramètres fournis ne correspondent à aucune signature de la cible de l'appel.",
        "Untyped function calls may not accept type arguments.": "Les appels de fonctions non typées ne peuvent pas accepter d'arguments de type.",
        "Value of type '{0}' is not callable. Did you mean to include 'new'?": "La valeur de type '{0}' ne peut pas être appelée. Voulez-vous inclure 'new' ?",
        "Cannot invoke an expression whose type lacks a call signature.": "Impossible d'appeler une expression dont le type ne possède pas de signature d'appel.",
        "Only a void function can be called with the 'new' keyword.": "Seule une fonction void peut être appelée avec le mot clé 'new'.",
        "Cannot use 'new' with an expression whose type lacks a call or construct signature.": "Impossible d'utiliser 'new' avec une expression dont le type ne possède pas de signature d'appel ou de construction.",
        "Neither type '{0}' nor type '{1}' is assignable to the other.": "Le type '{0}' n'est pas assignable au type '{1}', et inversement.",
        "Object literal may only specify known properties, and '{0}' does not exist in type '{1}'.": "Un littéral d'objet peut uniquement spécifier des propriétés connues, et '{0}' n'existe pas dans le type '{1}'.",
        "No best common type exists among return expressions.": "Il n'existe aucun meilleur type commun parmi les expressions de retour.",
        "A function whose declared type is neither 'void' nor 'any' must return a value or consist of a single 'throw' statement.": "Une fonction dont le type déclaré n'est ni 'void', ni 'any', doit retourner une valeur ou comporter une seule instruction 'throw'.",
        "An arithmetic operand must be of type 'any', 'number' or an enum type.": "Un opérande arithmétique doit être de type 'any', 'number' ou un type enum.",
        "The operand of an increment or decrement operator must be a variable, property or indexer.": "L'opérande d'un opérateur d'incrémentation ou de décrémentation doit être une variable, une propriété ou un indexeur.",
        "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.": "La partie gauche d'une expression 'instanceof' doit être de type 'any', un type d'objet ou un paramètre de type.",
        "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.": "La partie droite d'une expression 'instanceof' doit être de type 'any' ou d'un type assignable au type d'interface 'Function'.",
        "The left-hand side of an 'in' expression must be of type 'any', 'string', 'number', or 'symbol'.": "La partie gauche d'une expression 'in' doit être de type 'any', 'string', 'number' ou 'symbol'.",
        "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter": "La partie droite d'une expression 'in' doit être de type 'any', un type d'objet ou un paramètre de type",
        "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "La partie gauche d'une opération arithmétique doit être de type 'any', 'number' ou un type enum.",
        "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "La partie droite d'une opération arithmétique doit être de type 'any', 'number' ou un type enum.",
        "Invalid left-hand side of assignment expression.": "Partie gauche de l'expression d'assignation non valide.",
        "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": "L'opérateur '{0}' ne peut pas être appliqué aux types '{1}' et '{2}'.",
        "Type parameter name cannot be '{0}'": "Le nom du paramètre de type ne peut pas être '{0}'",
        "A parameter property is only allowed in a constructor implementation.": "Une propriété de paramètre est uniquement autorisée dans une implémentation de constructeur.",
        "A rest parameter must be of an array type.": "Un paramètre rest doit être de type tableau.",
        "A parameter initializer is only allowed in a function or constructor implementation.": "Un initialiseur de paramètre est uniquement autorisé dans une implémentation de fonction ou de constructeur.",
        "Parameter '{0}' cannot be referenced in its initializer.": "Le paramètre '{0}' ne peut pas être référencé dans son initialiseur.",
        "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.": "L'initialiseur du paramètre '{0}' ne peut pas faire référence à l'identificateur '{1}' déclaré après lui.",
        "Duplicate string index signature.": "Signature d'index de chaîne dupliquée.",
        "Duplicate number index signature.": "Signature d'index de nombre dupliquée.",
        "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.": "Un appel de 'super' doit être la première instruction du constructeur lorsqu'une classe contient des propriétés initialisées ou possède des propriétés de paramètre.",
        "Constructors for derived classes must contain a 'super' call.": "Les constructeurs pour les classes dérivées doivent contenir un appel de 'super'.",
        "A 'get' accessor must return a value or consist of a single 'throw' statement.": "Un accesseur 'get' doit retourner une valeur ou comporter une seule instruction 'throw'.",
        "Getter and setter accessors do not agree in visibility.": "Les accesseurs Get et Set ne sont pas en accord sur la visibilité.",
        "'get' and 'set' accessor must have the same type.": "Les accesseurs 'get' et 'set' doivent avoir le même type.",
        "A signature with an implementation cannot use a string literal type.": "Une signature avec une implémentation ne peut pas utiliser de type de littéral de chaîne.",
        "Specialized overload signature is not assignable to any non-specialized signature.": "La signature de surcharge spécialisée n'est assignable à aucune signature non spécialisée.",
        "Overload signatures must all be exported or not exported.": "Les signatures de surcharge doivent toutes être exportées ou non exportées.",
        "Overload signatures must all be ambient or non-ambient.": "Les signatures de surcharge doivent toutes être ambiantes ou non ambiantes.",
        "Overload signatures must all be public, private or protected.": "Les signatures de surcharge doivent toutes être publiques, privées ou protégées.",
        "Overload signatures must all be optional or required.": "Les signatures de surcharge doivent toutes être facultatives ou requises.",
        "Function overload must be static.": "La surcharge de fonction doit être statique.",
        "Function overload must not be static.": "La surcharge de fonction ne doit pas être statique.",
        "Function implementation name must be '{0}'.": "Le nom de l'implémentation de fonction doit être '{0}'.",
        "Constructor implementation is missing.": "L'implémentation de constructeur est manquante.",
        "Function implementation is missing or not immediately following the declaration.": "L'implémentation de fonction est manquante ou ne suit pas immédiatement la déclaration.",
        "Multiple constructor implementations are not allowed.": "Les implémentations de plusieurs constructeurs ne sont pas autorisées.",
        "Duplicate function implementation.": "Implémentation de fonction en double.",
        "Overload signature is not compatible with function implementation.": "La signature de surcharge n'est pas compatible avec l'implémentation de fonction.",
        "Individual declarations in merged declaration '{0}' must be all exported or all local.": "Les déclarations individuelles de la déclaration fusionnée '{0}' doivent toutes être exportées ou locales.",
        "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.": "Identificateur dupliqué 'arguments'. Le compilateur utilise 'arguments' pour initialiser les paramètres rest.",
        "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.": "Identificateur dupliqué '_this'. Le compilateur utilise la déclaration de variable '_this' pour capturer la référence 'this'.",
        "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.": "Expression résolue en déclaration de variable '_this' et utilisée par le compilateur pour capturer la référence 'this'.",
        "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.": "Identificateur dupliqué '_super'. Le compilateur utilise '_super' pour capturer la référence de classe de base.",
        "Expression resolves to '_super' that compiler uses to capture base class reference.": "Expression résolue en '_super' et utilisée par le compilateur pour capturer la référence de classe de base.",
        "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.": "Les déclarations de variable ultérieures doivent avoir le même type. La variable '{0}' doit être de type '{1}', mais elle a ici le type '{2}'.",
        "The left-hand side of a 'for...in' statement cannot use a type annotation.": "La partie gauche d'une instruction 'for...in' ne peut pas utiliser d'annotation de type.",
        "The left-hand side of a 'for...in' statement must be of type 'string' or 'any'.": "La partie gauche d'une instruction 'for...in' doit être de type 'string' ou 'any'.",
        "Invalid left-hand side in 'for...in' statement.": "Côté gauche de l'instruction 'for...in' non valide.",
        "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.": "La partie droite d'une instruction 'for...in' doit être de type 'any', un type d'objet ou un paramètre de type.",
        "Setters cannot return a value.": "Les méthodes setter ne peuvent pas retourner une valeur.",
        "Return type of constructor signature must be assignable to the instance type of the class": "Le type de retour de la signature du constructeur doit pouvoir être assigné au type d'instance de la classe",
        "All symbols within a 'with' block will be resolved to 'any'.": "Tous les symboles d'un bloc 'with' seront résolus en 'any'.",
        "Property '{0}' of type '{1}' is not assignable to string index type '{2}'.": "La propriété '{0}' de type '{1}' n'est pas assignable au type d'index de chaîne '{2}'.",
        "Property '{0}' of type '{1}' is not assignable to numeric index type '{2}'.": "La propriété '{0}' de type '{1}' n'est pas assignable au type d'index numérique '{2}'.",
        "Numeric index type '{0}' is not assignable to string index type '{1}'.": "Le type d'index numérique '{0}' n'est pas assignable au type d'index de chaîne '{1}'.",
        "Class name cannot be '{0}'": "Le nom de la classe ne peut pas être '{0}'",
        "Class '{0}' incorrectly extends base class '{1}'.": "La classe '{0}' étend de manière incorrecte la classe de base '{1}'.",
        "Class static side '{0}' incorrectly extends base class static side '{1}'.": "Le côté statique de la classe '{0}' étend de manière incorrecte le côté statique de la classe de base '{1}'.",
        "Type name '{0}' in extends clause does not reference constructor function for '{0}'.": "Le nom de type '{0}' dans la clause extends ne fait pas référence à la fonction de constructeur pour '{0}'.",
        "Class '{0}' incorrectly implements interface '{1}'.": "La classe '{0}' implémente de manière incorrecte l'interface '{1}'.",
        "A class may only implement another class or interface.": "Une classe peut uniquement implémenter une autre classe ou interface.",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.": "La classe '{0}' définit la fonction de membre d'instance '{1}', mais la classe étendue '{2}' le définit comme accesseur de membre d'instance.",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.": "La classe '{0}' définit la fonction de membre d'instance '{1}', mais la classe étendue '{2}' le définit comme propriété de membre d'instance.",
        "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.": "La classe '{0}' définit la propriété de membre d'instance '{1}', mais la classe étendue '{2}' le définit comme fonction de membre d'instance.",
        "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.": "La classe '{0}' définit l'accesseur de membre d'instance '{1}', mais la classe étendue '{2}' le définit comme fonction de membre d'instance.",
        "Interface name cannot be '{0}'": "Le nom de l'interface ne peut pas être '{0}'",
        "All declarations of an interface must have identical type parameters.": "Toutes les déclarations d'une interface doivent avoir des paramètres de type identiques.",
        "Interface '{0}' incorrectly extends interface '{1}'.": "L'interface '{0}' étend de manière incorrecte l'interface '{1}'.",
        "Enum name cannot be '{0}'": "Le nom d'enum ne peut pas être '{0}'",
        "In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.": "Dans un enum avec plusieurs déclarations, seule une déclaration peut omettre un initialiseur pour son premier élément d'enum.",
        "A namespace declaration cannot be in a different file from a class or function with which it is merged": "Une déclaration d'espace de noms ne peut pas se trouver dans un fichier autre que celui d'une classe ou d'une fonction avec laquelle elle est fusionnée",
        "A namespace declaration cannot be located prior to a class or function with which it is merged": "Une déclaration d'espace de noms ne peut pas se trouver avant une classe ou une fonction avec laquelle elle est fusionnée",
        "Ambient modules cannot be nested in other modules.": "Les modules ambiants ne peuvent pas être imbriqués dans d'autres modules.",
        "Ambient module declaration cannot specify relative module name.": "Une déclaration de module ambiant ne peut pas spécifier un nom de module relatif.",
        "Module '{0}' is hidden by a local declaration with the same name": "Le module '{0}' est masqué par une déclaration locale du même nom",
        "Import name cannot be '{0}'": "Le nom d'importation ne peut pas être '{0}'",
        "Import or export declaration in an ambient module declaration cannot reference module through relative module name.": "Une déclaration d'importation ou d'exportation dans une déclaration de module ambiant ne peut pas référencer un module via un nom de module relatif.",
        "Import declaration conflicts with local declaration of '{0}'": "La déclaration d'importation est en conflit avec la déclaration locale de '{0}'",
        "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module.": "Identificateur '{0}' en double. Le compilateur réserve le nom '{1}' dans l'étendue de plus haut niveau d'un module.",
        "Types have separate declarations of a private property '{0}'.": "Les types ont des déclarations distinctes d'une propriété privée '{0}'.",
        "Property '{0}' is protected but type '{1}' is not a class derived from '{2}'.": "La propriété '{0}' est protégée mais le type '{1}' n'est pas une classe dérivée de '{2}'.",
        "Property '{0}' is protected in type '{1}' but public in type '{2}'.": "La propriété '{0}' est protégée dans le type '{1}' mais publique dans le type '{2}'.",
        "Property '{0}' is protected and only accessible within class '{1}' and its subclasses.": "La propriété '{0}' est protégée et uniquement accessible dans la classe '{1}' et ses sous-classes.",
        "Property '{0}' is protected and only accessible through an instance of class '{1}'.": "La propriété '{0}' est protégée et uniquement accessible via une instance de la classe '{1}'.",
        "The '{0}' operator is not allowed for boolean types. Consider using '{1}' instead.": "L'opérateur '{0}' n'est pas autorisé pour les types booléens. Utilisez '{1}' à la place.",
        "Block-scoped variable '{0}' used before its declaration.": "Variable de portée de bloc '{0}' utilisée avant sa déclaration.",
        "The operand of an increment or decrement operator cannot be a constant.": "L'opérande d'un opérateur d'incrémentation ou de décrémentation ne peut pas être une constante.",
        "Left-hand side of assignment expression cannot be a constant.": "La partie gauche de l'expression d'assignation ne peut pas être une constante.",
        "Cannot redeclare block-scoped variable '{0}'.": "Impossible de redéclarer la variable de portée de bloc '{0}'.",
        "An enum member cannot have a numeric name.": "Un membre enum ne peut pas avoir un nom numérique.",
        "The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.": "L'argument de type pour le paramètre de type '{0}' ne peut pas être déduit à partir de l'utilisation. Spécifiez les arguments de type explicitement.",
        "Type argument candidate '{1}' is not a valid type argument because it is not a supertype of candidate '{0}'.": "Le candidat de l'argument de type '{1}' n'est pas un argument de type valide, car il ne s'agit pas d'un supertype du candidat '{0}'.",
        "Type alias '{0}' circularly references itself.": "L'alias de type '{0}' fait référence à lui-même de manière circulaire.",
        "Type alias name cannot be '{0}'": "Le nom de l'alias de type ne peut pas être '{0}'",
        "An AMD module cannot have multiple name assignments.": "Un module AMD ne peut pas avoir plusieurs affectations de nom.",
        "Type '{0}' has no property '{1}' and no string index signature.": "Le type '{0}' n'a pas de propriété '{1}' ni de signature d'index de chaîne.",
        "Type '{0}' has no property '{1}'.": "Le type '{0}' n'a pas de propriété '{1}'.",
        "Type '{0}' is not an array type.": "Le type '{0}' n'est pas un type de tableau.",
        "A rest element must be last in an array destructuring pattern": "Un élément rest doit être le dernier dans un modèle de déstructuration de tableau",
        "A binding pattern parameter cannot be optional in an implementation signature.": "Un paramètre de modèle de liaison ne peut pas être facultatif dans une signature d'implémentation.",
        "A computed property name must be of type 'string', 'number', 'symbol', or 'any'.": "Un nom de propriété calculée doit être de type 'string', 'number', 'symbol' ou 'any'.",
        "'this' cannot be referenced in a computed property name.": "'this' ne peut pas être référencé dans un nom de propriété calculée.",
        "'super' cannot be referenced in a computed property name.": "'super' ne peut pas être référencé dans un nom de propriété calculée.",
        "A computed property name cannot reference a type parameter from its containing type.": "Un nom de propriété calculée ne peut pas faire référence à un paramètre de type à partir de son type conteneur.",
        "Cannot find global value '{0}'.": "Valeur globale '{0}' introuvable.",
        "The '{0}' operator cannot be applied to type 'symbol'.": "L'opérateur '{0}' ne peut pas être appliqué au type 'symbol'.",
        "'Symbol' reference does not refer to the global Symbol constructor object.": "La référence 'Symbol' ne fait pas référence à l'objet constructeur Symbol global.",
        "A computed property name of the form '{0}' must be of type 'symbol'.": "Un nom de propriété calculée de la forme '{0}' doit être de type 'symbol'.",
        "Spread operator in 'new' expressions is only available when targeting ECMAScript 5 and higher.": "L'opérateur spread dans les expressions 'new' est disponible uniquement quand ECMAScript 5 ou version supérieure est ciblé.",
        "Enum declarations must all be const or non-const.": "Les déclarations d'enum doivent toutes être const ou non const.",
        "In 'const' enum declarations member initializer must be constant expression.": "Dans les déclarations d'enum 'const', l'initialiseur de membre doit être une expression constante.",
        "'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment.": "Les enums 'const' ne peuvent être utilisés que dans les expressions d'accès à une propriété ou un index, ou dans la partie droite d'une déclaration d'importation ou d'une assignation d'exportation.",
        "A const enum member can only be accessed using a string literal.": "Un membre de l'énumération const ne peut être accessible qu'à l'aide d'un littéral de chaîne.",
        "'const' enum member initializer was evaluated to a non-finite value.": "L'initialiseur de membre enum 'const' donne une valeur non finie.",
        "'const' enum member initializer was evaluated to disallowed value 'NaN'.": "L'initialiseur de membre enum 'const' donne une valeur non autorisée 'NaN'.",
        "Property '{0}' does not exist on 'const' enum '{1}'.": "La propriété '{0}' n'existe pas sur l'énumération 'const' '{1}'.",
        "'let' is not allowed to be used as a name in 'let' or 'const' declarations.": "'let' ne peut pas être utilisé comme nom dans les déclarations 'let' ou 'const'.",
        "Cannot initialize outer scoped variable '{0}' in the same scope as block scoped declaration '{1}'.": "Impossible d'initialiser la variable de portée externe '{0}' dans la même portée que celle de la déclaration de portée de bloc '{1}'.",
        "The left-hand side of a 'for...of' statement cannot use a type annotation.": "La partie gauche d'une instruction 'for...of' ne peut pas utiliser d'annotation de type.",
        "Export declaration conflicts with exported declaration of '{0}'": "La déclaration d'exportation est en conflit avec la déclaration exportée de '{0}'",
        "The left-hand side of a 'for...of' statement cannot be a previously defined constant.": "La partie gauche d'une instruction 'for...of' ne peut pas être une constante déjà définie.",
        "The left-hand side of a 'for...in' statement cannot be a previously defined constant.": "La partie gauche d'une instruction 'for...in' ne peut pas être une constante déjà définie.",
        "Invalid left-hand side in 'for...of' statement.": "Partie gauche non valide dans l'instruction 'for...of'.",
        "Type must have a '[Symbol.iterator]()' method that returns an iterator.": "Le type doit comporter une méthode '[Symbol.iterator]()' qui retourne un itérateur.",
        "An iterator must have a 'next()' method.": "Un itérateur doit comporter une méthode 'next()'.",
        "The type returned by the 'next()' method of an iterator must have a 'value' property.": "Le type retourné par la méthode 'next()' d'un itérateur doit avoir une propriété 'value'.",
        "The left-hand side of a 'for...in' statement cannot be a destructuring pattern.": "La partie gauche d'une instruction 'for...in' ne peut pas être un modèle de déstructuration.",
        "Cannot redeclare identifier '{0}' in catch clause": "Impossible de redéclarer l'identificateur '{0}' dans la clause catch",
        "Tuple type '{0}' with length '{1}' cannot be assigned to tuple with length '{2}'.": "Le type tuple '{0}' de longueur '{1}' ne peut pas être assigné à un tuple de longueur '{2}'.",
        "Using a string in a 'for...of' statement is only supported in ECMAScript 5 and higher.": "L'utilisation d'une chaîne dans une instruction 'for...of' est prise en charge uniquement dans ECMAScript 5 et version supérieure.",
        "Type '{0}' is not an array type or a string type.": "Le type '{0}' n'est pas un type de tableau ou un type de chaîne.",
        "The 'arguments' object cannot be referenced in an arrow function in ES3 and ES5. Consider using a standard function expression.": "L'objet 'arguments' ne peut pas être référencé dans une fonction arrow dans ES3 et ES5. Envisagez d'utiliser une expression de fonction standard.",
        "Module '{0}' resolves to a non-module entity and cannot be imported using this construct.": "Le module '{0}' se résout en une entité non-module et ne peut pas être importé à l'aide de cette construction.",
        "Module '{0}' uses 'export =' and cannot be used with 'export *'.": "Le module '{0}' utilise 'export =' et ne peut pas être utilisé avec 'export *'.",
        "An interface can only extend an identifier/qualified-name with optional type arguments.": "Une interface peut uniquement étendre un identificateur/nom qualifié avec des arguments de type facultatifs.",
        "A class can only implement an identifier/qualified-name with optional type arguments.": "Une classe peut uniquement implémenter un identificateur/nom qualifié avec des arguments de type facultatifs.",
        "A rest element cannot contain a binding pattern.": "Un élément rest ne peut pas contenir de modèle de liaison.",
        "'{0}' is referenced directly or indirectly in its own type annotation.": "'{0}' est référencé directement ou indirectement dans sa propre annotation de type.",
        "Cannot find namespace '{0}'.": "L'espace de noms '{0}' est introuvable.",
        "No best common type exists among yield expressions.": "Aucun meilleur type commun n'existe parmi les expressions générées.",
        "A generator cannot have a 'void' type annotation.": "Un générateur ne peut pas avoir d'annotation de type 'void'.",
        "'{0}' is referenced directly or indirectly in its own base expression.": "'{0}' est directement ou indirectement référencé dans sa propre expression de base.",
        "Type '{0}' is not a constructor function type.": "Le type '{0}' n'est pas un type de fonction decorator.",
        "No base constructor has the specified number of type arguments.": "Aucun constructeur de base n'a le nombre spécifié d'arguments de type.",
        "Base constructor return type '{0}' is not a class or interface type.": "Le type de retour du constructeur de base '{0}' n'est pas un type de classe ou d'interface.",
        "Base constructors must all have the same return type.": "Les constructeurs de base doivent tous avoir le même type de retour.",
        "Cannot create an instance of the abstract class '{0}'.": "Impossible de créer une instance de la classe abstraite '{0}'.",
        "Overload signatures must all be abstract or not abstract.": "Les signatures de surcharge doivent toutes être abstraites ou non abstraites.",
        "Abstract method '{0}' in class '{1}' cannot be accessed via super expression.": "La méthode abstraite '{0}' de la classe '{1}' n'est pas accessible via l'expression super.",
        "Classes containing abstract methods must be marked abstract.": "Les classes contenant des méthodes abstraites doivent être marquées comme étant abstraites.",
        "Non-abstract class '{0}' does not implement inherited abstract member '{1}' from class '{2}'.": "La classe non abstraite '{0}' n'implémente pas le membre abstrait '{1}' hérité de la classe '{2}'.",
        "All declarations of an abstract method must be consecutive.": "Toutes les déclarations d'une méthode abstraite doivent être consécutives.",
        "Cannot assign an abstract constructor type to a non-abstract constructor type.": "Impossible d'attribuer un type de constructeur abstrait à un type de constructeur non abstrait.",
        "Only an ambient class can be merged with an interface.": "Seule une classe ambiante peut être fusionnée avec une interface.",
        "Duplicate identifier '{0}'. Compiler uses declaration '{1}' to support async functions.": "Identificateur '{0}' en double. Le compilateur utilise la déclaration '{1}' pour prendre en charge les fonctions async.",
        "Expression resolves to variable declaration '{0}' that compiler uses to support async functions.": "L'expression correspond à la déclaration de variable '{0}' que le compilateur utilise pour prendre en charge les fonctions async.",
        "The 'arguments' object cannot be referenced in an async arrow function. Consider using a standard async function expression.": "L'objet 'arguments' ne peut pas être référencé dans une fonction arrow async. Utilisez plutôt une expression de fonction async standard.",
        "'yield' expressions cannot be used in a parameter initializer.": "Les expressions 'yield' ne peuvent pas être utilisées dans un initialiseur de paramètre.",
        "'await' expressions cannot be used in a parameter initializer.": "Les expressions 'await' ne peuvent pas être utilisées dans un initialiseur de paramètre.",
        "JSX element attributes type '{0}' must be an object type.": "Le type '{0}' des attributs de l'élément JSX doit être un type d'objet.",
        "The return type of a JSX element constructor must return an object type.": "Le type de retour d'un constructeur d'éléments JSX doit retourner un type d'objet.",
        "JSX element implicitly has type 'any' because the global type 'JSX.Element' does not exist.": "L'élément JSX a implicitement le type 'any', car le type global 'JSX.Element' n'existe pas.",
        "Property '{0}' in type '{1}' is not assignable to type '{2}'": "La propriété '{0}' du type '{1}' n'est pas attribuable au type '{2}'",
        "JSX element type '{0}' does not have any construct or call signatures.": "Le type '{0}' de l'élément JSX n'a pas de signature de construction ou d'appel.",
        "JSX element type '{0}' is not a constructor function for JSX elements.": "Le type '{0}' de l'élément JSX n'est pas une fonction constructeur pour les éléments JSX.",
        "Property '{0}' of JSX spread attribute is not assignable to target property.": "La propriété '{0}' de l'attribut spread JSX n'est pas attribuable à la propriété cible.",
        "JSX element class does not support attributes because it does not have a '{0}' property": "La classe de l'élément JSX ne prend pas en charge les attributs, car elle n'a pas de propriété '{0}'",
        "The global type 'JSX.{0}' may not have more than one property": "Le type global 'JSX.{0}' n'a peut-être pas plusieurs propriétés",
        "Cannot emit namespaced JSX elements in React": "Impossible d'émettre des éléments JSX d'un espace de noms dans React",
        "A member initializer in a 'const' enum declaration cannot reference members declared after it, including members defined in other 'const' enums.": "Un initialiseur de membre dans une déclaration d'enum 'const' ne peut pas référencer les membres déclarés après lui, ni les membres définis dans d'autres enums 'const'.",
        "Merged declaration '{0}' cannot include a default export declaration. Consider adding a separate 'export default {0}' declaration instead.": "La déclaration fusionnée '{0}' ne peut pas inclure de déclaration d'exportation par défaut. Ajoutez une déclaration 'export default {0}' distincte à la place.",
        "Import declaration '{0}' is using private name '{1}'.": "La déclaration d'importation '{0}' utilise le nom privé '{1}'.",
        "Type parameter '{0}' of exported class has or is using private name '{1}'.": "Le paramètre de type '{0}' de la classe exportée possède ou utilise le nom privé '{1}'.",
        "Type parameter '{0}' of exported interface has or is using private name '{1}'.": "Le paramètre de type '{0}' de l'interface exportée possède ou utilise le nom privé '{1}'.",
        "Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.": "Le paramètre de type '{0}' de la signature de constructeur de l'interface exportée possède ou utilise le nom privé '{1}'.",
        "Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'.": "Le paramètre de type '{0}' de la signature d'appel de l'interface exportée possède ou utilise le nom privé '{1}'.",
        "Type parameter '{0}' of public static method from exported class has or is using private name '{1}'.": "Le paramètre de type '{0}' de la méthode statique publique de la classe exportée possède ou utilise le nom privé '{1}'.",
        "Type parameter '{0}' of public method from exported class has or is using private name '{1}'.": "Le paramètre de type '{0}' de la méthode publique de la classe exportée possède ou utilise le nom privé '{1}'.",
        "Type parameter '{0}' of method from exported interface has or is using private name '{1}'.": "Le paramètre de type '{0}' de la méthode de l'interface exportée possède ou utilise le nom privé '{1}'.",
        "Type parameter '{0}' of exported function has or is using private name '{1}'.": "Le paramètre de type '{0}' de la fonction exportée possède ou utilise le nom privé '{1}'.",
        "Implements clause of exported class '{0}' has or is using private name '{1}'.": "La clause implements de la classe exportée '{0}' possède ou utilise le nom privé '{1}'.",
        "Extends clause of exported class '{0}' has or is using private name '{1}'.": "La clause extends de la classe exportée '{0}' possède ou utilise le nom privé '{1}'.",
        "Extends clause of exported interface '{0}' has or is using private name '{1}'.": "La clause extends de l'interface exportée '{0}' possède ou utilise le nom privé '{1}'.",
        "Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named.": "La variable exportée '{0}' possède ou utilise le nom '{1}' du module externe {2} mais ne peut pas être nommée.",
        "Exported variable '{0}' has or is using name '{1}' from private module '{2}'.": "La variable exportée '{0}' possède ou utilise le nom '{1}' du module privé '{2}'.",
        "Exported variable '{0}' has or is using private name '{1}'.": "La variable exportée '{0}' possède ou utilise le nom privé '{1}'.",
        "Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.": "La propriété statique publique '{0}' de la classe exportée possède ou utilise le nom '{1}' du module externe {2} mais ne peut pas être nommée.",
        "Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'.": "La propriété statique publique '{0}' de la classe exportée possède ou utilise le nom '{1}' du module privé '{2}'.",
        "Public static property '{0}' of exported class has or is using private name '{1}'.": "La propriété statique publique '{0}' de la classe exportée possède ou utilise le type privé '{1}'.",
        "Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.": "La propriété publique '{0}' de la classe exportée possède ou utilise le nom '{1}' du module externe {2} mais ne peut pas être nommée.",
        "Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'.": "La propriété publique '{0}' de la classe exportée possède ou utilise le nom '{1}' du module privé '{2}'.",
        "Public property '{0}' of exported class has or is using private name '{1}'.": "La propriété publique '{0}' de la classe exportée possède ou utilise le type privé '{1}'.",
        "Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'.": "La propriété '{0}' de l'interface exportée possède ou utilise le nom '{1}' du module privé '{2}'.",
        "Property '{0}' of exported interface has or is using private name '{1}'.": "La propriété '{0}' de l'interface exportée possède ou utilise le nom privé '{1}'.",
        "Parameter '{0}' of public static property setter from exported class has or is using name '{1}' from private module '{2}'.": "Le paramètre '{0}' de la méthode setter d'une propriété statique publique de la classe exportée possède ou utilise le nom '{1}' du module privé '{2}'.",
        "Parameter '{0}' of public static property setter from exported class has or is using private name '{1}'.": "Le paramètre '{0}' de la méthode setter d'une propriété statique publique de la classe exportée possède ou utilise le nom privé '{1}'.",
        "Parameter '{0}' of public property setter from exported class has or is using name '{1}' from private module '{2}'.": "Le paramètre '{0}' de la méthode setter d'une propriété publique de la classe exportée possède ou utilise le nom '{1}' du module privé '{2}'.",
        "Parameter '{0}' of public property setter from exported class has or is using private name '{1}'.": "Le paramètre '{0}' de la méthode setter d'une propriété publique de la classe exportée possède ou utilise le nom privé '{1}'.",
        "Return type of public static property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.": "Le type de retour de l'accesseur Get de propriété statique publique de la classe exportée possède ou utilise le nom '{0}' du module externe {1} mais ne peut pas être nommé.",
        "Return type of public static property getter from exported class has or is using name '{0}' from private module '{1}'.": "Le type de retour de l'accesseur Get de propriété statique publique de la classe exportée possède ou utilise le nom '{0}' du module privé '{1}'.",
        "Return type of public static property getter from exported class has or is using private name '{0}'.": "Le type de retour de l'accesseur Get de propriété statique publique de la classe exportée possède ou utilise le nom privé '{0}'.",
        "Return type of public property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.": "Le type de retour de l'accesseur Get de propriété publique de la classe exportée possède ou utilise le nom '{0}' du module externe {1} mais ne peut pas être nommé.",
        "Return type of public property getter from exported class has or is using name '{0}' from private module '{1}'.": "Le type de retour de l'accesseur Get de propriété publique de la classe exportée possède ou utilise le nom '{0}' du module privé '{1}'.",
        "Return type of public property getter from exported class has or is using private name '{0}'.": "Le type de retour de l'accesseur Get de propriété publique de la classe exportée possède ou utilise le nom privé '{0}'.",
        "Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'.": "Le type de retour de la signature de constructeur de l'interface exportée possède ou utilise le nom '{0}' du module privé '{1}'.",
        "Return type of constructor signature from exported interface has or is using private name '{0}'.": "Le type de retour de la signature de constructeur de l'interface exportée possède ou utilise le nom privé '{0}'.",
        "Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'.": "Le type de retour de la signature d'appel de l'interface exportée possède ou utilise le nom '{0}' du module privé '{1}'.",
        "Return type of call signature from exported interface has or is using private name '{0}'.": "Le type de retour de la signature d'appel de l'interface exportée possède ou utilise le nom privé '{0}'.",
        "Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'.": "Le type de retour de la signature d'index de l'interface exportée possède ou utilise le nom '{0}' du module privé '{1}'.",
        "Return type of index signature from exported interface has or is using private name '{0}'.": "Le type de retour de la signature d'index de l'interface exportée possède ou utilise le nom privé '{0}'.",
        "Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named.": "Le type de retour de la méthode statique publique de la classe exportée possède ou utilise le nom '{0}' du module externe {1} mais ne peut pas être nommé.",
        "Return type of public static method from exported class has or is using name '{0}' from private module '{1}'.": "Le type de retour de la méthode statique publique de la classe exportée possède ou utilise le nom '{0}' du module privé '{1}'.",
        "Return type of public static method from exported class has or is using private name '{0}'.": "Le type de retour de la méthode statique publique de la classe exportée possède ou utilise le nom privé '{0}'.",
        "Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named.": "Le type de retour de la méthode publique de la classe exportée possède ou utilise le nom '{0}' du module externe {1} mais ne peut pas être nommé.",
        "Return type of public method from exported class has or is using name '{0}' from private module '{1}'.": "Le type de retour de la méthode publique de la classe exportée possède ou utilise le nom '{0}' du module privé '{1}'.",
        "Return type of public method from exported class has or is using private name '{0}'.": "Le type de retour de la méthode publique de la classe exportée possède ou utilise le nom privé '{0}'.",
        "Return type of method from exported interface has or is using name '{0}' from private module '{1}'.": "Le type de retour de la méthode de l'interface exportée possède ou utilise le nom '{0}' du module privé '{1}'.",
        "Return type of method from exported interface has or is using private name '{0}'.": "Le type de retour de la méthode de l'interface exportée possède ou utilise le nom privé '{0}'.",
        "Return type of exported function has or is using name '{0}' from external module {1} but cannot be named.": "Le type de retour de la fonction exportée possède ou utilise le nom '{0}' du module externe {1} mais ne peut pas être nommé.",
        "Return type of exported function has or is using name '{0}' from private module '{1}'.": "Le type de retour de la fonction exportée possède ou utilise le nom '{0}' du module privé '{1}'.",
        "Return type of exported function has or is using private name '{0}'.": "Le type de retour de la fonction exportée possède ou utilise le nom privé '{0}'.",
        "Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named.": "Le paramètre '{0}' du constructeur de la classe exportée possède ou utilise le nom '{1}' du module externe {2} mais ne peut pas être nommé.",
        "Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'.": "Le paramètre '{0}' du constructeur de la classe exportée possède ou utilise le nom '{1}' du module privé '{2}'.",
        "Parameter '{0}' of constructor from exported class has or is using private name '{1}'.": "Le paramètre '{0}' du constructeur de la classe exportée possède ou utilise le nom privé '{1}'.",
        "Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'.": "Le paramètre '{0}' de la signature de constructeur de l'interface exportée possède ou utilise le nom '{1}' du module privé '{2}'.",
        "Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.": "Le paramètre '{0}' de la signature de constructeur de l'interface exportée possède ou utilise le nom privé '{1}'.",
        "Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'.": "Le paramètre '{0}' de la signature d'appel de l'interface exportée possède ou utilise le nom '{1}' du module privé '{2}'.",
        "Parameter '{0}' of call signature from exported interface has or is using private name '{1}'.": "Le paramètre '{0}' de la signature d'appel de l'interface exportée possède ou utilise le nom privé '{1}'.",
        "Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named.": "Le paramètre '{0}' de la méthode statique publique de la classe exportée possède ou utilise le nom '{1}' du module externe {2} mais ne peut pas être nommé.",
        "Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'.": "Le paramètre '{0}' de la méthode statique publique de la classe exportée possède ou utilise le nom '{1}' du module privé '{2}'.",
        "Parameter '{0}' of public static method from exported class has or is using private name '{1}'.": "Le paramètre '{0}' de la méthode statique publique de la classe exportée possède ou utilise le nom privé '{1}'.",
        "Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named.": "Le paramètre '{0}' de la méthode publique de la classe exportée possède ou utilise le nom '{1}' du module externe {2} mais ne peut pas être nommé.",
        "Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'.": "Le paramètre '{0}' de la méthode publique de la classe exportée possède ou utilise le nom '{1}' du module privé '{2}'.",
        "Parameter '{0}' of public method from exported class has or is using private name '{1}'.": "Le paramètre '{0}' de la méthode publique de la classe exportée possède ou utilise le nom privé '{1}'.",
        "Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'.": "Le paramètre '{0}' de la méthode de l'interface exportée possède ou utilise le nom '{1}' du module privé '{2}'.",
        "Parameter '{0}' of method from exported interface has or is using private name '{1}'.": "Le paramètre '{0}' de la méthode de l'interface exportée possède ou utilise le nom privé '{1}'.",
        "Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named.": "Le paramètre '{0}' de la fonction exportée possède ou utilise le nom '{1}' du module externe {2} mais ne peut pas être nommé.",
        "Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'.": "Le paramètre '{0}' de la fonction exportée possède ou utilise le nom '{1}' du module privé '{2}'.",
        "Parameter '{0}' of exported function has or is using private name '{1}'.": "Le paramètre '{0}' de la fonction exportée possède ou utilise le nom privé '{1}'.",
        "Exported type alias '{0}' has or is using private name '{1}'.": "L'alias de type exporté '{0}' possède ou utilise le nom privé '{1}'.",
        "Default export of the module has or is using private name '{0}'.": "L'exportation par défaut du module a utilisé ou utilise le nom privé '{0}'.",
        "Loop contains block-scoped variable '{0}' referenced by a function in the loop. This is only supported in ECMAScript 6 or higher.": "Une boucle contient la variable '{0}' de portée de bloc référencée par une fonction dans la boucle. Cela est pris en charge uniquement dans ECMAScript 6 ou version supérieure.",
        "The current host does not support the '{0}' option.": "L'hôte actuel ne prend pas en charge l'option '{0}'.",
        "Cannot find the common subdirectory path for the input files.": "Impossible de trouver le chemin d'accès au sous-répertoire commun pour les fichiers d'entrée.",
        "Cannot read file '{0}': {1}": "Impossible de lire le fichier '{0}' : {1}",
        "Unsupported file encoding.": "Encodage de fichier non pris en charge.",
        "Failed to parse file '{0}': {1}.": "Échec de l'analyse du fichier '{0}' : {1}.",
        "Unknown compiler option '{0}'.": "Option de compilateur '{0}' inconnue.",
        "Compiler option '{0}' requires a value of type {1}.": "L'option de compilateur '{0}' requiert une valeur de type {1}.",
        "Could not write file '{0}': {1}": "Impossible d'écrire le fichier '{0}' : {1}",
        "Option 'mapRoot' cannot be specified without specifying 'sourceMap' option.": "L'option 'mapRoot' ne peut pas être spécifiée sans la spécification de l'option 'sourceMap'.",
        "Option 'sourceRoot' cannot be specified without specifying 'sourceMap' option.": "L'option 'sourceRoot' ne peut pas être spécifiée sans la spécification de l'option 'sourceMap'.",
        "Option 'noEmit' cannot be specified with option 'out' or 'outDir'.": "L'option 'noEmit' ne peut pas être spécifiée avec l'option 'out' ou 'outDir'.",
        "Option 'noEmit' cannot be specified with option 'declaration'.": "L'option 'noEmit' ne peut pas être spécifiée avec l'option 'declaration'.",
        "Option 'project' cannot be mixed with source files on a command line.": "L'option 'project' ne peut pas être associée à des fichiers sources sur une ligne de commande.",
        "Option 'declaration' cannot be specified with option 'isolatedModules'.": "L'option 'declaration' ne peut pas être spécifiée avec l'option 'isolatedModules'.",
        "Option 'noEmitOnError' cannot be specified with option 'isolatedModules'.": "L'option 'noEmitOnError' ne peut pas être spécifiée avec l'option 'isolatedModules'.",
        "Option 'out' cannot be specified with option 'isolatedModules'.": "L'option 'out' ne peut pas être spécifiée avec l'option 'isolatedModules'.",
        "Option 'isolatedModules' can only be used when either option'--module' is provided or option 'target' is 'ES6' or higher.": "L'option 'isolatedModules' peut être utilisée seulement quand l'option '--module' est spécifiée ou si l'option 'target' a la valeur 'ES6' ou supérieure.",
        "Option 'sourceMap' cannot be specified with option 'inlineSourceMap'.": "L'option 'sourceMap' ne peut pas être spécifiée avec l'option 'inlineSourceMap'.",
        "Option 'sourceRoot' cannot be specified with option 'inlineSourceMap'.": "L'option 'sourceRoot' ne peut pas être spécifiée avec l'option 'inlineSourceMap'.",
        "Option 'mapRoot' cannot be specified with option 'inlineSourceMap'.": "L'option 'mapRoot' ne peut pas être spécifiée avec l'option 'inlineSourceMap'.",
        "Option 'inlineSources' can only be used when either option '--inlineSourceMap' or option '--sourceMap' is provided.": "L'option 'inlineSources' peut être utilisée seulement quand l'option '--inlineSourceMap' ou l'option '--sourceMap' est spécifiée.",
        "Concatenate and emit output to single file.": "Concaténer la sortie et l'émettre vers un seul fichier.",
        "Generates corresponding '.d.ts' file.": "Génère le fichier '.d.ts' correspondant.",
        "Specifies the location where debugger should locate map files instead of generated locations.": "Spécifie l'emplacement dans lequel le débogueur doit localiser les fichiers de mappage plutôt que les emplacements générés.",
        "Specifies the location where debugger should locate TypeScript files instead of source locations.": "Spécifie l'emplacement dans lequel le débogueur doit localiser les fichiers TypeScript plutôt que les emplacements source.",
        "Watch input files.": "Fichiers d'entrée d'espion.",
        "Redirect output structure to the directory.": "Rediriger la structure de sortie vers le répertoire.",
        "Do not erase const enum declarations in generated code.": "N'effacez pas les déclarations d'enum const dans le code généré.",
        "Do not emit outputs if any errors were reported.": "N'émettez pas de sortie si des erreurs sont signalées.",
        "Do not emit comments to output.": "Ne pas publier de commentaires dans la sortie.",
        "Do not emit outputs.": "N'émettez pas de sorties.",
        "Specify ECMAScript target version: 'ES3' (default), 'ES5', or 'ES6' (experimental)": "Spécifiez la version cible d'ECMAScript : 'ES3' (par défaut), 'ES5' ou 'ES6' (expérimental)",
        "Specify module code generation: 'commonjs', 'amd', 'system' or 'umd'": "Spécifiez la génération du code du module : 'commonjs', 'amd', 'system' ou 'umd'",
        "Print this message.": "Imprimer ce message.",
        "Print the compiler's version.": "Affichez la version du compilateur.",
        "Compile the project in the given directory.": "Compilez le projet dans le répertoire donné.",
        "Syntax: {0}": "Syntaxe : {0}",
        "options": "options",
        "file1": "fichier",
        "Examples: {0}": "Exemples : {0}",
        "Options:": "Options :",
        "Version {0}": "Version {0}",
        "Insert command line options and files from a file.": "Insérer les options de ligne de commande et les fichiers à partir d'un fichier texte.",
        "File change detected. Starting incremental compilation...": "Modification de fichier détectée. Démarrage de la compilation incrémentielle...",
        "KIND": "GENRE",
        "file2": "FICHIER",
        "VERSION": "VERSION",
        "LOCATION": "EMPLACEMENT",
        "DIRECTORY": "RÉPERTOIRE",
        "Compilation complete. Watching for file changes.": "Fin de la compilation. Détection des changements apportés au fichier.",
        "Generates corresponding '.map' file.": "Génère le fichier '.map' correspondant.",
        "Compiler option '{0}' expects an argument.": "L'option de compilateur '{0}' attend an argument.",
        "Unterminated quoted string in response file '{0}'.": "Chaîne entre guillemets inachevée dans le fichier réponse '{0}'.",
        "Argument for '--module' option must be 'commonjs', 'amd', 'system' or 'umd'.": "L'argument pour l'option '--module' doit être 'commonjs', 'amd', 'system' ou 'umd'.",
        "Argument for '--target' option must be 'ES3', 'ES5', or 'ES6'.": "L'argument pour l'option '--target' doit être 'ES3', 'ES5' ou 'ES6'.",
        "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.": "Les paramètres régionaux doivent être sous la forme <langue> ou <langue>-<territoire>. Par exemple '{0}' ou '{1}'.",
        "Unsupported locale '{0}'.": "Paramètres régionaux non pris en charge : '{0}'.",
        "Unable to open file '{0}'.": "Impossible d'ouvrir le fichier '{0}'.",
        "Corrupted locale file {0}.": "Fichier de paramètres régionaux endommagé : {0}.",
        "Raise error on expressions and declarations with an implied 'any' type.": "Lève une erreur sur les expressions et les déclarations ayant un type 'any' implicite.",
        "File '{0}' not found.": "Fichier '{0}' introuvable.",
        "File '{0}' has unsupported extension. The only supported extensions are {1}.": "Le fichier '{0}' a une extension non prise en charge. Les seules extensions prises en charge sont {1}.",
        "Suppress noImplicitAny errors for indexing objects lacking index signatures.": "Supprimer les erreurs noImplicitAny pour les objets d’indexation auxquels il manque des signatures d’index.",
        "Do not emit declarations for code that has an '@internal' annotation.": "N'émettez pas de déclarations pour du code ayant une annotation '@internal'.",
        "Specifies the root directory of input files. Use to control the output directory structure with --outDir.": "Spécifie le répertoire racine des fichiers d'entrée. Utilisé pour contrôler la structure de répertoires de sortie avec --outDir.",
        "File '{0}' is not under 'rootDir' '{1}'. 'rootDir' is expected to contain all source files.": "Le fichier '{0}' ne se trouve pas sous 'rootDir' '{1}'. 'rootDir' est supposé contenir tous les fichiers sources.",
        "Specifies the end of line sequence to be used when emitting files: 'CRLF' (dos) or 'LF' (unix).": "Spécifie la fin de la séquence de lignes à utiliser lors de l'émission de fichiers : 'CRLF' (Dos) ou 'LF' (Unix).",
        "NEWLINE": "NOUVELLE LIGNE",
        "Argument for '--newLine' option must be 'CRLF' or 'LF'.": "L'argument pour l'option '--newLine' doit être 'CRLF' ou 'LF'.",
        "Specify JSX code generation: 'preserve' or 'react'": "Spécifier la génération de code JSX : 'preserve' ou 'react'",
        "Argument for '--jsx' must be 'preserve' or 'react'.": "L'argument pour '--jsx' doit être 'preserve' ou 'react'.",
        "Option 'experimentalDecorators' must also be specified when option 'emitDecoratorMetadata' is specified.": "L'option 'experimentalDecorators' doit également être spécifiée quand l'option 'emitDecoratorMetadata' est spécifiée.",
        "Enables experimental support for ES7 decorators.": "Active la prise en charge expérimentale pour les décorateurs ES7.",
        "Enables experimental support for emitting type metadata for decorators.": "Active la prise en charge expérimentale pour l'émission des métadonnées de type pour les décorateurs.",
        "Option 'experimentalAsyncFunctions' cannot be specified when targeting ES5 or lower.": "L'option 'experimentalAsyncFunctions' ne peut pas être spécifiée quand ES5 ou version inférieure est ciblé.",
        "Enables experimental support for ES7 async functions.": "Active la prise en charge expérimentale des fonctions async ES7.",
        "Variable '{0}' implicitly has an '{1}' type.": "La variable '{0}' possède implicitement un type '{1}'.",
        "Parameter '{0}' implicitly has an '{1}' type.": "Le paramètre '{0}' possède implicitement un type '{1}'.",
        "Member '{0}' implicitly has an '{1}' type.": "Le membre '{0}' possède implicitement un type '{1}'.",
        "'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.": "L'expression 'new', dont la cible ne dispose pas d'une signature de construction, possède implicitement un type 'any'.",
        "'{0}', which lacks return-type annotation, implicitly has an '{1}' return type.": "'{0}', qui ne dispose pas d'annotation de type de retour, possède implicitement un type '{1}'.",
        "Function expression, which lacks return-type annotation, implicitly has an '{0}' return type.": "L'expression de fonction, qui ne dispose pas d'annotation de type de retour, possède implicitement un type de retour '{0}'.",
        "Construct signature, which lacks return-type annotation, implicitly has an 'any' return type.": "La signature de construction, qui ne dispose pas d'annotation de type de retour, possède implicitement un type 'any'.",
        "Property '{0}' implicitly has type 'any', because its 'set' accessor lacks a type annotation.": "La propriété '{0}' possède implicitement le type 'any', car son accesseur 'set' ne dispose pas d'une annotation de type.",
        "Index signature of object type implicitly has an 'any' type.": "La signature d'index du type d'objet a implicitement un type 'any'.",
        "Object literal's property '{0}' implicitly has an '{1}' type.": "La propriété '{0}' du littéral d'objet possède implicitement un type '{1}'.",
        "Rest parameter '{0}' implicitly has an 'any[]' type.": "Le paramètre rest '{0}' possède implicitement un type 'any[]'.",
        "Call signature, which lacks return-type annotation, implicitly has an 'any' return type.": "La signature d'appel, qui ne dispose pas d'annotation de type de retour, possède implicitement un type de retour 'any'.",
        "'{0}' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.": "'{0}' a implicitement le type 'any', car il n'a pas d'annotation de type et est référencé directement ou indirectement dans son propre initialiseur.",
        "'{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.": "'{0}' possède implicitement le type de retour 'any', car il n'a pas d'annotation de type de retour, et est référencé directement ou indirectement dans l'une de ses expressions de retour.",
        "Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.": "La fonction possède implicitement le type de retour 'any', car elle n'a pas d'annotation de type de retour, et est référencée directement ou indirectement dans l'une de ses expressions de retour.",
        "Generator implicitly has type '{0}' because it does not yield any values. Consider supplying a return type.": "Le générateur a implicitement le type '{0}', car il ne produit aucune valeur. Fournissez un type de retour.",
        "JSX element implicitly has type 'any' because no interface 'JSX.{0}' exists": "L'élément JSX a implicitement le type 'any', car il n'existe aucune interface 'JSX.{0}'",
        "You cannot rename this element.": "Vous ne pouvez pas renommer cet élément.",
        "You cannot rename elements that are defined in the standard TypeScript library.": "Vous ne pouvez pas renommer des éléments définis dans la bibliothèque TypeScript standard.",
        "'import ... =' can only be used in a .ts file.": "'import ... =' peut uniquement être utilisé dans un fichier .ts.",
        "'export=' can only be used in a .ts file.": "'export=' peut uniquement être utilisé dans un fichier .ts.",
        "'type parameter declarations' can only be used in a .ts file.": "Les 'déclarations de paramètre de type' peuvent uniquement être utilisées dans un fichier .ts.",
        "'implements clauses' can only be used in a .ts file.": "Les clauses 'implements' peuvent uniquement être utilisées dans un fichier .ts.",
        "'interface declarations' can only be used in a .ts file.": "Les 'déclarations d'interface' peuvent uniquement être utilisées dans un fichier .ts.",
        "'module declarations' can only be used in a .ts file.": "Les 'déclarations de module' peuvent uniquement être utilisées dans un fichier .ts.",
        "'type aliases' can only be used in a .ts file.": "Les 'alias de type' peuvent uniquement être utilisés dans un fichier .ts.",
        "'{0}' can only be used in a .ts file.": "'{0}' peut uniquement être utilisé dans un fichier .ts.",
        "'types' can only be used in a .ts file.": "Les 'types' peuvent uniquement être utilisés dans un fichier .ts.",
        "'type arguments' can only be used in a .ts file.": "Les 'arguments de type' peuvent uniquement être utilisés dans un fichier .ts.",
        "'parameter modifiers' can only be used in a .ts file.": "Les 'modificateurs de paramètre' peuvent uniquement être utilisés dans un fichier .ts.",
        "'property declarations' can only be used in a .ts file.": "Les 'déclarations de propriété' peuvent uniquement être utilisées dans un fichier .ts.",
        "'enum declarations' can only be used in a .ts file.": "Les déclarations 'enum' peuvent uniquement être utilisées dans un fichier .ts.",
        "'type assertion expressions' can only be used in a .ts file.": "Les 'expressions d'assertion de type' peuvent uniquement être utilisées dans un fichier .ts.",
        "'decorators' can only be used in a .ts file.": "Un 'decorator' peut uniquement être utilisé dans un fichier .ts.",
        "Only identifiers/qualified-names with optional type arguments are currently supported in a class 'extends' clauses.": "Seuls les identificateurs/noms qualifiés avec des arguments de type facultatifs sont actuellement pris en charge dans les clauses 'extends' de classe.",
        "'class' expressions are not currently supported.": "Les expressions 'class' ne sont actuellement pas prises en charge.",
        "JSX attributes must only be assigned a non-empty 'expression'.": "Les attributs JSX doivent uniquement être attribués à une 'expression' non vide.",
        "JSX elements cannot have multiple attributes with the same name.": "Les éléments JSX ne peuvent pas avoir plusieurs attributs du même nom.",
        "Expected corresponding JSX closing tag for '{0}'.": "Balise de fermeture JSX correspondante attendue pour '{0}'.",
        "JSX attribute expected.": "Attribut JSX attendu.",
        "Cannot use JSX unless the '--jsx' flag is provided.": "Impossible d'utiliser JSX, sauf si l'indicateur '--jsx' est fourni.",
        "A constructor cannot contain a 'super' call when its class extends 'null'": "Un constructeur ne peut pas contenir d'appel de 'super' quand sa classe étend 'null'"
}