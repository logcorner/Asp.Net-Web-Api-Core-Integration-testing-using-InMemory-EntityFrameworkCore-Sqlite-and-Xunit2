{
        "Unterminated string literal.": "未终止的字符串文本。",
        "Identifier expected.": "应为标识符。",
        "'{0}' expected.": "应为“{0}”。",
        "A file cannot have a reference to itself.": "文件不能引用自身。",
        "Trailing comma not allowed.": "不允许使用尾随逗号。",
        "'*/' expected.": "应为 \"*/\"。",
        "Unexpected token.": "意外的标记。",
        "A rest parameter must be last in a parameter list.": "Rest 参数必须是列表中的最后一个参数。",
        "Parameter cannot have question mark and initializer.": "参数不能包含问号和初始值设定项。",
        "A required parameter cannot follow an optional parameter.": "必选参数不能位于可选参数后。",
        "An index signature cannot have a rest parameter.": "索引签名不能包含 rest 参数。",
        "An index signature parameter cannot have an accessibility modifier.": "索引签名参数不能具有可访问性修饰符。",
        "An index signature parameter cannot have a question mark.": "索引签名参数不能包含问号。",
        "An index signature parameter cannot have an initializer.": "索引签名参数不能具有初始值设定项。",
        "An index signature must have a type annotation.": "索引签名必须具有类型批注。",
        "An index signature parameter must have a type annotation.": "索引签名参数必须具有类型批注。",
        "An index signature parameter type must be 'string' or 'number'.": "索引签名参数类型必须“字符串”或“数字”。",
        "Accessibility modifier already seen.": "已看到可访问性修饰符。",
        "'{0}' modifier must precede '{1}' modifier.": "“{0}”修饰符必须位于“{1}”修饰符之前。",
        "'{0}' modifier already seen.": "已看到“{0}”修饰符。",
        "'{0}' modifier cannot appear on a class element.": "“{0}”修饰符不能出现在类元素上。",
        "'super' must be followed by an argument list or member access.": "\"super\" 的后面必须是参数列表或成员访问。",
        "Only ambient modules can use quoted names.": "仅环境模块可使用带引号的名称。",
        "Statements are not allowed in ambient contexts.": "不允许在环境上下文中使用语句。",
        "A 'declare' modifier cannot be used in an already ambient context.": "不能在已有的环境上下文中使用 \"declare\" 修饰符。",
        "Initializers are not allowed in ambient contexts.": "不允许在环境上下文中使用初始值设定项。",
        "'{0}' modifier cannot be used in an ambient context.": "“{0}”修饰符不能在环境上下文中使用。",
        "'{0}' modifier cannot be used with a class declaration.": "“{0}”修饰符不能与类声明一起使用。",
        "'{0}' modifier cannot be used here.": "“{0}”修饰符不能在此处使用。",
        "'{0}' modifier cannot appear on a data property.": "“{0}”修饰符不能出现在数据属性上。",
        "'{0}' modifier cannot appear on a module element.": "“{0}”修饰符不能出现在模块元素上。",
        "A '{0}' modifier cannot be used with an interface declaration.": "“{0}”修饰符不能与接口声明一起使用。",
        "A 'declare' modifier is required for a top level declaration in a .d.ts file.": "在 .d.ts 文件中的顶层声明需要 \"declare\" 修饰符。",
        "A rest parameter cannot be optional.": "Rest 参数不能为可选。",
        "A rest parameter cannot have an initializer.": "Rest 参数不能具有初始值设定项。",
        "A 'set' accessor must have exactly one parameter.": "\"set\" 访问器只能具有一个参数。",
        "A 'set' accessor cannot have an optional parameter.": "\"set\" 访问器不能具有可选参数。",
        "A 'set' accessor parameter cannot have an initializer.": "\"set\" 访问器参数不能包含初始值设定项。",
        "A 'set' accessor cannot have rest parameter.": "\"set\" 访问器不能具有 rest 参数。",
        "A 'get' accessor cannot have parameters.": "\"get\" 访问器不能具有参数。",
        "Type '{0}' is not a valid async function return type.": "类型“{0}”不是有效的异步函数返回类型。",
        "Accessors are only available when targeting ECMAScript 5 and higher.": "访问器仅在面向 ECMAScript 5 和更高版本时可用。",
        "An async function or method must have a valid awaitable return type.": "异步函数或方法必须具有有效的可等待返回类型。",
        "Operand for 'await' does not have a valid callable 'then' member.": "\"await\" 的操作数不具有有效的可调用 \"then\" 成员。",
        "Return expression in async function does not have a valid callable 'then' member.": "异步函数中的返回表达式不具有有效的可调用 \"then\" 成员。",
        "Expression body for async arrow function does not have a valid callable 'then' member.": "异步箭头函数的表达式主体不具有有效的可调用 \"then\" 成员。",
        "Enum member must have initializer.": "枚举成员必须具有初始值设定项。",
        "{0} is referenced directly or indirectly in the fulfillment callback of its own 'then' method.": "在 {0} 自身的 \"then\" 方法的 fulfillment 回调中直接或间接引用它。",
        "An export assignment cannot be used in a namespace.": "不能在命名空间中使用导出分配。",
        "Ambient enum elements can only have integer literal initializers.": "环境枚举元素只能具有整型文本初始值。",
        "Unexpected token. A constructor, method, accessor, or property was expected.": "意外的标记。应为构造函数、方法、访问器或属性。",
        "A '{0}' modifier cannot be used with an import declaration.": "“{0}”修饰符不能与导入声明一起使用。",
        "Invalid 'reference' directive syntax.": "\"reference\" 指令语法无效。",
        "Octal literals are not available when targeting ECMAScript 5 and higher.": "面向 ECMAScript 5 和更高版本时，八进制文本不可用。",
        "An accessor cannot be declared in an ambient context.": "不能在环境上下文中声明访问器。",
        "'{0}' modifier cannot appear on a constructor declaration.": "“{0}”修饰符不能出现在构造函数声明中。",
        "'{0}' modifier cannot appear on a parameter.": "“{0}”修饰符不能出现在参数中。",
        "Only a single variable declaration is allowed in a 'for...in' statement.": "\"for...in\" 语句中只允许单个变量声明。",
        "Type parameters cannot appear on a constructor declaration.": "类型参数不能出现在构造函数声明中。",
        "Type annotation cannot appear on a constructor declaration.": "类型注释不能出现在构造函数声明中。",
        "An accessor cannot have type parameters.": "访问器不能具有类型参数。",
        "A 'set' accessor cannot have a return type annotation.": "\"set\" 访问器不能具有返回类型批注。",
        "An index signature must have exactly one parameter.": "索引签名必须只包含一个参数。",
        "'{0}' list cannot be empty.": "“{0}”列表不能为空。",
        "Type parameter list cannot be empty.": "类型参数列表不能为空。",
        "Type argument list cannot be empty.": "类型参数列表不能为空。",
        "Invalid use of '{0}' in strict mode.": "严格模式下“{0}”的使用无效。",
        "'with' statements are not allowed in strict mode.": "严格模式下不允许使用 \"with\" 语句。",
        "'delete' cannot be called on an identifier in strict mode.": "在严格模式下，无法对标识符调用 \"delete\"。",
        "A 'continue' statement can only be used within an enclosing iteration statement.": "\"continue\" 语句只能在封闭迭代语句内使用。",
        "A 'break' statement can only be used within an enclosing iteration or switch statement.": "\"break\" 只能在封闭迭代或 switch 语句内使用。",
        "Jump target cannot cross function boundary.": "跳转目标不能跨越函数边界。",
        "A 'return' statement can only be used within a function body.": "\"return\" 语句只能在函数体中使用。",
        "Expression expected.": "应为表达式。",
        "Type expected.": "应为类型。",
        "A class member cannot be declared optional.": "不能将类成员声明为可选。",
        "A 'default' clause cannot appear more than once in a 'switch' statement.": "\"default\" 子句在 \"switch\" 语句中只能出现一次。",
        "Duplicate label '{0}'": "复制标签“{0}”",
        "A 'continue' statement can only jump to a label of an enclosing iteration statement.": "\"continue\" 语句只能跳转到封闭迭代语句的标签。",
        "A 'break' statement can only jump to a label of an enclosing statement.": "\"break\" 语句只能跳转到封闭语句的标签。",
        "An object literal cannot have multiple properties with the same name in strict mode.": "严格模式下，对象文字不能包含多个具有相同名称的属性。",
        "An object literal cannot have multiple get/set accessors with the same name.": "对象文字不能具有多个具有相同名称的 get/set 访问器。",
        "An object literal cannot have property and accessor with the same name.": "对象文字不能包含具有相同名称的属性和访问器。",
        "An export assignment cannot have modifiers.": "导出分配不能具有修饰符。",
        "Octal literals are not allowed in strict mode.": "严格模式下不允许使用八进制文本。",
        "A tuple type element list cannot be empty.": "元祖类型元素列表不能为空。",
        "Variable declaration list cannot be empty.": "变量声明列表不能为空。",
        "Digit expected.": "应为数字。",
        "Hexadecimal digit expected.": "应为十六进制数字。",
        "Unexpected end of text.": "文本意外结束。",
        "Invalid character.": "无效的字符。",
        "Declaration or statement expected.": "应为声明或语句。",
        "Statement expected.": "应为语句。",
        "'case' or 'default' expected.": "应为 \"case\" 或 \"default\"。",
        "Property or signature expected.": "应为属性或签名。",
        "Enum member expected.": "应为枚举成员。",
        "Variable declaration expected.": "应为变量声明。",
        "Argument expression expected.": "应为参数表达式。",
        "Property assignment expected.": "应为属性分配。",
        "Expression or comma expected.": "应为表达式或逗号。",
        "Parameter declaration expected.": "应为参数声明。",
        "Type parameter declaration expected.": "应为类型参数声明。",
        "Type argument expected.": "应为类型参数。",
        "String literal expected.": "应为字符串文本。",
        "Line break not permitted here.": "不允许在此处换行。",
        "'{' or ';' expected.": "需要 \"{\" 或 \";\"。",
        "Modifiers not permitted on index signature members.": "不允许对索引签名成员使用修饰符。",
        "Declaration expected.": "应为声明。",
        "Import declarations in a namespace cannot reference a module.": "命名空间中的导入声明不能引用模块。",
        "Cannot compile modules unless the '--module' flag is provided.": "无法编译模块，除非提供 \"--module\" 标志。",
        "File name '{0}' differs from already included file name '{1}' only in casing": "文件名“{0}”仅在大小写方面与包含的文件名“{1}”不同",
        "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.": "\"new T[]\" 不能用于创建数组。请改用 \"new Array<T>()\"。",
        "'const' declarations must be initialized": "必须初始化 \"const\" 声明",
        "'const' declarations can only be declared inside a block.": "\"const\" 声明只能在块的内部声明。",
        "'let' declarations can only be declared inside a block.": "\"let\" 声明只能在块的内部声明。",
        "Unterminated template literal.": "未终止的模板文本。",
        "Unterminated regular expression literal.": "未终止的正则表达式文本。",
        "An object member cannot be declared optional.": "对象成员无法声明为可选。",
        "A 'yield' expression is only allowed in a generator body.": "只允许在生成器正文中使用 \"yield\" 表达式。",
        "Computed property names are not allowed in enums.": "枚举中不允许计算属性名。",
        "A computed property name in an ambient context must directly refer to a built-in symbol.": "环境上下文中的计算属性名称必须直接引用内置符号。",
        "A computed property name in a class property declaration must directly refer to a built-in symbol.": "类属性声明中的计算属性名称必须直接引用内置符号。",
        "A computed property name in a method overload must directly refer to a built-in symbol.": "方法重载中的计算属性名称必须直接引用内置符号。",
        "A computed property name in an interface must directly refer to a built-in symbol.": "接口中的计算属性名称必须直接引用内置符号。",
        "A computed property name in a type literal must directly refer to a built-in symbol.": "类型文本中的计算属性名称必须直接引用内置符号。",
        "A comma expression is not allowed in a computed property name.": "计算属性名中不允许逗号表达式。",
        "'extends' clause already seen.": "已看到 \"extends\" 子句。",
        "'extends' clause must precede 'implements' clause.": "\"extends\" 子句必须位于 \"implements\" 子句之前。",
        "Classes can only extend a single class.": "类只能扩展一个类。",
        "'implements' clause already seen.": "已看到 \"implements\" 子句。",
        "Interface declaration cannot have 'implements' clause.": "接口声明不能有 \"implements\" 字句。",
        "Binary digit expected.": "需要二进制数字。",
        "Octal digit expected.": "需要八进制数字。",
        "Unexpected token. '{' expected.": "意外标记。需要 \"{\"。",
        "Property destructuring pattern expected.": "应为属性析构模式。",
        "Array element destructuring pattern expected.": "应为数组元素析构模式。",
        "A destructuring declaration must have an initializer.": "析构声明必须具有初始值设定项。",
        "An implementation cannot be declared in ambient contexts.": "不能在环境上下文中声明实现。",
        "Modifiers cannot appear here.": "修饰符不能出现在此处。",
        "Merge conflict marker encountered.": "遇到合并冲突标记。",
        "A rest element cannot have an initializer.": "rest 元素不能具有初始值设定项。",
        "A parameter property may not be a binding pattern.": "参数属性不能为绑定模式。",
        "Only a single variable declaration is allowed in a 'for...of' statement.": "\"for...of\" 语句中只允许单个变量声明。",
        "The variable declaration of a 'for...in' statement cannot have an initializer.": "\"for...in\" 语句的变量声明不能有初始值设定项。",
        "The variable declaration of a 'for...of' statement cannot have an initializer.": "\"for...of\" 语句的变量声明不能有初始值设定项。",
        "An import declaration cannot have modifiers.": "导入声明不能有修饰符。",
        "Module '{0}' has no default export.": "模块“{0}”不具有默认导出。",
        "An export declaration cannot have modifiers.": "导出声明不能有修饰符。",
        "Export declarations are not permitted in a namespace.": "命名空间中不允许有导出声明。",
        "Catch clause variable name must be an identifier.": "Catch 子句变量名称必须是一个标识符。",
        "Catch clause variable cannot have a type annotation.": "Catch 子句变量不能有类型批注。",
        "Catch clause variable cannot have an initializer.": "Catch 子句变量不能有初始值设定项。",
        "An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.": "扩展的 Unicode 转义值必须介于(含) 0x0 和 0x10FFFF 之间。",
        "Unterminated Unicode escape sequence.": "Unicode 转义序列未终止。",
        "Line terminator not permitted before arrow.": "箭头前不允许有行终止符。",
        "Import assignment cannot be used when targeting ECMAScript 6 or higher. Consider using 'import * as ns from \"mod\"', 'import {a} from \"mod\"' or 'import d from \"mod\"' instead.": "面向 ECMAScript 6 或更高版本时，不能使用导入分配。请考虑改用 \"import * as ns from \"mod\"\"、\"import {a} from \"mod\"\" 或 \"import d from \"mod\"\"。",
        "Export assignment cannot be used when targeting ECMAScript 6 or higher. Consider using 'export default' instead.": "面向 ECMAScript 6 或更高版本时，不能使用导出分配。请考虑改用 \"export default\"。",
        "Cannot compile modules into 'commonjs', 'amd', 'system' or 'umd' when targeting 'ES6' or higher.": "面向 \"ES6\" 或更高版本时，不能将模块编译成 \"commonjs\"、\"amd\"、\"system\" 或 \"umd\"。",
        "Decorators are only available when targeting ECMAScript 5 and higher.": "仅当面向 ECMAScript 5 和更高版本时，修饰器才可用。",
        "Decorators are not valid here.": "修饰器在此处无效。",
        "Decorators cannot be applied to multiple get/set accessors of the same name.": "不能向多个同名的 get/set 访问器应用修饰器。",
        "Cannot compile namespaces when the '--isolatedModules' flag is provided.": "提供 \"--isolatedModules\" 标志时无法编译命名空间。",
        "Ambient const enums are not allowed when the '--isolatedModules' flag is provided.": "提供 \"--isolatedModules\" 标志的情况下不允许使用环境常量枚举。",
        "Invalid use of '{0}'. Class definitions are automatically in strict mode.": "使用“{0}”无效。类定义会自动进入严格模式。",
        "A class declaration without the 'default' modifier must have a name": "不带 \"default\" 修饰符的类声明必须具有名称",
        "Identifier expected. '{0}' is a reserved word in strict mode": "应为标识符。“{0}”在严格模式下是保留字",
        "Identifier expected. '{0}' is a reserved word in strict mode. Class definitions are automatically in strict mode.": "应为标识符。“{0}”在严格模式下是保留字。类定义会自动进入严格模式。",
        "Identifier expected. '{0}' is a reserved word in strict mode. Modules are automatically in strict mode.": "预期的标识符。“{0}”是严格模式下的保留字。模块自动处于严格模式。",
        "Invalid use of '{0}'. Modules are automatically in strict mode.": "“{0}”的使用无效。模块自动处于严格模式。",
        "Export assignment is not supported when '--module' flag is 'system'.": "当 \"--module\" 标志是 \"system\" 时不支持导出分配。",
        "Experimental support for decorators is a feature that is subject to change in a future release. Specify '--experimentalDecorators' to remove this warning.": "对修饰器的实验支持是一种功能，会在将来的版本中进行更改。指定 \"--experimentalDecorators\" 可移除此警告。",
        "Generators are only available when targeting ECMAScript 6 or higher.": "仅当面向 ECMAScript 6 或更高版本时，生成器才可用。",
        "Generators are not allowed in an ambient context.": "不允许在环境上下文中使用生成器。",
        "An overload signature cannot be declared as a generator.": "重载签名无法声明为生成器。",
        "'{0}' tag already specified.": "已指定“{0}”标记。",
        "Signature '{0}' must have a type predicate.": "签名“{0}”必须具有类型谓词。",
        "Cannot find parameter '{0}'.": "无法找到参数“{0}”。",
        "Type predicate '{0}' is not assignable to '{1}'.": "类型谓词“{0}”不可分配给“{1}”。",
        "Parameter '{0}' is not in the same position as parameter '{1}'.": "参数“{0}”和参数“{1}”的位置不一样。",
        "A type predicate is only allowed in return type position for functions and methods.": "只允许在函数和方法的返回类型位置使用类型谓词。",
        "A type predicate cannot reference a rest parameter.": "类型谓词无法引用 rest 参数。",
        "A type predicate cannot reference element '{0}' in a binding pattern.": "类型谓词无法在绑定模式中引用元素“{0}”。",
        "An export assignment can only be used in a module.": "导出分配只能在模块中使用。",
        "An import declaration can only be used in a namespace or module.": "导入声明只能在命名空间或模块中使用。",
        "An export declaration can only be used in a module.": "导出声明只能在模块中使用。",
        "An ambient module declaration is only allowed at the top level in a file.": "只允许在文件的顶层中使用环境模块声明。",
        "A namespace declaration is only allowed in a namespace or module.": "只允许在命名空间或模块中使用命名空间声明。",
        "Experimental support for async functions is a feature that is subject to change in a future release. Specify '--experimentalAsyncFunctions' to remove this warning.": "异步函数的实验支持是一种在未来版本中可能有所改变的功能。指定 \"--experimentalAsyncFunctions\" 以删除此警告。",
        "'with' statements are not allowed in an async function block.": "不允许在异步功能块中使用 \"with\" 语句。",
        "'await' expression is only allowed within an async function.": "只允许在异步函数中使用 \"await\" 表达式。",
        "Async functions are only available when targeting ECMAScript 6 and higher.": "仅当面向 ECMAScript 6 和更高版本时，异步函数才可用。",
        "The return type of a property decorator function must be either 'void' or 'any'.": "属性装饰器函数的返回类型必须为 \"void\" 或 \"any\"。",
        "The return type of a parameter decorator function must be either 'void' or 'any'.": "参数装饰器函数的返回类型必须为 \"void\" 或 \"any\"。",
        "Unable to resolve signature of class decorator when called as an expression.": "作为表达式调用时，无法解析类装饰器的签名。",
        "Unable to resolve signature of parameter decorator when called as an expression.": "作为表达式调用时，无法解析参数装饰器的签名。",
        "Unable to resolve signature of property decorator when called as an expression.": "作为表达式调用时，无法解析属性装饰器的签名。",
        "Unable to resolve signature of method decorator when called as an expression.": "作为表达式调用时，无法解析方法装饰器的签名。",
        "'abstract' modifier can only appear on a class or method declaration.": "\"abstract\" 修饰符只能出现在类声明或方法声明中。",
        "'{0}' modifier cannot be used with '{1}' modifier.": "“{0}”修饰符不能与“{1}”修饰符一起使用。",
        "Abstract methods can only appear within an abstract class.": "抽象方法只能出现在抽象类中。",
        "Method '{0}' cannot have an implementation because it is marked abstract.": "方法“{0}”不能实现，因为它标记为抽象。",
        "Duplicate identifier '{0}'.": "标识符“{0}”重复。",
        "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.": "实例成员变量“{0}”的初始值设定项不能引用在构造函数中声明的标识符“{1}”。",
        "Static members cannot reference class type parameters.": "静态成员不能引用类类型参数。",
        "Circular definition of import alias '{0}'.": "导入别名“{0}”的循环定义。",
        "Cannot find name '{0}'.": "无法找到名称“{0}”。",
        "Module '{0}' has no exported member '{1}'.": "模块“{0}”没有导出的成员“{1}”。",
        "File '{0}' is not a module.": "文件“{0}”不是模块。",
        "Cannot find module '{0}'.": "找不到模块“{0}”。",
        "An export assignment cannot be used in a module with other exported elements.": "不能在具有其他导出元素的模块中使用导出分配。",
        "Type '{0}' recursively references itself as a base type.": "类型“{0}”以递归方式将自身引用为基类。",
        "A class may only extend another class.": "类只能扩展其他类。",
        "An interface may only extend a class or another interface.": "接口只能扩展类或其他接口。",
        "Constraint of a type parameter cannot reference any type parameter from the same type parameter list.": "类型参数约束不能引用同一类型参数列表中的任何类型参数。",
        "Generic type '{0}' requires {1} type argument(s).": "泛型类型“{0}”需要 {1} 类型参数。",
        "Type '{0}' is not generic.": "类型“{0}”不是泛型类型。",
        "Global type '{0}' must be a class or interface type.": "全局类型“{0}”必须为类或接口类型。",
        "Global type '{0}' must have {1} type parameter(s).": "全局类型“{0}”必须具有 {1} 个类型参数。",
        "Cannot find global type '{0}'.": "无法找到全局类型“{0}”。",
        "Named property '{0}' of types '{1}' and '{2}' are not identical.": "“{1}”和“{2}”类型的命名属性“{0}”不完全相同。",
        "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}'.": "接口“{0}”不能同时扩展类型“{1}”和“{2}”。",
        "Excessive stack depth comparing types '{0}' and '{1}'.": "与类型“{0}”和“{1}”相比，堆栈深度过高。",
        "Type '{0}' is not assignable to type '{1}'.": "不能将类型“{0}”赋给类型“{1}”。",
        "Property '{0}' is missing in type '{1}'.": "类型“{1}”中缺少属性“{0}”。",
        "Property '{0}' is private in type '{1}' but not in type '{2}'.": "属性“{0}”在类型“{1}”中是私有属性，但在类型“{2}”中不是。",
        "Types of property '{0}' are incompatible.": "属性“{0}”的类型不兼容。",
        "Property '{0}' is optional in type '{1}' but required in type '{2}'.": "属性“{0}”在类型“{1}”中为可选，但在类型“{2}”中为必选。",
        "Types of parameters '{0}' and '{1}' are incompatible.": "参数“{0}”和“{1}” 的类型不兼容。",
        "Index signature is missing in type '{0}'.": "类型“{0}”中缺少索引签名。",
        "Index signatures are incompatible.": "索引签名不兼容。",
        "'this' cannot be referenced in a module or namespace body.": "不能在模块或命名空间体中引用 \"this\"。",
        "'this' cannot be referenced in current location.": "不能在当前位置引用 \"this\"。",
        "'this' cannot be referenced in constructor arguments.": "不能在构造函数参数中引用 \"this\"。",
        "'this' cannot be referenced in a static property initializer.": "\"this\" 不能被静态属性初始值设定项引用。",
        "'super' can only be referenced in a derived class.": "只能在派生类中引用 \"super\"。",
        "'super' cannot be referenced in constructor arguments.": "不能在构造函数参数中引用 \"super\"。",
        "Super calls are not permitted outside constructors or in nested functions inside constructors.": "不允许在构造函数外部或在构造函数内的嵌套函数中进行 Super 调用。",
        "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.": "只有构造函数、成员函数或派生类的成员取值函数中才允许 \"super\" 属性访问。",
        "Property '{0}' does not exist on type '{1}'.": "属性“{0}”在类型“{1}”上不存在。",
        "Only public and protected methods of the base class are accessible via the 'super' keyword.": "通过 \"super\" 关键字只能访问基类的公共方法和受保护方法。",
        "Property '{0}' is private and only accessible within class '{1}'.": "属性“{0}”为私有，只能在类“{1}”中访问。",
        "An index expression argument must be of type 'string', 'number', 'symbol, or 'any'.": "索引表达式参数的类型必须为 \"string\"、\"number\"、\"symbol\" 或 \"any\"。",
        "Type '{0}' does not satisfy the constraint '{1}'.": "类型“{0}”不满足约束“{1}”。",
        "Argument of type '{0}' is not assignable to parameter of type '{1}'.": "类型“{0}”的参数不能赋给类型“{1}”的参数。",
        "Supplied parameters do not match any signature of call target.": "提供的参数与调用目标的任何签名都不匹配。",
        "Untyped function calls may not accept type arguments.": "非类型化函数调用不能接受类型参数。",
        "Value of type '{0}' is not callable. Did you mean to include 'new'?": "类型“{0}”的值不可调用。是否希望包括 \"new\"?",
        "Cannot invoke an expression whose type lacks a call signature.": "无法调用其类型缺少调用签名的表达式。",
        "Only a void function can be called with the 'new' keyword.": "使用 \"new\" 关键字只能调用 void 函数。",
        "Cannot use 'new' with an expression whose type lacks a call or construct signature.": "其类型缺少调用或构造签名的表达式无法使用 \"new\"。",
        "Neither type '{0}' nor type '{1}' is assignable to the other.": "类型“{0}”或类型“{1}”均不能赋给对方。",
        "Object literal may only specify known properties, and '{0}' does not exist in type '{1}'.": "对象文字可能只指定已知属性，并且“{0}”不在类型“{1}”中。",
        "No best common type exists among return expressions.": "返回表达式中不存在最佳通用类型。",
        "A function whose declared type is neither 'void' nor 'any' must return a value or consist of a single 'throw' statement.": "其声明的类型不是 \"void\" 或 \"any\" 的函数必须返回一个值或由单个 \"throw\" 语句组成。",
        "An arithmetic operand must be of type 'any', 'number' or an enum type.": "算术操作数必须为类型 \"any\"、\"number\" 或枚举类型。",
        "The operand of an increment or decrement operator must be a variable, property or indexer.": "递增运算符或递减运算符的操作数必须是变量、属性或索引器。",
        "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.": "\"instanceof\" 表达式左侧必须是 \"any\" 类型、对象类型或类型参数。",
        "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.": "\"instanceof\" 表达式的右侧必须属于类型 \"any\"，或属于可分配给 \"Function\" 接口类型的类型。",
        "The left-hand side of an 'in' expression must be of type 'any', 'string', 'number', or 'symbol'.": "\"in\" 表达式左侧的类型必须为 \"any\"、\"string\"、\"number\" 或 \"symbol\"。",
        "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter": "\"in\" 表达式的右侧必须是 \"any\" 类型、对象类型或类型参数",
        "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "算术运算左侧必须是 \"any\"、\"number\" 或枚举类型。",
        "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "算术运算右侧必须是 \"any\"、\"number\" 或枚举类型。",
        "Invalid left-hand side of assignment expression.": "赋值表达式左侧无效。",
        "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": "运算符“{0}”不能应用于类型“{1}”和“{2}”。",
        "Type parameter name cannot be '{0}'": "类型参数名称不能为“{0}”",
        "A parameter property is only allowed in a constructor implementation.": "只允许在构造函数实现中使用参数属性。",
        "A rest parameter must be of an array type.": "Rest 参数必须是数组类型。",
        "A parameter initializer is only allowed in a function or constructor implementation.": "只允许在函数或构造函数实现中使用参数初始值设定项。",
        "Parameter '{0}' cannot be referenced in its initializer.": "参数“{0}”初始值设定项中不能引用它自身。",
        "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.": "参数“{0}”的初始值设定项不能引用在它之后声明的标识符“{1}”。",
        "Duplicate string index signature.": "字符串索引签名重复。",
        "Duplicate number index signature.": "数字索引签名重复。",
        "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.": "当类包含初始化的属性或参数属性时，\"super\" 调用必须是构造函数中的第一个语句。",
        "Constructors for derived classes must contain a 'super' call.": "派生类的构造函数必须包含 \"super\" 调用。",
        "A 'get' accessor must return a value or consist of a single 'throw' statement.": "\"get\" 访问器必须返回一个值或由单个 \"throw\" 语句组成。",
        "Getter and setter accessors do not agree in visibility.": "Getter 和 setter 访问器在可见性上不一致。",
        "'get' and 'set' accessor must have the same type.": "\"get\" 和 \"set\" 访问器必须属于同一类型。",
        "A signature with an implementation cannot use a string literal type.": "具有实现的签名不能使用字符串文本类型。",
        "Specialized overload signature is not assignable to any non-specialized signature.": "指定的重载签名不可分配给任何非专用化签名。",
        "Overload signatures must all be exported or not exported.": "重载签名必须全部导出或全部不导出。",
        "Overload signatures must all be ambient or non-ambient.": "重载签名必须全部为环境签名或非环境签名。",
        "Overload signatures must all be public, private or protected.": "重载签名必须全部是公共签名、私有签名或受保护签名。",
        "Overload signatures must all be optional or required.": "重载签名必须全部为可选签名或必需签名。",
        "Function overload must be static.": "函数重载必须为静态。",
        "Function overload must not be static.": "函数重载不能为静态。",
        "Function implementation name must be '{0}'.": "函数实现名称必须为“{0}”。",
        "Constructor implementation is missing.": "缺少构造函数实现。",
        "Function implementation is missing or not immediately following the declaration.": "函数实现缺失或未立即出现在声明之后。",
        "Multiple constructor implementations are not allowed.": "不允许存在多个构造函数实现。",
        "Duplicate function implementation.": "函数实现重复。",
        "Overload signature is not compatible with function implementation.": "重载签名与函数实现不兼容。",
        "Individual declarations in merged declaration '{0}' must be all exported or all local.": "合并声明“{0}”中的单独声明必须全部导出或全部是局部声明。",
        "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.": "标识符 \"arguments\" 重复。编译器使用 \"arguments\" 初始化 rest 参数。",
        "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.": "标识符 \"_this\" 重复。编译器使用变量声明 \"_this\" 捕获 \"_this\" 引用。",
        "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.": "表达式解析为变量声明 \"_this\"，编译器使用 \"_this\" 来捕获 \"this\" 引用。",
        "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.": "标识符 \"_super\" 重复。编译器使用 \"_super\" 获取基类引用。",
        "Expression resolves to '_super' that compiler uses to capture base class reference.": "表达式解析为 \"_super\"，编译器使用 \"_super\" 获取基类引用。",
        "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.": "后续变量声明必须属于同一类型。变量“{0}”必须属于类型“{1}”，但此处却为类型“{2}”。",
        "The left-hand side of a 'for...in' statement cannot use a type annotation.": "\"for...in\" 语句的左侧不能使用类型批注。",
        "The left-hand side of a 'for...in' statement must be of type 'string' or 'any'.": "\"for...in\" 语句的左侧必须是 \"string\" 或 \"any\" 类型。",
        "Invalid left-hand side in 'for...in' statement.": "\"for...in\" 语句左侧无效。",
        "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.": "\"for...in\" 语句右侧必须是 \"any\" 类型、对象类型或类型参数。",
        "Setters cannot return a value.": "Setter 不能返回值。",
        "Return type of constructor signature must be assignable to the instance type of the class": "构造函数签名的返回类型必须赋给类的实例类型",
        "All symbols within a 'with' block will be resolved to 'any'.": "\"with\" 块内的所有符号都将被解析为 \"any\"。",
        "Property '{0}' of type '{1}' is not assignable to string index type '{2}'.": "类型“{1}”的属性“{0}”不能赋给字符串索引类型“{2}”。",
        "Property '{0}' of type '{1}' is not assignable to numeric index type '{2}'.": "类型“{1}”的属性“{0}”不能赋给数字索引类型“{2}”。",
        "Numeric index type '{0}' is not assignable to string index type '{1}'.": "数字索引类型“{0}”不能赋给字符串索引类型“{1}”。",
        "Class name cannot be '{0}'": "类名不能为“{0}”",
        "Class '{0}' incorrectly extends base class '{1}'.": "类“{0}”错误扩展基类“{1}”。",
        "Class static side '{0}' incorrectly extends base class static side '{1}'.": "类静态侧“{0}”错误扩展基类静态侧“{1}”。",
        "Type name '{0}' in extends clause does not reference constructor function for '{0}'.": "Extends 子句中的类型名称“{0}”不能引用“{0}”的构造函数。",
        "Class '{0}' incorrectly implements interface '{1}'.": "类“{0}”错误实现接口“{1}”。",
        "A class may only implement another class or interface.": "类只能实现其他类或接口。",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.": "类“{0}”将“{1}”定义为实例成员函数，但扩展类“{2}”将其定义为实例成员访问器。",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.": "类“{0}”将“{1}”定义为实例成员函数，但扩展类“{2}”将其定义为实例成员属性。",
        "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.": "类“{0}”将“{1}”定义为实例成员属性，但扩展类“{2}”将其定义为实例成员函数。",
        "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.": "类“{0}”将“{1}”定义为实例成员访问器，但扩展类“{2}”将其定义为实例成员函数。",
        "Interface name cannot be '{0}'": "接口名不能为“{0}”",
        "All declarations of an interface must have identical type parameters.": "接口的所有声明必须具有相同的类型参数。",
        "Interface '{0}' incorrectly extends interface '{1}'.": "接口“{0}”错误扩展接口“{1}”。",
        "Enum name cannot be '{0}'": "枚举名不能为“{0}”",
        "In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.": "在包含多个声明的枚举中，只有一个声明可以省略其第一个枚举元素的初始值设定项。",
        "A namespace declaration cannot be in a different file from a class or function with which it is merged": "命名空间声明不能位于类中的其他文件或与之合并的函数中",
        "A namespace declaration cannot be located prior to a class or function with which it is merged": "命名空间声明不能位于类或与之合并的函数前",
        "Ambient modules cannot be nested in other modules.": "不能在其他模块中嵌套环境模块。",
        "Ambient module declaration cannot specify relative module name.": "环境模块声明无法指定相对模块名。",
        "Module '{0}' is hidden by a local declaration with the same name": "模块“{0}”被具有相同名称的局部声明隐藏",
        "Import name cannot be '{0}'": "导入名称不能为“{0}”",
        "Import or export declaration in an ambient module declaration cannot reference module through relative module name.": "环境模块声明中的导入或导出声明不能通过相对模块名引用模块。",
        "Import declaration conflicts with local declaration of '{0}'": "导入声明与“{0}”的局部声明冲突。",
        "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module.": "标识符“{0}”重复。编译器在模块的顶层范围中保留名称“{1}”。",
        "Types have separate declarations of a private property '{0}'.": "类型具有私有属性“{0}”的单独声明。",
        "Property '{0}' is protected but type '{1}' is not a class derived from '{2}'.": "属性“{0}”受保护，但类型“{1}”并不是从“{2}”派生的类。",
        "Property '{0}' is protected in type '{1}' but public in type '{2}'.": "属性“{0}”在类型“{1}”中受保护，但在类型“{2}”中为公共属性。",
        "Property '{0}' is protected and only accessible within class '{1}' and its subclasses.": "属性“{0}”受保护，只能在类“{1}”及其子类中访问。",
        "Property '{0}' is protected and only accessible through an instance of class '{1}'.": "属性“{0}”受保护，只能通过类“{1}”的实例访问。",
        "The '{0}' operator is not allowed for boolean types. Consider using '{1}' instead.": "“{0}”运算符不允许用于布尔类型。请考虑改用“{1}”。",
        "Block-scoped variable '{0}' used before its declaration.": "声明之前已使用的块范围变量“{0}”。",
        "The operand of an increment or decrement operator cannot be a constant.": "递增或递减运算符的操作数不能为常数。",
        "Left-hand side of assignment expression cannot be a constant.": "赋值表达式的左边不能为常数。",
        "Cannot redeclare block-scoped variable '{0}'.": "不能重新声明块范围变量“{0}”。",
        "An enum member cannot have a numeric name.": "枚举成员不能具有数值名。",
        "The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.": "无法从用法推断类型形参“{0}”的类型实参。可以考虑显式指定类型实参。",
        "Type argument candidate '{1}' is not a valid type argument because it is not a supertype of candidate '{0}'.": "候选类型参数“{1}”不是有效的类型参数，因为它不是候选“{0}”的超类型。",
        "Type alias '{0}' circularly references itself.": "类型别名“{0}”循环引用自身。",
        "Type alias name cannot be '{0}'": "类型别名不能为“{0}”",
        "An AMD module cannot have multiple name assignments.": "AMD 模块无法拥有多个名称分配。",
        "Type '{0}' has no property '{1}' and no string index signature.": "类型“{0}”不具有属性“{1}”和字符串索引签名。",
        "Type '{0}' has no property '{1}'.": "类型“{0}”不具有属性“{1}”。",
        "Type '{0}' is not an array type.": "类型“{0}”不是数组类型。",
        "A rest element must be last in an array destructuring pattern": "rest 元素必须在数组析构模式中位于最末",
        "A binding pattern parameter cannot be optional in an implementation signature.": "绑定模式参数在实现签名中不能为可选项。",
        "A computed property name must be of type 'string', 'number', 'symbol', or 'any'.": "计算属性名称的类型必须为 \"string\"、\"number\"、\"symbol\" 或 \"any\"。",
        "'this' cannot be referenced in a computed property name.": "不能在计算属性名称中引用 \"this\"。",
        "'super' cannot be referenced in a computed property name.": "不能在计算属性名称中引用 \"super\"。",
        "A computed property name cannot reference a type parameter from its containing type.": "计算属性名称无法从其包含的类型引用类型参数。",
        "Cannot find global value '{0}'.": "找不到全局值“{0}”。",
        "The '{0}' operator cannot be applied to type 'symbol'.": "“{0}”运算符不能应用于类型 \"symbol\"。",
        "'Symbol' reference does not refer to the global Symbol constructor object.": "\"Symbol\" 引用不是指全局符号构造函数对象。",
        "A computed property name of the form '{0}' must be of type 'symbol'.": "窗体“{0}”的计算属性名称必须是 \"symbol\" 类型。",
        "Spread operator in 'new' expressions is only available when targeting ECMAScript 5 and higher.": "仅当面向 ECMAScript 5 及更高版本时，\"new\" 表达式中的展开运算符才可用。",
        "Enum declarations must all be const or non-const.": "枚举声明都必须是常数或非常数。",
        "In 'const' enum declarations member initializer must be constant expression.": "\"const\" 枚举声明成员初始值设定项必须是常量表达式。",
        "'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment.": "\"const\" 枚举仅可在属性、索引访问表达式、导入声明的右边或导出分配中使用。",
        "A const enum member can only be accessed using a string literal.": "仅可使用字符串文本才能访问 const 枚举成员。",
        "'const' enum member initializer was evaluated to a non-finite value.": "\"const\" 枚举成员初始值设定项被评估为非有限值。",
        "'const' enum member initializer was evaluated to disallowed value 'NaN'.": "\"const\" 枚举成员初始值设定项被评估为不允许使用的值 \"NaN\"。",
        "Property '{0}' does not exist on 'const' enum '{1}'.": "\"const\" 枚举“{1}”上不存在属性“{0}”。",
        "'let' is not allowed to be used as a name in 'let' or 'const' declarations.": "\"let\" 不能用作 \"let\" 或 \"const\" 声明中的名称。",
        "Cannot initialize outer scoped variable '{0}' in the same scope as block scoped declaration '{1}'.": "不能在块范围声明“{1}”所在的范围内初始化外部范围变量“{0}”。",
        "The left-hand side of a 'for...of' statement cannot use a type annotation.": "\"for...of\" 语句的左边不能使用类型批注。",
        "Export declaration conflicts with exported declaration of '{0}'": "导出声明与“{0}”的导出声明冲突",
        "The left-hand side of a 'for...of' statement cannot be a previously defined constant.": "\"for...of\" 语句的左边不能是以前定义的常量。",
        "The left-hand side of a 'for...in' statement cannot be a previously defined constant.": "\"for...in\" 语句的左边不能是以前定义的常量。",
        "Invalid left-hand side in 'for...of' statement.": "\"for...of\" 语句的左边无效。",
        "Type must have a '[Symbol.iterator]()' method that returns an iterator.": "类型必须具有返回迭代器的 \"[Symbol.iterator]()\" 方法。",
        "An iterator must have a 'next()' method.": "迭代器必须具有 \"next()\" 方法。",
        "The type returned by the 'next()' method of an iterator must have a 'value' property.": "迭代器的 \"next()\" 方法返回的类型必须具有 \"value\" 属性。",
        "The left-hand side of a 'for...in' statement cannot be a destructuring pattern.": "\"for...in\" 语句的左边不能为析构模式。",
        "Cannot redeclare identifier '{0}' in catch clause": "不能在 catch 子句中重新声明标识符“{0}”",
        "Tuple type '{0}' with length '{1}' cannot be assigned to tuple with length '{2}'.": "不能将长度为“{1}”的元组类型“{0}”分配给长度为“{2}”的元组。",
        "Using a string in a 'for...of' statement is only supported in ECMAScript 5 and higher.": "仅 ECMAScript 5 和更高版本支持在 \"for...of\" 语句中使用字符串。",
        "Type '{0}' is not an array type or a string type.": "类型“{0}”不是数组类型或字符串类型。",
        "The 'arguments' object cannot be referenced in an arrow function in ES3 and ES5. Consider using a standard function expression.": "ES3 和 ES5 中的箭头函数不能引用 \"arguments\" 对象。请考虑使用标准函数表达式。",
        "Module '{0}' resolves to a non-module entity and cannot be imported using this construct.": "模块“{0}”解析为非模块实体，且不能使用此构造导入。",
        "Module '{0}' uses 'export =' and cannot be used with 'export *'.": "模块“{0}”使用 \"export =\" 且无法与 \"export *\" 一起使用。",
        "An interface can only extend an identifier/qualified-name with optional type arguments.": "接口只能扩展具有可选类型参数的标识符/限定名称。",
        "A class can only implement an identifier/qualified-name with optional type arguments.": "类只能实现具有可选类型参数的标识符/限定名称。",
        "A rest element cannot contain a binding pattern.": "rest 元素不能包含绑定模式。",
        "'{0}' is referenced directly or indirectly in its own type annotation.": "“{0}”在其自身的类型批注中直接或间接引用。",
        "Cannot find namespace '{0}'.": "找不到命名空间“{0}”。",
        "No best common type exists among yield expressions.": "yield 表达式中不存在最佳通用类型。",
        "A generator cannot have a 'void' type annotation.": "生成器不能具有 \"void\" 类型注释。",
        "'{0}' is referenced directly or indirectly in its own base expression.": "在 “{0}” 自身的基表达式中直接或间接引用它。",
        "Type '{0}' is not a constructor function type.": "类型“{0}”不是构造函数类型。",
        "No base constructor has the specified number of type arguments.": "没有任何基构造函数具有指定数量的类型参数。",
        "Base constructor return type '{0}' is not a class or interface type.": "基构造函数返回类型“{0}”不是类或接口类型。",
        "Base constructors must all have the same return type.": "所有的基构造函数必须具有相同的返回类型。",
        "Cannot create an instance of the abstract class '{0}'.": "无法创建抽象类“{0}”的实例。",
        "Overload signatures must all be abstract or not abstract.": "重载签名必须全部为抽象签名或全部为非抽象签名。",
        "Abstract method '{0}' in class '{1}' cannot be accessed via super expression.": "无法通过 super 表达式访问“{1}”类中的“{0}”抽象方法。",
        "Classes containing abstract methods must be marked abstract.": "包含抽象方法的类必须标记为抽象。",
        "Non-abstract class '{0}' does not implement inherited abstract member '{1}' from class '{2}'.": "非抽象类“{0}”不能实现继承自“{2}”类的“{1}”抽象成员。",
        "All declarations of an abstract method must be consecutive.": "抽象方法的所有声明必须是连续的。",
        "Cannot assign an abstract constructor type to a non-abstract constructor type.": "无法将抽象构造函数类型分配给非抽象构造函数类型。",
        "Only an ambient class can be merged with an interface.": "只有环境类可以与接口合并。",
        "Duplicate identifier '{0}'. Compiler uses declaration '{1}' to support async functions.": "标识符“{0}”重复。编译器使用“{1}”声明来支持异步函数。",
        "Expression resolves to variable declaration '{0}' that compiler uses to support async functions.": "表达式解析为编译器用于支持异步函数的变量声明“{0}”。",
        "The 'arguments' object cannot be referenced in an async arrow function. Consider using a standard async function expression.": "无法在异步箭头函数中引用 \"arguments\" 对象。请考虑使用标准的异步函数表达式。",
        "'yield' expressions cannot be used in a parameter initializer.": "不能在参数初始值设定项中使用 \"yield\" 表达式。",
        "'await' expressions cannot be used in a parameter initializer.": "不能在参数初始值设定项中使用 \"await\" 表达式。",
        "JSX element attributes type '{0}' must be an object type.": "JSX 元素属性类型“{0}”必须为对象类型。",
        "The return type of a JSX element constructor must return an object type.": "JSX 元素构造函数的返回类型必须返回对象类型。",
        "JSX element implicitly has type 'any' because the global type 'JSX.Element' does not exist.": "JSX 元素隐式具有类型 \"any\"，因为不存在全局类型 \"JSX.Element\"。",
        "Property '{0}' in type '{1}' is not assignable to type '{2}'": "类型“{1}”中的属性“{0}”不可分配给类型“{2}”",
        "JSX element type '{0}' does not have any construct or call signatures.": "JSX 元素类型“{0}”不具有任何构造签名或调用签名。",
        "JSX element type '{0}' is not a constructor function for JSX elements.": "JSX 元素类型“{0}”不是 JSX 元素的构造函数。",
        "Property '{0}' of JSX spread attribute is not assignable to target property.": "JSK 展开属性的“{0}”属性不能分配给目标属性。",
        "JSX element class does not support attributes because it does not have a '{0}' property": "JSK 元素类不支持属性，因为它不具有“{0}”属性",
        "The global type 'JSX.{0}' may not have more than one property": "全局类型“JSX.{0}”不可以具有多个属性",
        "Cannot emit namespaced JSX elements in React": "无法发出 React 中带命名空间的 JSX 元素",
        "A member initializer in a 'const' enum declaration cannot reference members declared after it, including members defined in other 'const' enums.": "\"const\" 枚举声明中的成员初始值设定项无法引用在它之后声明的成员，包括在其他 \"const\" 枚举中定义的成员。",
        "Merged declaration '{0}' cannot include a default export declaration. Consider adding a separate 'export default {0}' declaration instead.": "合并声明“{0}”不能包含默认导出声明。请考虑改为添加一个独立的“导出默认 {0}”声明。",
        "Import declaration '{0}' is using private name '{1}'.": "导入声明“{0}”使用的是专用名称“{1}”。",
        "Type parameter '{0}' of exported class has or is using private name '{1}'.": "导出类的类型参数“{0}”当前具有或使用专用名称“{1}”。",
        "Type parameter '{0}' of exported interface has or is using private name '{1}'.": "导出接口中的类型参数“{0}”当前具有或使用专用名称“{1}”。",
        "Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.": "导出接口中的构造函数签名的类型参数“{0}”当前具有或使用专用名称“{1}”。",
        "Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'.": "导出接口中的调用函数的类型参数“{0}”当前具有或使用专用名称“{1}”。",
        "Type parameter '{0}' of public static method from exported class has or is using private name '{1}'.": "导出类中的公共静态方法的类型参数“{0}”当前具有或使用专用名称“{1}”。",
        "Type parameter '{0}' of public method from exported class has or is using private name '{1}'.": "导出类中的公共方法的类型参数“{0}”当前具有或使用专用名称“{1}”。",
        "Type parameter '{0}' of method from exported interface has or is using private name '{1}'.": "导出接口中的方法的类型参数“{0}”当前具有或使用专用名称“{1}”。",
        "Type parameter '{0}' of exported function has or is using private name '{1}'.": "导出函数的类型参数“{0}”当前具有或使用专用名称“{1}”。",
        "Implements clause of exported class '{0}' has or is using private name '{1}'.": "导出的类“{0}”的 Implements 子句当前具有或使用专用名称“{1}”。",
        "Extends clause of exported class '{0}' has or is using private name '{1}'.": "导出的类“{0}”的 extends 子句当前具有或使用专用名称“{1}”。",
        "Extends clause of exported interface '{0}' has or is using private name '{1}'.": "导出接口“{0}”的 extends 子句当前具有或使用专用名称“{1}”。",
        "Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named.": "导出的变量“{0}”当前具有或使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
        "Exported variable '{0}' has or is using name '{1}' from private module '{2}'.": "导出的变量“{0}”当前具有或使用私有模块“{2}”中的名称“{1}”。",
        "Exported variable '{0}' has or is using private name '{1}'.": "导出的变量“{0}”当前具有或使用专用名称“{1}”。",
        "Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.": "导出类中的公共静态属性“{0}”的返回类型当前具有或使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
        "Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'.": "导出类的公共静态属性“{0}”当前具有或使用外部模块“{2}”中的名称“{1}”。",
        "Public static property '{0}' of exported class has or is using private name '{1}'.": "导出类的公共静态属性“{0}”当前具有或使用专用名称“{1}”。",
        "Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.": "导出类的公共属性“{0}”当前具有或使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
        "Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'.": "导出类的公共属性“{0}”当前具有或使用私有模块“{2}”中的名称“{1}”。",
        "Public property '{0}' of exported class has or is using private name '{1}'.": "导出类的公共属性“{0}”当前具有或使用专用名称“{1}”。",
        "Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'.": "导出接口的属性“{0}”当前具有或使用私有模块“{2}”中的名称“{1}”。",
        "Property '{0}' of exported interface has or is using private name '{1}'.": "导出接口的属性“{0}”当前具有或使用专用名称“{1}”。",
        "Parameter '{0}' of public static property setter from exported class has or is using name '{1}' from private module '{2}'.": "导出类中的公共静态属性 setter 的参数“{0}”当前具有或使用私有模块“{2}”中的名称“{1}”。",
        "Parameter '{0}' of public static property setter from exported class has or is using private name '{1}'.": "导出类中的公共静态属性 setter 的参数“{0}”当前具有或使用专用名称“{1}”。",
        "Parameter '{0}' of public property setter from exported class has or is using name '{1}' from private module '{2}'.": "导出类中的公共属性 setter 的参数“{0}”当前具有或使用私有模块“{2}”中的名称“{1}”。",
        "Parameter '{0}' of public property setter from exported class has or is using private name '{1}'.": "导出类中的公共属性 setter 的参数“{0}”当前具有或使用专用名称“{1}”。",
        "Return type of public static property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.": "导出类中的公共静态属性 getter 的返回类型当前具有或使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
        "Return type of public static property getter from exported class has or is using name '{0}' from private module '{1}'.": "导出类中的公共静态属性 getter 的返回类型当前具有或使用私有模块“{1}”中的名称“{0}”。",
        "Return type of public static property getter from exported class has or is using private name '{0}'.": "导出类中的公共静态属性 getter 的返回类型当前具有或使用专用名称“{0}”。",
        "Return type of public property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.": "导出类中的公共属性 getter 的返回类型当前具有或使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
        "Return type of public property getter from exported class has or is using name '{0}' from private module '{1}'.": "导出类中的公共属性 getter 的返回类型当前具有或使用私有模块“{1}”中的名称“{0}”。",
        "Return type of public property getter from exported class has or is using private name '{0}'.": "导出类中的公共属性 getter 的返回类型当前具有或使用专用名称“{0}”。",
        "Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'.": "导出接口中的构造函数签名的返回类型当前具有或使用私有模块“{1}”中的名称“{0}”。",
        "Return type of constructor signature from exported interface has or is using private name '{0}'.": "导出接口中的构造函数签名的返回类型当前具有或使用自有名称“{0}”。",
        "Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'.": "导出接口中的调用函数签名的返回类型当前具有或使用私有模块“{1}”中的名称“{0}”。",
        "Return type of call signature from exported interface has or is using private name '{0}'.": "导出接口中的调用签名的返回类型当前具有或使用专用名称“{0}”。",
        "Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'.": "导出接口中的索引签名的返回类型当前具有或使用私有模块“{1}”中的名称“{0}”。",
        "Return type of index signature from exported interface has or is using private name '{0}'.": "导出接口中的索引签名的返回类型当前具有或使用专用名称“{0}”。",
        "Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named.": "导出类中的公共静态方法的返回类型当前具有或使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
        "Return type of public static method from exported class has or is using name '{0}' from private module '{1}'.": "导出类中的公共静态方法的返回类型当前具有或使用私有模块“{1}”中的名称“{0}”。",
        "Return type of public static method from exported class has or is using private name '{0}'.": "导出类中的公共静态方法的返回类型当前具有或使用专用名称“{0}”。",
        "Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named.": "导出类中的公共方法的返回类型当前具有或使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
        "Return type of public method from exported class has or is using name '{0}' from private module '{1}'.": "导出类中的公共方法的返回类型当前具有或使用私有模块“{1}”中的名称“{0}”。",
        "Return type of public method from exported class has or is using private name '{0}'.": "导出类中的公共方法的返回类型当前具有或使用专用名称“{0}”。",
        "Return type of method from exported interface has or is using name '{0}' from private module '{1}'.": "导出接口中的方法的返回类型当前具有或使用私有模块“{1}”中的名称“{0}”。",
        "Return type of method from exported interface has or is using private name '{0}'.": "导出接口中的方法的返回类型当前具有或使用专用名称“{0}”。",
        "Return type of exported function has or is using name '{0}' from external module {1} but cannot be named.": "导出函数的返回类型当前具有或使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
        "Return type of exported function has or is using name '{0}' from private module '{1}'.": "导出函数的返回类型当前具有或使用私有模块“{1}”中的名称“{0}”。",
        "Return type of exported function has or is using private name '{0}'.": "导出函数的返回类型当前具有或使用专用名称“{0}”。",
        "Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named.": "导出类中的构造函数的参数“{0}”当前具有或使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
        "Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'.": "导出类的构造函数的参数“{0}”当前具有或使用私有模块“{2}”中的名称“{1}”。",
        "Parameter '{0}' of constructor from exported class has or is using private name '{1}'.": "导出类中的构造函数的参数“{0}”当前具有或使用专用名称“{1}”。",
        "Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'.": "导出接口中的构造函数签名的参数“{0}”当前具有或使用私有模块“{2}”中的名称“{1}”。",
        "Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.": "导出接口中的构造函数签名的参数“{0}”当前具有或使用专用名称“{1}”。",
        "Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'.": "导出接口中的调用签名的参数“{0}”当前具有或使用私有模块“{2}”中的名称“{1}”。",
        "Parameter '{0}' of call signature from exported interface has or is using private name '{1}'.": "导出接口中的调用签名的参数“{0}”当前具有或使用专用名称“{1}”。",
        "Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named.": "导出类中的公共静态方法的参数“{0}”当前具有或使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
        "Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'.": "导出类中的公共静态方法的参数“{0}”当前具有或使用私有模块“{2}”中的名称“{1}”。",
        "Parameter '{0}' of public static method from exported class has or is using private name '{1}'.": "导出类中的公共静态方法的参数“{0}”当前具有或使用专用名称“{1}”。",
        "Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named.": "导出类中的公共方法的参数“{0}”当前具有或使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
        "Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'.": "导出类中的公共方法的参数“{0}”当前具有或使用私有模块“{2}”中的名称“{1}”。",
        "Parameter '{0}' of public method from exported class has or is using private name '{1}'.": "导出类中的公共方法的参数“{0}”当前具有或使用专用名称“{1}”。",
        "Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'.": "导出接口中的方法的参数“{0}”当前具有或使用私有模块“{2}”中的名称“{1}”。",
        "Parameter '{0}' of method from exported interface has or is using private name '{1}'.": "导出接口中的方法的参数“{0}”当前具有或使用专用名称“{1}”。",
        "Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named.": "导出函数的参数“{0}”当前具有或使用外部模块 {2} 中的名称“{1}”，但不能为其命名。",
        "Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'.": "导出函数的参数“{0}”当前具有或使用私有模块“{2}”中的名称“{1}”。",
        "Parameter '{0}' of exported function has or is using private name '{1}'.": "导出函数的参数“{0}”当前具有或使用专用名称“{1}”。",
        "Exported type alias '{0}' has or is using private name '{1}'.": "导出的类型别名“{0}”已经或正在使用专用名称“{1}”。",
        "Default export of the module has or is using private name '{0}'.": "模块的默认导出具有或正在使用专用名称“{0}”。",
        "Loop contains block-scoped variable '{0}' referenced by a function in the loop. This is only supported in ECMAScript 6 or higher.": "循环包含循环中的函数所引用的块范围变量“{0}”。仅 ECMAScript 6 或更高版本支持该功能。",
        "The current host does not support the '{0}' option.": "当前主机不支持“{0}”选项。",
        "Cannot find the common subdirectory path for the input files.": "找不到输入文件的公共子目录路径。",
        "Cannot read file '{0}': {1}": "无法读取文件“{0}”: {1}",
        "Unsupported file encoding.": "文件编码不受支持。",
        "Failed to parse file '{0}': {1}.": "未能分析文件“{0}”: {1}。",
        "Unknown compiler option '{0}'.": "未知编译器选项“{0}”。",
        "Compiler option '{0}' requires a value of type {1}.": "编译器选项“{0}”需要类型 {1} 的值。",
        "Could not write file '{0}': {1}": "无法编写文件“{0}”:{1}",
        "Option 'mapRoot' cannot be specified without specifying 'sourceMap' option.": "在不指定 \"sourceMap\" 选项的情况下，不能指定 \"mapRoot\" 选项。",
        "Option 'sourceRoot' cannot be specified without specifying 'sourceMap' option.": "在不指定 \"sourceMap\" 选项的情况下，不能指定 \"sourceRoot\" 选项。",
        "Option 'noEmit' cannot be specified with option 'out' or 'outDir'.": "选项 \"noEmit\" 不能与选项 \"out\" 或 \"outDir\" 一起指定。",
        "Option 'noEmit' cannot be specified with option 'declaration'.": "选项 \"noEmit\" 不能与选项 \"declaration\" 一起指定。",
        "Option 'project' cannot be mixed with source files on a command line.": "选项 \"project\" 在命令行上不能与源文件混合使用。",
        "Option 'declaration' cannot be specified with option 'isolatedModules'.": "选项 \"declaration\" 不能与选项 \"isolatedModules\" 一起指定。",
        "Option 'noEmitOnError' cannot be specified with option 'isolatedModules'.": "选项 \"noEmitOnError\" 不能与选项 \"isolatedModules\" 一起指定。",
        "Option 'out' cannot be specified with option 'isolatedModules'.": "选项 \"out\" 不能与选项 \"isolatedModules\" 一起指定。",
        "Option 'isolatedModules' can only be used when either option'--module' is provided or option 'target' is 'ES6' or higher.": "只能在提供选项 \"--module\" 或者选项 \"target\" 为 \"ES6\" 或更高版本的情况下使用选项 \"isolatedModules\"。",
        "Option 'sourceMap' cannot be specified with option 'inlineSourceMap'.": "选项 \"sourceMap\" 不能与选项 \"inlineSourceMap\" 一起指定。",
        "Option 'sourceRoot' cannot be specified with option 'inlineSourceMap'.": "选项 \"sourceRoot\" 不能与选项 \"inlineSourceMap\" 一起指定。",
        "Option 'mapRoot' cannot be specified with option 'inlineSourceMap'.": "选项 \"mapRoot\" 不能与选项 \"inlineSourceMap\" 一起指定。",
        "Option 'inlineSources' can only be used when either option '--inlineSourceMap' or option '--sourceMap' is provided.": "仅当提供了选项 \"--inlineSources\" 或选项 \"--sourceMap\" 时，才能使用选项 \"inlineSources\"。",
        "Concatenate and emit output to single file.": "连接输出并将其发出到单个文件。",
        "Generates corresponding '.d.ts' file.": "生成相应的 \".d.ts\" 文件。",
        "Specifies the location where debugger should locate map files instead of generated locations.": "指定调试器应放置映射文件的位置而不是生成的位置。",
        "Specifies the location where debugger should locate TypeScript files instead of source locations.": "指定调试器应放置 TypeScript 文件的位置而不是源位置。",
        "Watch input files.": "监视输入文件。",
        "Redirect output structure to the directory.": "将输出结构重定向到目录。",
        "Do not erase const enum declarations in generated code.": "请勿清除生成代码中的常量枚举声明。",
        "Do not emit outputs if any errors were reported.": "如果报告了任何错误，请勿发出输出。",
        "Do not emit comments to output.": "请勿将注释发到输出中。",
        "Do not emit outputs.": "不要发出输出。",
        "Specify ECMAScript target version: 'ES3' (default), 'ES5', or 'ES6' (experimental)": "指定 ECMAScript 目标版本: \"ES3\"(默认)、\"ES5\" 或 \"ES6\"(实验)",
        "Specify module code generation: 'commonjs', 'amd', 'system' or 'umd'": "指定模块代码生成: \"commonjs\"、\"amd\"、\"system\" 或 \"umd\"。",
        "Print this message.": "打印此消息。",
        "Print the compiler's version.": "打印编译器的版本。",
        "Compile the project in the given directory.": "在指定目录中编译项目。",
        "Syntax: {0}": "语法:{0}",
        "options": "选项",
        "file1": "文件",
        "Examples: {0}": "示例:{0}",
        "Options:": "选项:",
        "Version {0}": "版本 {0}",
        "Insert command line options and files from a file.": "从文件插入命令行选项和文件。",
        "File change detected. Starting incremental compilation...": "检测到文件更改。正在启动增量编译...",
        "KIND": "种类",
        "file2": "文件",
        "VERSION": "版本",
        "LOCATION": "位置",
        "DIRECTORY": "目录",
        "Compilation complete. Watching for file changes.": "编译完成。查看文件更改。",
        "Generates corresponding '.map' file.": "生成相应的 \".map\" 文件。",
        "Compiler option '{0}' expects an argument.": "编译器选项“{0}”需要参数。",
        "Unterminated quoted string in response file '{0}'.": "响应文件“{0}”中引号不配对。",
        "Argument for '--module' option must be 'commonjs', 'amd', 'system' or 'umd'.": "\"--module\" 选项的参数必须是 \"commonjs\"、\"amd\"、\"system\" 或 \"umd\"。",
        "Argument for '--target' option must be 'ES3', 'ES5', or 'ES6'.": "\"--target\" 选项的参数必须是 \"ES3\"、\"ES5\" 或 \"ES6\"。",
        "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.": "区域设置必须采用 <语言> 或 <语言>-<区域> 形式。例如“{0}”或“{1}”。",
        "Unsupported locale '{0}'.": "不受支持的区域设置“{0}”。",
        "Unable to open file '{0}'.": "无法打开文件“{0}”。",
        "Corrupted locale file {0}.": "区域设置文件 {0} 已损坏。",
        "Raise error on expressions and declarations with an implied 'any' type.": "对具有隐式 \"any\" 类型的表达式和声明引发错误。",
        "File '{0}' not found.": "未找到文件“{0}”。",
        "File '{0}' has unsupported extension. The only supported extensions are {1}.": "不支持文件“{0}”的扩展名。唯一支持的扩展名为 {1}。",
        "Suppress noImplicitAny errors for indexing objects lacking index signatures.": "抑制缺少索引签名的索引对象的 noImplicitAny 错误。",
        "Do not emit declarations for code that has an '@internal' annotation.": "不要对具有 \"@internal\" 批注的代码发出声明。",
        "Specifies the root directory of input files. Use to control the output directory structure with --outDir.": "指定输入文件的根目录。与 --outDir 一起用于控制输出目录结构。",
        "File '{0}' is not under 'rootDir' '{1}'. 'rootDir' is expected to contain all source files.": "文件“{0}”不在 \"rootDir\"“{1}”下。\"rootDir\" 应包含所有源文件。",
        "Specifies the end of line sequence to be used when emitting files: 'CRLF' (dos) or 'LF' (unix).": "指定发出文件时要使用的行序列结尾: \"CRLF\" (dos)或 \"LF\" (unix)。",
        "NEWLINE": "换行符",
        "Argument for '--newLine' option must be 'CRLF' or 'LF'.": "\"--newLine\" 选项的参数必须是 \"CRLF\" 或 \"LF\"。",
        "Specify JSX code generation: 'preserve' or 'react'": "指定 JSX 代码生成: \"preserve\" 或 \"react\"",
        "Argument for '--jsx' must be 'preserve' or 'react'.": "\"--jsx\" 的参数必须为 \"preserve\" 或 \"react\"。",
        "Option 'experimentalDecorators' must also be specified when option 'emitDecoratorMetadata' is specified.": "指定了选项 \"emitDecoratorMetadata\" 时，还必须指定选项 \"experimentalDecorators\"。",
        "Enables experimental support for ES7 decorators.": "对 ES7 修饰器启用实验支持。",
        "Enables experimental support for emitting type metadata for decorators.": "对发出修饰器的类型元数据启用实验支持。",
        "Option 'experimentalAsyncFunctions' cannot be specified when targeting ES5 or lower.": "面向 ES5 或更低版本时不能指定选项 \"experimentalAsyncFunctions\"。",
        "Enables experimental support for ES7 async functions.": "对 ES7 异步函数启用实验支持。",
        "Variable '{0}' implicitly has an '{1}' type.": "变量“{0}”隐式具有“{1}”类型。",
        "Parameter '{0}' implicitly has an '{1}' type.": "参数“{0}”隐式具有“{1}”类型。",
        "Member '{0}' implicitly has an '{1}' type.": "成员“{0}”隐式地含有类型“{1}”。",
        "'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.": "其目标缺少构造签名的 \"new\" 表达式隐式具有 \"any\" 类型。",
        "'{0}', which lacks return-type annotation, implicitly has an '{1}' return type.": "缺少返回类型批注的“{0}”隐式具有“{1}”返回类型。",
        "Function expression, which lacks return-type annotation, implicitly has an '{0}' return type.": "缺少返回类型批注的函数表达式隐式具有“{0}”返回类型。",
        "Construct signature, which lacks return-type annotation, implicitly has an 'any' return type.": "缺少返回类型批注的构造签名隐式具有返回类型 \"any\"。",
        "Property '{0}' implicitly has type 'any', because its 'set' accessor lacks a type annotation.": "属性“{0}”隐式具有类型 \"any\"，因为其 \"set\" 访问器缺少类型批注。 ",
        "Index signature of object type implicitly has an 'any' type.": "对象类型的索引签名隐式地含有 \"any\" 类型。",
        "Object literal's property '{0}' implicitly has an '{1}' type.": "对象文字的属性“{0}”隐式含有“{1}”类型。",
        "Rest parameter '{0}' implicitly has an 'any[]' type.": "Rest 参数“{0}”隐式具有 \"any[]\" 类型。",
        "Call signature, which lacks return-type annotation, implicitly has an 'any' return type.": "缺少返回类型批注的调用签名隐式具有返回类型 \"any\"。",
        "'{0}' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.": "“{0}”隐式具有类型 \"any\"，因为它不具有类型注释，且在其自身的初始值设定项中直接或间接引用它。",
        "'{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.": "由于“{0}'”不具有返回类型批注并且在它的一个返回表达式中得到直接或间接引用，因此它隐式具有返回类型 \"any\"。",
        "Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.": "由于函数不具有返回类型批注并且在它的一个返回表达式中得到直接或间接引用，因此它隐式具有返回类型 \"any\"。",
        "Generator implicitly has type '{0}' because it does not yield any values. Consider supplying a return type.": "生成器隐式具有类型“{0}”，因为它不生成任何值。请考虑提供一个返回类型。",
        "JSX element implicitly has type 'any' because no interface 'JSX.{0}' exists": "JSX 元素隐式具有类型 \"any\"，因为不存在接口“JSX.{0}”",
        "You cannot rename this element.": "无法重命名此元素。",
        "You cannot rename elements that are defined in the standard TypeScript library.": "不能重命名标准 TypeScript 库中定义的元素。",
        "'import ... =' can only be used in a .ts file.": "\"import ... =\" 只能在 .ts 文件中使用。",
        "'export=' can only be used in a .ts file.": "\"export=\" 只能在 .ts 文件中使用。",
        "'type parameter declarations' can only be used in a .ts file.": "\"type parameter declarations\" 只能在 .ts 文件中使用。",
        "'implements clauses' can only be used in a .ts file.": "\"implements clauses\" 只能在 .ts 文件中使用。",
        "'interface declarations' can only be used in a .ts file.": "\"interface declarations\" 只能在 .ts 文件中使用。",
        "'module declarations' can only be used in a .ts file.": "\"module declarations\" 只能在 .ts 文件中使用。",
        "'type aliases' can only be used in a .ts file.": "\"type aliases\" 只能在 .ts 文件中使用。",
        "'{0}' can only be used in a .ts file.": "“{0}”只能在 .ts 文件中使用。",
        "'types' can only be used in a .ts file.": "\"types\" 只能在 .ts 文件中使用。",
        "'type arguments' can only be used in a .ts file.": "\"type arguments\" 只能在 .ts 文件中使用。",
        "'parameter modifiers' can only be used in a .ts file.": "\"parameter modifiers\" 只能在 .ts 文件中使用。",
        "'property declarations' can only be used in a .ts file.": "\"property declarations\" 只能在 .ts 文件中使用。",
        "'enum declarations' can only be used in a .ts file.": "\"enum declarations\" 只能在 .ts 文件中使用。",
        "'type assertion expressions' can only be used in a .ts file.": "\"type assertion expressions\" 只能在 .ts 文件中使用。",
        "'decorators' can only be used in a .ts file.": "\"decorators\" 只能在 .ts 文件中使用。",
        "Only identifiers/qualified-names with optional type arguments are currently supported in a class 'extends' clauses.": "类 \"extends\" 子句当前只支持具有可选类型参数的标识符/限定名称。",
        "'class' expressions are not currently supported.": "当前不支持 \"class\" 表达式。",
        "JSX attributes must only be assigned a non-empty 'expression'.": "只能为 JSX 属性分配非空“表达式”。",
        "JSX elements cannot have multiple attributes with the same name.": "JSX 元素不能具有多个名称相同的属性。",
        "Expected corresponding JSX closing tag for '{0}'.": "“{0}”预期的相应 JSK 结束标记。",
        "JSX attribute expected.": "需要 JSX 属性。",
        "Cannot use JSX unless the '--jsx' flag is provided.": "无法使用 JSX，除非提供了 \"--jsx\" 标志。",
        "A constructor cannot contain a 'super' call when its class extends 'null'": "当构造函数的类扩展 \"null\" 时，它不能包含 \"super\" 调用。"
}